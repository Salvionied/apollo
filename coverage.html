
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apollo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Salvionied/apollo/ApolloBuilder.go (60.2%)</option>
				
				<option value="file1">github.com/Salvionied/apollo/Models.go (46.6%)</option>
				
				<option value="file2">github.com/Salvionied/apollo/Utils.go (100.0%)</option>
				
				<option value="file3">github.com/Salvionied/apollo/apollotypes/plutus.go (0.0%)</option>
				
				<option value="file4">github.com/Salvionied/apollo/apollotypes/types.go (0.0%)</option>
				
				<option value="file5">github.com/Salvionied/apollo/backends.go (12.5%)</option>
				
				<option value="file6">github.com/Salvionied/apollo/crypto/bech32/crypto.go (0.0%)</option>
				
				<option value="file7">github.com/Salvionied/apollo/crypto/bip32/utils.go (0.0%)</option>
				
				<option value="file8">github.com/Salvionied/apollo/crypto/bip32/xprv.go (0.0%)</option>
				
				<option value="file9">github.com/Salvionied/apollo/crypto/bip32/xpub.go (0.0%)</option>
				
				<option value="file10">github.com/Salvionied/apollo/crypto/ed25519/ed25519.go (0.0%)</option>
				
				<option value="file11">github.com/Salvionied/apollo/crypto/edwards25519/edwards25519.go (0.0%)</option>
				
				<option value="file12">github.com/Salvionied/apollo/crypto/edwards25519/verify.go (0.0%)</option>
				
				<option value="file13">github.com/Salvionied/apollo/plutusencoder/customtypes.go (62.1%)</option>
				
				<option value="file14">github.com/Salvionied/apollo/plutusencoder/plutus.go (65.6%)</option>
				
				<option value="file15">github.com/Salvionied/apollo/serialization/Address/Address.go (97.3%)</option>
				
				<option value="file16">github.com/Salvionied/apollo/serialization/Amount/Amount.go (100.0%)</option>
				
				<option value="file17">github.com/Salvionied/apollo/serialization/Asset/Asset.go (100.0%)</option>
				
				<option value="file18">github.com/Salvionied/apollo/serialization/AssetName/AssetName.go (100.0%)</option>
				
				<option value="file19">github.com/Salvionied/apollo/serialization/Certificate/Certificate.go (65.3%)</option>
				
				<option value="file20">github.com/Salvionied/apollo/serialization/Fingerprint/Fingerprint.go (61.5%)</option>
				
				<option value="file21">github.com/Salvionied/apollo/serialization/HDWallet/HDWallet.go (78.3%)</option>
				
				<option value="file22">github.com/Salvionied/apollo/serialization/Key/Key.go (80.3%)</option>
				
				<option value="file23">github.com/Salvionied/apollo/serialization/Metadata/Metadata.go (83.9%)</option>
				
				<option value="file24">github.com/Salvionied/apollo/serialization/MultiAsset/MultiAsset.go (94.3%)</option>
				
				<option value="file25">github.com/Salvionied/apollo/serialization/NativeScript/NativeScript.go (90.9%)</option>
				
				<option value="file26">github.com/Salvionied/apollo/serialization/PlutusData/PlutusData.go (14.8%)</option>
				
				<option value="file27">github.com/Salvionied/apollo/serialization/Policy/Policy.go (60.0%)</option>
				
				<option value="file28">github.com/Salvionied/apollo/serialization/Redeemer/Redeemer.go (100.0%)</option>
				
				<option value="file29">github.com/Salvionied/apollo/serialization/Relay/Relay.go (83.8%)</option>
				
				<option value="file30">github.com/Salvionied/apollo/serialization/Transaction/Transaction.go (83.3%)</option>
				
				<option value="file31">github.com/Salvionied/apollo/serialization/TransactionBody/TransactionBody.go (76.5%)</option>
				
				<option value="file32">github.com/Salvionied/apollo/serialization/TransactionInput/TransactionInput.go (100.0%)</option>
				
				<option value="file33">github.com/Salvionied/apollo/serialization/TransactionOutput/TransactionOutput.go (84.2%)</option>
				
				<option value="file34">github.com/Salvionied/apollo/serialization/TransactionWitnessSet/TransactionWitnessSet.go (61.1%)</option>
				
				<option value="file35">github.com/Salvionied/apollo/serialization/UTxO/UTxO.go (100.0%)</option>
				
				<option value="file36">github.com/Salvionied/apollo/serialization/Value/Value.go (83.3%)</option>
				
				<option value="file37">github.com/Salvionied/apollo/serialization/Withdrawal/Withdrawal.go (0.0%)</option>
				
				<option value="file38">github.com/Salvionied/apollo/serialization/common.go (0.0%)</option>
				
				<option value="file39">github.com/Salvionied/apollo/testUtils/testUtils.go (0.0%)</option>
				
				<option value="file40">github.com/Salvionied/apollo/txBuilding/Backend/Base/Base.go (0.0%)</option>
				
				<option value="file41">github.com/Salvionied/apollo/txBuilding/Backend/BlockFrostChainContext/BlockFrostChainContext.go (35.4%)</option>
				
				<option value="file42">github.com/Salvionied/apollo/txBuilding/Backend/Cache/Cache.go (0.0%)</option>
				
				<option value="file43">github.com/Salvionied/apollo/txBuilding/Backend/FixedChainContext/FixedChainContext.go (0.0%)</option>
				
				<option value="file44">github.com/Salvionied/apollo/txBuilding/Backend/MaestroChainContext/MaestroChainContext.go (0.0%)</option>
				
				<option value="file45">github.com/Salvionied/apollo/txBuilding/Backend/OgmiosChainContext/OgmiosChainContext.go (26.1%)</option>
				
				<option value="file46">github.com/Salvionied/apollo/txBuilding/Backend/UtxorpcChainContext/UtxorpcChainContext.go (45.6%)</option>
				
				<option value="file47">github.com/Salvionied/apollo/txBuilding/Errors/Errors.go (0.0%)</option>
				
				<option value="file48">github.com/Salvionied/apollo/txBuilding/TxBuilder/TxBuilder.go (0.0%)</option>
				
				<option value="file49">github.com/Salvionied/apollo/txBuilding/Utils/Utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apollo

import (
        "bytes"
        "crypto/ed25519"
        "encoding/hex"
        "errors"
        "fmt"
        "slices"
        "strconv"

        "github.com/Salvionied/apollo/apollotypes"
        "github.com/Salvionied/apollo/constants"
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Amount"
        "github.com/Salvionied/apollo/serialization/Certificate"
        "github.com/Salvionied/apollo/serialization/HDWallet"
        "github.com/Salvionied/apollo/serialization/Key"
        "github.com/Salvionied/apollo/serialization/Metadata"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/NativeScript"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionBody"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/TransactionWitnessSet"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/Value"
        "github.com/Salvionied/apollo/serialization/VerificationKeyWitness"
        "github.com/Salvionied/apollo/serialization/Withdrawal"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/Salvionied/apollo/txBuilding/Utils"
        "github.com/fxamacker/cbor/v2"
)

const (
        EX_MEMORY_BUFFER = 0.2
        EX_STEP_BUFFER   = 0.2
        STAKE_DEPOSIT    = 2_000_000
)

type Apollo struct {
        Context            Base.ChainContext
        payments           []PaymentI
        isEstimateRequired bool
        auxiliaryData      *Metadata.AuxiliaryData
        utxos              []UTxO.UTxO
        preselectedUtxos   []UTxO.UTxO
        inputAddresses     []Address.Address
        tx                 *Transaction.Transaction
        datums             []PlutusData.PlutusData
        requiredSigners    []serialization.PubKeyHash
        v1scripts          []PlutusData.PlutusV1Script
        v2scripts          []PlutusData.PlutusV2Script
        v3scripts          []PlutusData.PlutusV3Script
        redeemers          []Redeemer.Redeemer
        redeemersToUTxO    map[string]Redeemer.Redeemer
        stakeRedeemers     map[string]Redeemer.Redeemer
        mintRedeemers      map[string]Redeemer.Redeemer
        mint               []Unit
        collaterals        []UTxO.UTxO
        Fee                int64
        FeePadding         int64
        Ttl                int64
        ValidityStart      int64
        collateralAmount   int
        totalCollateral    int
        referenceInputs    []TransactionInput.TransactionInput
        referenceInputsV3  []TransactionInput.TransactionInput
        collateralReturn   *TransactionOutput.TransactionOutput
        withdrawals        *Withdrawal.Withdrawal
        certificates       *Certificate.Certificates
        nativescripts      []NativeScript.NativeScript
        usedUtxos          []string
        referenceScripts   []PlutusData.ScriptHashable
        wallet             apollotypes.Wallet
        scriptHashes       []string
}

/*
*

        New creates and initializes a new Apollo instance with the specified chain context,


        in which sets up various internal data structures for building and handling transactions.

        Params:


                cc (Base.ChainContext): The chain context to use for transaction building.

        Returns:
                *Apollo: A pointer to the initialized Apollo instance.
*/
func New(cc Base.ChainContext) *Apollo <span class="cov8" title="1">{
        return &amp;Apollo{
                Context:            cc,
                payments:           []PaymentI{},
                isEstimateRequired: false,
                auxiliaryData:      &amp;Metadata.AuxiliaryData{},
                utxos:              []UTxO.UTxO{},
                preselectedUtxos:   []UTxO.UTxO{},
                inputAddresses:     []Address.Address{},
                tx:                 nil,
                datums:             make([]PlutusData.PlutusData, 0),
                requiredSigners:    make([]serialization.PubKeyHash, 0),
                v1scripts:          make([]PlutusData.PlutusV1Script, 0),
                v2scripts:          make([]PlutusData.PlutusV2Script, 0),
                redeemers:          make([]Redeemer.Redeemer, 0),
                redeemersToUTxO:    make(map[string]Redeemer.Redeemer),
                stakeRedeemers:     make(map[string]Redeemer.Redeemer),
                mint:               make([]Unit, 0),
                collaterals:        make([]UTxO.UTxO, 0),
                Fee:                0,
                FeePadding:         0,
                usedUtxos:          make([]string, 0),
                referenceInputs:    make([]TransactionInput.TransactionInput, 0),
                referenceInputsV3:  make([]TransactionInput.TransactionInput, 0),
                referenceScripts:   make([]PlutusData.ScriptHashable, 0),
                mintRedeemers:      make(map[string]Redeemer.Redeemer)}
}</span>

/*
*

        GetWallet returns the wallet associated with the Apollo instance.

        Returns:
                apollotypes.Wallet: The wallet associated with the Apollo instance.
*/
func (b *Apollo) GetWallet() apollotypes.Wallet <span class="cov0" title="0">{
        return b.wallet
}</span>

/*
*

        AddInput appends one or more UTxOs to the list of preselected
        UTxOs for transaction inputs.

        Params:
                utxos (...UTxO.UTxO): A set of UTxOs to be added as inputs.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddInput(utxos ...UTxO.UTxO) *Apollo <span class="cov8" title="1">{
        b.preselectedUtxos = append(b.preselectedUtxos, utxos...)
        for _, utxo := range utxos </span><span class="cov8" title="1">{
                b.usedUtxos = append(b.usedUtxos, utxo.GetKey())
        }</span>
        <span class="cov8" title="1">return b</span>
}

/*
*

        ConsumeUTxO adds a UTxO as an input to the transaction and deducts the specified payments from it.

        Params:
                utxo (UTxO.UTxO): The UTxO to be consumed as an input.
                payments (...PaymentI): A sett of payments to be deducted from the UTxO.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) ConsumeUTxO(utxo UTxO.UTxO, payments ...PaymentI) *Apollo <span class="cov0" title="0">{
        b.preselectedUtxos = append(b.preselectedUtxos, utxo)
        selectedValue := utxo.Output.GetAmount()
        for _, payment := range payments </span><span class="cov0" title="0">{
                selectedValue = selectedValue.Sub(payment.ToValue())
        }</span>
        <span class="cov0" title="0">if selectedValue.Less(Value.Value{}) </span><span class="cov0" title="0">{
                panic("selected value is negative")</span>
        }
        <span class="cov0" title="0">b.payments = append(b.payments, payments...)
        selectedValue = selectedValue.RemoveZeroAssets()
        p := NewPaymentFromValue(utxo.Output.GetAddress(), selectedValue)
        b.payments = append(b.payments, p)
        return b</span>
}

/*
*

                ConsumeAssetsFromUtxo adds a UTxO as an input to the transaction and deducts the specified asset payments from it.

                 Params:
                           utxo (UTxO.UTxO): The UTxO to be consumed as an input.


                           payments (...PaymentI): Asset payments to be deducted from the UTxO.

                 Returns:
                           *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) ConsumeAssetsFromUtxo(
        utxo UTxO.UTxO,
        payments ...PaymentI,
) *Apollo <span class="cov0" title="0">{
        b.preselectedUtxos = append(b.preselectedUtxos, utxo)
        selectedValue := utxo.Output.GetAmount()
        for _, payment := range payments </span><span class="cov0" title="0">{
                selectedValue = selectedValue.Sub(
                        Value.SimpleValue(0, payment.ToValue().GetAssets()),
                )
        }</span>
        <span class="cov0" title="0">if selectedValue.Less(Value.Value{}) </span><span class="cov0" title="0">{
                panic("selected value is negative")</span>
        }
        <span class="cov0" title="0">b.payments = append(b.payments, payments...)
        selectedValue = selectedValue.RemoveZeroAssets()
        p := NewPaymentFromValue(utxo.Output.GetAddress(), selectedValue)
        b.payments = append(b.payments, p)
        return b</span>
}

/*
*

        AddLoadedUTxOs appends one or more UTxOs to the list of loaded UTxOs.

        Params:
                utxos (...UTxO.UTxO): A set of UTxOs to be added to the loaded UTxOs.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddLoadedUTxOs(utxos ...UTxO.UTxO) *Apollo <span class="cov8" title="1">{
        b.utxos = append(b.utxos, utxos...)
        return b
}</span>

/*
*

        AddInputAddress appends an input address to the list of input addresses for the transaction.

        Params:
                address (Address.Address): The input address to be added.

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddInputAddress(address Address.Address) *Apollo <span class="cov0" title="0">{
        b.inputAddresses = append(b.inputAddresses, address)
        return b

}</span>

/*
*

        AddInputAddressFromBech32 decodes a Bech32 address and
        appends it to the list of input addresses for the transaction.

        Params:
                address (string): The Bech32 address to be decoded and added

        Returns:
                *Apollo: A pointer to the modified Apollo instance.
*/
func (b *Apollo) AddInputAddressFromBech32(address string) *Apollo <span class="cov8" title="1">{
        decoded_addr, _ := Address.DecodeAddress(address)
        b.inputAddresses = append(b.inputAddresses, decoded_addr)
        return b
}</span>

/*
*

        AddPayment appends a payment to the list of payments for the transaction.

        Params:
                payment (PaymentI): The payment to be added.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the payment added.
*/
func (b *Apollo) AddPayment(payment PaymentI) *Apollo <span class="cov8" title="1">{
        b.payments = append(b.payments, payment)
        return b
}</span>

/*
*

        PayToAddressBech32 creates a payment to the specified Bech32 address
        with the given lovelace and units.

        Params:
                address (string): The Bech32 address to which the payment will be made.
                lovelace (int): The amount in lovelace to be paid.
                units (...Unit): The units (assets) to be paid along with the lovelace.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the payment added.
*/
func (b *Apollo) PayToAddressBech32(
        address string,
        lovelace int,
        units ...Unit,
) *Apollo <span class="cov8" title="1">{
        decoded_addr, _ := Address.DecodeAddress(address)
        return b.AddPayment(
                &amp;Payment{lovelace, decoded_addr, units, nil, nil, false},
        )
}</span>

/*
*

                PayToAddress creates a payment to the specified address with the given lovelace and units,
                then adds it to the list of payment.

                Params:
                        address (Address.Address): The recipient's address for the payment.
                           lovelace (int): The amount in lovelace to send in the payment.
                           units (...Unit): A set of units to include in the payment.

                Returns:


        *Apollo: A pointer to the modified Apollo instance with the payment added.
*/
func (b *Apollo) PayToAddress(
        address Address.Address,
        lovelace int,
        units ...Unit,
) *Apollo <span class="cov0" title="0">{
        return b.AddPayment(&amp;Payment{lovelace, address, units, nil, nil, false})
}</span>

/*
*

                AddDatum appends a Plutus datum to the list of data associated with the Apollo instance.

                Params:
                           pd (*PlutusData.PlutusData): The Plutus datum to be added.

                Returns:


        *Apollo: A pointer to the modified Apollo instance with the datum added.
*/
func (b *Apollo) AddDatum(pd *PlutusData.PlutusData) *Apollo <span class="cov8" title="1">{
        b.datums = append(b.datums, *pd)
        return b
}</span>

/*
*

        PayToContract creates a payment to a smart contract address and includes a Plutus datum, which


                 is added to the list of payments, and if a datum is provided, it is added to the data list.

                Params:


        contractAddress (Address.Address): The smart contract address to send the payment to.
        pd (*PlutusData.PlutusData): Plutus datum to include in the payment.
        lovelace (int): The amount in lovelace to send in the payment.
        isInline (bool): Indicates if the payment is inline with the datum.
        units (...Unit): A set of units to include in the payment.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the payment and datum added.
*/
func (b *Apollo) PayToContract(
        contractAddress Address.Address,
        pd *PlutusData.PlutusData,
        lovelace int,
        isInline bool,
        units ...Unit,
) *Apollo <span class="cov8" title="1">{
        if isInline </span><span class="cov0" title="0">{
                b = b.AddPayment(
                        &amp;Payment{lovelace, contractAddress, units, pd, nil, isInline},
                )
        }</span> else<span class="cov8" title="1"> if pd != nil </span><span class="cov8" title="1">{
                dataHash, _ := PlutusData.PlutusDataHash(pd)
                b = b.AddPayment(&amp;Payment{lovelace, contractAddress, units, pd, dataHash.Payload, isInline})
        }</span> else<span class="cov0" title="0"> {
                b = b.AddPayment(&amp;Payment{lovelace, contractAddress, units, nil, nil, isInline})
        }</span>
        <span class="cov8" title="1">if pd != nil &amp;&amp; !isInline </span><span class="cov8" title="1">{
                b = b.AddDatum(pd)
        }</span>
        <span class="cov8" title="1">return b</span>
}

/*
*

        AddRequiredSignerFromBech32 decodes an address in Bech32 format and adds
        its payment and staking parts as required signers.

        Params:


        address (string): The Bech32-encoded address to decode and add its parts as required signers.


        addPaymentPart (bool): Indicates whether to add the payment part as a required signer.


                           addStakingPart (bool): Indicates whether to add the staking part as a required signer.

                Returns:


        *Apollo: A pointer to the modified Apollo instance with the required signers added.
*/
func (b *Apollo) AddRequiredSignerFromBech32(
        address string,
        addPaymentPart, addStakingPart bool,
) *Apollo <span class="cov0" title="0">{
        decoded_addr, _ := Address.DecodeAddress(address)
        if addPaymentPart </span><span class="cov0" title="0">{
                b.requiredSigners = append(
                        b.requiredSigners,
                        serialization.PubKeyHash(decoded_addr.PaymentPart[0:28]),
                )

        }</span>
        <span class="cov0" title="0">if addStakingPart </span><span class="cov0" title="0">{
                b.requiredSigners = append(
                        b.requiredSigners,
                        serialization.PubKeyHash(decoded_addr.StakingPart[0:28]),
                )
        }</span>
        <span class="cov0" title="0">return b</span>

}

/*
*

                AddRequiredSigner appends a public key hash to the list of required signers.

                 Params:


                          pkh (serialization.PubKeyHash): The public key hash to add as a required signer.

                Returns:


        *Apollo: A pointer to the modified Apollo instance with the required signer added.
*/
func (b *Apollo) AddRequiredSigner(pkh serialization.PubKeyHash) *Apollo <span class="cov0" title="0">{
        b.requiredSigners = append(b.requiredSigners, pkh)
        return b
}</span>

/*
*

                AddRequiredSignerFromAddress extracts the payment and staking parts from an address and adds them as required signers.

                 Params:


        address (Address.Address): The address from which to extract the parts and add them as required signers.


        addPaymentPart (bool): Indicates whether to add the payment part as a required signer.


                          addStakingPart (bool): Indicates whether to add the staking part as a required signer.

                Returns:


        *Apollo: A pointer to the modified Apollo instance with the required signers added.
*/
func (b *Apollo) AddRequiredSignerFromAddress(
        address Address.Address,
        addPaymentPart, addStakingPart bool,
) *Apollo <span class="cov0" title="0">{
        if addPaymentPart </span><span class="cov0" title="0">{
                pkh := serialization.PubKeyHash(address.PaymentPart)

                b.requiredSigners = append(b.requiredSigners, pkh)

        }</span>
        <span class="cov0" title="0">if addStakingPart </span><span class="cov0" title="0">{
                pkh := serialization.PubKeyHash(address.StakingPart)

                b.requiredSigners = append(b.requiredSigners, pkh)

        }</span>
        <span class="cov0" title="0">return b</span>
}

func (b *Apollo) SetFeePadding(padding int64) *Apollo <span class="cov0" title="0">{
        b.FeePadding = padding
        return b
}</span>

/**
buildOutputs constructs and returns the transaction outputs based on the payments.

Returns:
        []TransactionOutput.TransactionOutput: A slice of transaction outputs.
*/

func (b *Apollo) buildOutputs() []TransactionOutput.TransactionOutput <span class="cov8" title="1">{
        outputs := make([]TransactionOutput.TransactionOutput, 0)
        for _, payment := range b.payments </span><span class="cov8" title="1">{
                outputs = append(outputs, *payment.ToTxOut())
        }</span>
        <span class="cov8" title="1">return outputs</span>

}

/*
*

        buildWitnessSet constructs and returns the witness set for the transaction.

        Returns:


        TransactionWitnessSet.TransactionWitnessSet: The transaction's witness set.
*/
func (b *Apollo) buildWitnessSet() TransactionWitnessSet.TransactionWitnessSet <span class="cov8" title="1">{
        plutusdata := make([]PlutusData.PlutusData, 0)
        plutusdata = append(plutusdata, b.datums...)
        return TransactionWitnessSet.TransactionWitnessSet{
                NativeScripts:  b.nativescripts,
                PlutusV1Script: b.v1scripts,
                PlutusV2Script: b.v2scripts,
                PlutusV3Script: b.v3scripts,
                PlutusData:     PlutusData.PlutusIndefArray(plutusdata),
                Redeemer:       b.redeemers,
        }
}</span>

/*
*

        buildFakeWitnessSet constructs and returns a fake witness set used for testing.

        Returns:
                TransactionWitnessSet.TransactionWitnessSet: A fake witness set for testing.
*/
func (b *Apollo) buildFakeWitnessSet() TransactionWitnessSet.TransactionWitnessSet <span class="cov8" title="1">{
        plutusdata := make([]PlutusData.PlutusData, 0)
        plutusdata = append(plutusdata, b.datums...)
        fakeVkWitnesses := make([]VerificationKeyWitness.VerificationKeyWitness, 0)
        fakeVkWitnesses = append(
                fakeVkWitnesses,
                VerificationKeyWitness.VerificationKeyWitness{
                        Vkey:      constants.FAKE_VKEY,
                        Signature: constants.FAKE_SIGNATURE},
        )
        for range b.requiredSigners </span><span class="cov0" title="0">{
                fakeVkWitnesses = append(
                        fakeVkWitnesses,
                        VerificationKeyWitness.VerificationKeyWitness{
                                Vkey:      constants.FAKE_VKEY,
                                Signature: constants.FAKE_SIGNATURE},
                )
        }</span>
        <span class="cov8" title="1">return TransactionWitnessSet.TransactionWitnessSet{
                NativeScripts:  b.nativescripts,
                PlutusV1Script: b.v1scripts,
                PlutusV2Script: b.v2scripts,
                PlutusV3Script: b.v3scripts,
                PlutusData:     PlutusData.PlutusIndefArray(plutusdata),
                Redeemer:       b.redeemers,
                VkeyWitnesses:  fakeVkWitnesses,
        }</span>
}

/**
scriptDataHash computes the hash of script data based on redeemers and datums.

Returns:
        *serialization.ScriptDataHash: The computed script data hash.
        error: An error if the scriptDataHash fails.
*/

func (b *Apollo) scriptDataHash() (*serialization.ScriptDataHash, error) <span class="cov8" title="1">{
        if len(b.datums) == 0 &amp;&amp; len(b.redeemers) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">redeemers := b.redeemers
        PV1Scripts := b.v1scripts
        PV2Scripts := b.v2scripts
        PV3Scripts := b.v3scripts
        datums := b.datums
        usedCms := map[any]cbor.Marshaler{}
        if len(redeemers) &gt; 0 </span><span class="cov8" title="1">{
                if len(PV1Scripts) &gt; 0 </span><span class="cov8" title="1">{
                        usedCms[serialization.CustomBytes{Value: "00"}] = PlutusData.PLUTUSV1COSTMODEL
                }</span>
                <span class="cov8" title="1">if len(PV2Scripts) &gt; 0 || len(b.referenceInputs) &gt; 0 </span><span class="cov0" title="0">{
                        usedCms[1] = PlutusData.PLUTUSV2COSTMODEL
                }</span>
                <span class="cov8" title="1">if len(PV3Scripts) &gt; 0 || len(b.referenceInputsV3) &gt; 0 </span><span class="cov0" title="0">{
                        usedCms[2] = PlutusData.PLUTUSV3COSTMODEL
                }</span>

        }

        <span class="cov8" title="1">var redeemer_bytes []byte
        if len(redeemers) == 0 </span><span class="cov8" title="1">{
                redeemer_bytes, _ = hex.DecodeString("a0")
        }</span> else<span class="cov8" title="1"> {
                redeemer_bytes, _ = cbor.Marshal(redeemers)
        }</span>
        <span class="cov8" title="1">var err error
        var datum_bytes []byte
        if len(datums) &gt; 0 </span><span class="cov8" title="1">{

                datum_bytes, err = cbor.Marshal(PlutusData.PlutusIndefArray(datums))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                datum_bytes = []byte{}
        }</span>
        <span class="cov8" title="1">var cost_model_bytes []byte
        cost_model_bytes, _ = cbor.Marshal(usedCms)
        total_bytes := append(redeemer_bytes, datum_bytes...)
        // //total_bytes := redeemer_bytes
        // // Compute all versions of the hash
        // // with pv1
        // clmsBytsV1, _ := cbor.Marshal(PlutusData.COST_MODELSV1)
        // tbytesP1 := append(total_bytes, clmsBytsV1...)
        // fmt.Println("TOTAL_BYTES", hex.EncodeToString(tbytesP1))
        // hashP1, err := serialization.Blake2bHash(tbytesP1)
        // if err != nil {
        //         return nil, err
        // }
        // //fmt.Println("PRE_HASH_PV1", hex.EncodeToString(tbytesP1))
        // fmt.Println("HASH_PV1", hex.EncodeToString(hashP1))
        // // with pv2
        // clmsBytsV2, _ := cbor.Marshal(map[int]cbor.Marshaler{1: PlutusData.PLUTUSV2COSTMODEL})
        // tbytesP2 := append(total_bytes, clmsBytsV2...)
        // hashP2, err := serialization.Blake2bHash(tbytesP2)
        // if err != nil {
        //         return nil, err
        // }
        // //fmt.Println("PRE_HASH_PV2", hex.EncodeToString(tbytesP2))
        // fmt.Println("HASH_PV2", hex.EncodeToString(hashP2))
        // // No Pv version
        // clmsNoHash, _ := hex.DecodeString("a0")
        // tbytesNoHash := append(total_bytes, clmsNoHash...)
        // hashNoHash, err := serialization.Blake2bHash(tbytesNoHash)
        // if err != nil {
        //         return nil, err
        // }
        // //fmt.Println("PRE_HASH_NO_HASH", hex.EncodeToString(tbytesNoHash))
        // fmt.Println("HASH_NO_HASH", hex.EncodeToString(hashNoHash))
        total_bytes = append(total_bytes, cost_model_bytes...)
        hash, err := serialization.Blake2bHash(total_bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // fmt.Println("PRE_HASH", hex.EncodeToString(total_bytes))
        // fmt.Println("HASH", hex.EncodeToString(hash))
        <span class="cov8" title="1">return &amp;serialization.ScriptDataHash{Payload: hash}, nil</span>

}

/*
*

        getMints returns the multi-assets generated from minting.

        Returns:
                MultiAsset.MultiAsset[int64]: The generated multi-assets.
*/
func (b *Apollo) getMints() MultiAsset.MultiAsset[int64] <span class="cov8" title="1">{
        ma := make(MultiAsset.MultiAsset[int64])
        for _, mintUnit := range b.mint </span><span class="cov8" title="1">{
                ma = ma.Add(mintUnit.ToValue().GetAssets())
        }</span>
        <span class="cov8" title="1">return ma</span>
}

/*
*

        MintAssets adds a minting unit to the transaction's minting set.

        Params:
                mintUnit Unit: The minting unit to add.

        Returns:
                *Apollo: A pointer to the Apollo object to support method chaining.
*/
func (b *Apollo) MintAssets(mintUnit Unit) *Apollo <span class="cov8" title="1">{
        b.mint = append(b.mint, mintUnit)
        return b
}</span>

/*
*

        MintAssetsWithRedeemer adds a minting unit with an associated redeemer to the transaction's minting set.

        Params:
                mintUnit Unit: The minting unit to add.


                redeemer Redeemer.Redeemer: The redeemer associated with the minting unit.

        Returns:
                *Apollo: A pointer to the Apollo object with the minting unit added.
*/
func (b *Apollo) MintAssetsWithRedeemer(
        mintUnit Unit,
        redeemer Redeemer.Redeemer,
) *Apollo <span class="cov0" title="0">{
        b.mint = append(b.mint, mintUnit)
        b.mintRedeemers[mintUnit.PolicyId+mintUnit.Name] = redeemer
        b.isEstimateRequired = true
        return b
}</span>

/**
buildTxBody constructs and returns the transaction body for the transaction.

Returns:
        TransactionBody.TransactionBody: The transaction body.
        error: An error if the build fails.
*/

func (b *Apollo) buildTxBody() (TransactionBody.TransactionBody, error) <span class="cov8" title="1">{
        inputs := make([]TransactionInput.TransactionInput, 0)
        for _, utxo := range b.preselectedUtxos </span><span class="cov8" title="1">{
                inputs = append(inputs, utxo.Input)
        }</span>
        <span class="cov8" title="1">collaterals := make([]TransactionInput.TransactionInput, 0)
        for _, utxo := range b.collaterals </span><span class="cov8" title="1">{
                collaterals = append(collaterals, utxo.Input)
        }</span>
        <span class="cov8" title="1">dataHash, err := b.scriptDataHash()
        if err != nil </span><span class="cov0" title="0">{
                return TransactionBody.TransactionBody{}, err
        }</span>
        <span class="cov8" title="1">scriptDataHash := make([]byte, 0)
        if dataHash != nil </span><span class="cov8" title="1">{
                scriptDataHash = dataHash.Payload
        }</span>
        <span class="cov8" title="1">aux_data_hash := b.auxiliaryData.Hash()
        mints := b.getMints()
        txb := TransactionBody.TransactionBody{
                Inputs:            inputs,
                Outputs:           b.buildOutputs(),
                Fee:               b.Fee,
                Ttl:               b.Ttl,
                Mint:              mints,
                AuxiliaryDataHash: aux_data_hash,
                ScriptDataHash:    scriptDataHash,
                RequiredSigners:   b.requiredSigners,
                ValidityStart:     b.ValidityStart,
                Collateral:        collaterals,
                Certificates:      b.certificates,
                Withdrawals:       b.withdrawals,
                ReferenceInputs:   append(b.referenceInputs, b.referenceInputsV3...),
        }
        if b.totalCollateral != 0 </span><span class="cov8" title="1">{
                txb.TotalCollateral = b.totalCollateral
                txb.CollateralReturn = b.collateralReturn
        }</span>
        <span class="cov8" title="1">return txb, nil</span>
}

func (b *Apollo) SetCertificates(c *Certificate.Certificates) *Apollo <span class="cov0" title="0">{
        b.certificates = c
        return b
}</span>

/*
*

        buildFullFakeTx constructs and returns a full fake transaction for testing.

        Returns:
                *Transaction.Transaction: A pointer to the fake transaction.
                error: An error if the transaction construction fails.
*/
func (b *Apollo) buildFullFakeTx() (*Transaction.Transaction, error) <span class="cov8" title="1">{
        txBody, err := b.buildTxBody()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if txBody.Fee == 0 </span><span class="cov8" title="1">{
                maxFee, err := b.Context.MaxTxFee()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">txBody.Fee = int64(maxFee)</span>
        }
        <span class="cov8" title="1">witness := b.buildFakeWitnessSet()
        tx := Transaction.Transaction{
                TransactionBody:       txBody,
                TransactionWitnessSet: witness,
                Valid:                 true,
                AuxiliaryData:         b.auxiliaryData}
        bytes, _ := tx.Bytes()
        pp, err := b.Context.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(bytes) &gt; pp.MaxTxSize </span><span class="cov0" title="0">{
                return nil, errors.New("transaction too large")
        }</span>
        <span class="cov8" title="1">return &amp;tx, nil</span>
}

/*
*

        estimateFee estimates the transaction fee based on execution units and transaction size.

        Returns:
                int64: The estimated transaction fee.
*/
func (b *Apollo) estimateFee() (int64, error) <span class="cov8" title="1">{
        pExU := Redeemer.ExecutionUnits{Mem: 0, Steps: 0}
        for _, redeemer := range b.redeemers </span><span class="cov8" title="1">{
                pExU.Sum(redeemer.ExUnits)
        }</span>
        <span class="cov8" title="1">for _, mintRedeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                pExU.Sum(mintRedeemer.ExUnits)
        }</span>
        <span class="cov8" title="1">for _, stakeRedeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                pExU.Sum(stakeRedeemer.ExUnits)
        }</span>
        <span class="cov8" title="1">fftx, err := b.buildFullFakeTx()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">fakeTxBytes, _ := fftx.Bytes()
        fakeTxLength := len([]byte(hex.EncodeToString(fakeTxBytes)))
        estimatedFee, err := Utils.Fee(
                b.Context,
                fakeTxLength,
                pExU.Steps,
                pExU.Mem,
                fftx.TransactionBody.ReferenceInputs,
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">estimatedFee += b.FeePadding
        return estimatedFee, nil</span>

}

/*
*

        getAvailableUtxos returns the available unspent transaction outputs (UTXOs) for the transaction.

        Returns:
                []UTxO.UTxO: A slice of available UTXOs.
*/
func (b *Apollo) getAvailableUtxos() []UTxO.UTxO <span class="cov8" title="1">{
        availableUtxos := make([]UTxO.UTxO, 0)
        for _, utxo := range b.utxos </span><span class="cov8" title="1">{
                if !slices.Contains(b.usedUtxos, utxo.GetKey()) </span><span class="cov8" title="1">{
                        availableUtxos = append(availableUtxos, utxo)
                }</span>
        }
        <span class="cov8" title="1">return availableUtxos</span>
}

/*
*

        setRedeemerIndexes function sets indexes for redeemers in
        the transaction based on UTxO inputs.

        Returns:
                *Apollo: A pointer to the Apollo object with indexes and redeemers set.
*/
func (b *Apollo) setRedeemerIndexes() *Apollo <span class="cov8" title="1">{
        sorted_inputs := SortInputs(b.preselectedUtxos)
        for i, utxo := range sorted_inputs </span><span class="cov8" title="1">{
                key := hex.EncodeToString(
                        utxo.Input.TransactionId,
                ) + strconv.Itoa(
                        utxo.Input.Index,
                )
                val, ok := b.redeemersToUTxO[key]
                if ok &amp;&amp; val.Tag == Redeemer.SPEND </span><span class="cov8" title="1">{
                        redeem := b.redeemersToUTxO[key]
                        redeem.Index = i
                        b.redeemersToUTxO[key] = redeem
                }</span> else<span class="cov8" title="1"> if ok &amp;&amp; val.Tag == Redeemer.MINT </span><span class="cov0" title="0">{
                        // TODO: IMPLEMENT FOR MINTS
                        continue</span>
                }
        }
        <span class="cov8" title="1">return b</span>
}

/*
*

        AttachDatum attaches a datum to the transaction.

        Params:
                datum *PlutusData.PlutusData: The datum to attach.

        Returns:
                *Apollo: A pointer to the Apollo object with the datum added.
*/
func (b *Apollo) AttachDatum(datum *PlutusData.PlutusData) *Apollo <span class="cov8" title="1">{
        b.datums = append(b.datums, *datum)
        return b
}</span>

/**
setCollateral function sets collateral for the transaction.

Returns:
        *Apollo: A pointer to the Apollo object to support method chaining.
        error: An error if the setCollateral fails.
*/

func (b *Apollo) setCollateral() (*Apollo, error) <span class="cov8" title="1">{
        collateral_amount := 5_000_000

        if b.collateralAmount &gt; 0 </span><span class="cov0" title="0">{
                collateral_amount = b.collateralAmount
        }</span>

        <span class="cov8" title="1">if len(b.collaterals) &gt; 0 </span><span class="cov8" title="1">{
                for _, utxo := range b.collaterals </span><span class="cov8" title="1">{
                        if int(
                                utxo.Output.GetValue().GetCoin(),
                        ) &gt;= collateral_amount+1_000_000 &amp;&amp;
                                len(utxo.Output.GetValue().GetAssets()) &lt;= 5 </span><span class="cov0" title="0">{
                                b.totalCollateral = collateral_amount
                                return_amount := utxo.Output.GetValue().
                                        GetCoin() -
                                        int64(
                                                collateral_amount,
                                        )
                                returnOutput := TransactionOutput.SimpleTransactionOutput(
                                        b.inputAddresses[0],
                                        Value.SimpleValue(
                                                return_amount,
                                                utxo.Output.GetValue().GetAssets(),
                                        ),
                                )
                                b.collateralReturn = &amp;returnOutput
                        }</span>
                }
                <span class="cov8" title="1">return b, nil</span>
        }
        <span class="cov8" title="1">witnesses := b.buildWitnessSet()
        if len(witnesses.PlutusV1Script) == 0 &amp;&amp;
                len(witnesses.PlutusV2Script) == 0 &amp;&amp;
                len(
                        b.referenceInputs,
                ) == 0 &amp;&amp; len(witnesses.PlutusV3Script) == 0 &amp;&amp; len(b.referenceInputsV3) == 0 </span><span class="cov8" title="1">{
                return b, nil
        }</span>
        <span class="cov8" title="1">availableUtxos := b.getAvailableUtxos()

        for _, utxo := range availableUtxos </span><span class="cov8" title="1">{
                if int(utxo.Output.GetValue().GetCoin()) &gt;= collateral_amount &amp;&amp;
                        len(utxo.Output.GetValue().GetAssets()) &lt;= 5 </span><span class="cov8" title="1">{
                        return_amount := utxo.Output.GetValue().
                                GetCoin() -
                                int64(
                                        collateral_amount,
                                )
                        min_lovelace, err := Utils.MinLovelacePostAlonzo(
                                TransactionOutput.SimpleTransactionOutput(
                                        b.inputAddresses[0],
                                        Value.SimpleValue(
                                                return_amount,
                                                utxo.Output.GetAmount().GetAssets(),
                                        ),
                                ),
                                b.Context,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return b, err
                        }</span>
                        <span class="cov8" title="1">if min_lovelace &gt; return_amount &amp;&amp; return_amount != 0 </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov8" title="1"> if return_amount == 0 &amp;&amp; len(utxo.Output.GetAmount().GetAssets()) == 0 </span><span class="cov0" title="0">{
                                b.collaterals = append(b.collaterals, utxo)
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span> else<span class="cov8" title="1"> {
                                returnOutput := TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(return_amount, utxo.Output.GetValue().GetAssets()))
                                b.collaterals = append(b.collaterals, utxo)
                                b.collateralReturn = &amp;returnOutput
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, utxo := range availableUtxos </span><span class="cov0" title="0">{
                if int(utxo.Output.GetValue().GetCoin()) &gt;= collateral_amount </span><span class="cov0" title="0">{
                        return_amount := utxo.Output.GetValue().
                                GetCoin() -
                                int64(
                                        collateral_amount,
                                )
                        min_lovelace, err := Utils.MinLovelacePostAlonzo(
                                TransactionOutput.SimpleTransactionOutput(
                                        b.inputAddresses[0],
                                        Value.SimpleValue(
                                                return_amount,
                                                utxo.Output.GetAmount().GetAssets(),
                                        ),
                                ),
                                b.Context,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return b, err
                        }</span>
                        <span class="cov0" title="0">if min_lovelace &gt; return_amount &amp;&amp; return_amount != 0 </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> if return_amount == 0 &amp;&amp; len(utxo.Output.GetAmount().GetAssets()) == 0 </span><span class="cov0" title="0">{
                                b.collaterals = append(b.collaterals, utxo)
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span> else<span class="cov0" title="0"> {
                                returnOutput := TransactionOutput.SimpleTransactionOutput(b.inputAddresses[0], Value.SimpleValue(return_amount, utxo.Output.GetValue().GetAssets()))
                                b.collaterals = append(b.collaterals, utxo)
                                b.collateralReturn = &amp;returnOutput
                                b.totalCollateral = collateral_amount
                                return b, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return b, errors.New("NoCollateral")</span>
}

/*
*

        Clone creates a deep copy of the Apollo object.

        Returns:
                *Apollo: A pointer to the cloned Apollo object.
*/
func (b *Apollo) Clone() *Apollo <span class="cov8" title="1">{
        clone := *b
        return &amp;clone
}</span>

/*
*

        estimateExUnits estimates the execution units for redeemers and updates them.

        Returns:
                map[string]Redeemer.ExecutionUnits: A map of estimated execution units.
*/
func (b *Apollo) estimateExunits() (map[string]Redeemer.ExecutionUnits, error) <span class="cov8" title="1">{
        cloned_b := b.Clone()
        cloned_b.isEstimateRequired = false
        updated_b, err := cloned_b.Complete()
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]Redeemer.ExecutionUnits, 0), err
        }</span>
        //updated_b = updated_b.fakeWitness()
        <span class="cov8" title="1">tx_cbor, _ := cbor.Marshal(updated_b.tx)
        return b.Context.EvaluateTx(tx_cbor)</span>
}

/*
*

        updateExUnits updates the execution units in the transaction based on estimates.

        Returns:
                *Apollo: A pointer to the Apollo object to support method chaining.
*/
func (b *Apollo) updateExUnits() (*Apollo, error) <span class="cov8" title="1">{
        if b.isEstimateRequired </span><span class="cov8" title="1">{
                estimated_execution_units, err := b.estimateExunits()
                if err != nil </span><span class="cov0" title="0">{
                        return b, errors.New("could not estimate ExUnits")
                }</span>
                <span class="cov8" title="1">for k, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        key := fmt.Sprintf(
                                "%s:%d",
                                Redeemer.RedeemerTagNames[redeemer.Tag],
                                redeemer.Index,
                        )
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov8" title="1">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                redeemer.ExUnits.Mem = int64(
                                        float32(redeemer.ExUnits.Mem) * 1.2,
                                )
                                redeemer.ExUnits.Steps = int64(
                                        float32(redeemer.ExUnits.Steps) * 1.2,
                                )
                                b.redeemersToUTxO[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        key := fmt.Sprintf(
                                "%s:%d",
                                Redeemer.RedeemerTagNames[redeemer.Tag],
                                redeemer.Index,
                        )
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                redeemer.ExUnits.Mem = int64(
                                        float32(redeemer.ExUnits.Mem) * 1.2,
                                )
                                redeemer.ExUnits.Steps = int64(
                                        float32(redeemer.ExUnits.Steps) * 1.2,
                                )
                                b.stakeRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        key := fmt.Sprintf(
                                "%s:%d",
                                Redeemer.RedeemerTagNames[redeemer.Tag],
                                redeemer.Index,
                        )
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                redeemer.ExUnits.Mem = int64(
                                        float32(redeemer.ExUnits.Mem) * 1.2,
                                )
                                redeemer.ExUnits.Steps = int64(
                                        float32(redeemer.ExUnits.Steps) * 1.2,
                                )
                                b.mintRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)

                }</span>
        } else<span class="cov8" title="1"> {
                for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>

        }
        <span class="cov8" title="1">return b, nil</span>
}

/*
*

        GetTx returns the transaction associated with the Apollo object.

        Returns:
                *Transacction.Transaction: A pointer to the transaction.
*/
func (b *Apollo) GetTx() *Transaction.Transaction <span class="cov8" title="1">{
        return b.tx
}</span>

func CountRequiredAssets(assets MultiAsset.MultiAsset[int64]) int <span class="cov8" title="1">{
        count := 0
        for _, asset := range assets </span><span class="cov8" title="1">{
                for _, amt := range asset </span><span class="cov8" title="1">{
                        if amt &gt; 0 </span><span class="cov8" title="1">{
                                count++
                        }</span>
                }
        }
        <span class="cov8" title="1">return count</span>
}

/*
*

        Complete assembles and finalizes the Apollo transaction, handling
        inputs, change, fees, collateral and witness data.

        Returns:


        *Apollo: A pointer to the Apollo object representing the completed transaction.
        error: An error if any issues are encountered during the process.
*/
func (b *Apollo) Complete() (*Apollo, error) <span class="cov8" title="1">{
        selectedUtxos := make([]UTxO.UTxO, 0)
        selectedAmount := Value.Value{}
        for _, utxo := range b.preselectedUtxos </span><span class="cov8" title="1">{
                selectedAmount = selectedAmount.Add(utxo.Output.GetValue())
        }</span>
        <span class="cov8" title="1">burnedValue := b.GetBurns()
        mintedValue := b.getPositiveMints()
        selectedAmount = selectedAmount.Add(mintedValue)
        requestedAmount := Value.Value{}
        requestedAmount.Add(burnedValue)
        for _, payment := range b.payments </span><span class="cov8" title="1">{
                payment.EnsureMinUTXO(b.Context)
                requestedAmount = requestedAmount.Add(payment.ToValue())
        }</span>
        <span class="cov8" title="1">if b.certificates != nil </span><span class="cov0" title="0">{
                requestedAmount = requestedAmount.Add(
                        Value.PureLovelaceValue(
                                int64(STAKE_DEPOSIT * len(*b.certificates)),
                        ),
                )
        }</span>
        <span class="cov8" title="1">estimatedFee, err := b.estimateFee()
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov8" title="1">requestedAmount.AddLovelace(estimatedFee + constants.MIN_LOVELACE)
        unfulfilledAmount := requestedAmount.Sub(selectedAmount)
        unfulfilledAmount = unfulfilledAmount.RemoveZeroAssets()
        available_utxos := SortUtxos(b.getAvailableUtxos())
        //BALANCE TX
        requiredAssetsCount := CountRequiredAssets(unfulfilledAmount.GetAssets())
        if unfulfilledAmount.GetCoin() &gt; 0 || requiredAssetsCount &gt; 0 </span><span class="cov8" title="1">{
                //BALANCE
                if len(unfulfilledAmount.GetAssets()) &gt; 0 </span><span class="cov8" title="1">{
                        //BALANCE WITH ASSETS
                        for pol, assets := range unfulfilledAmount.GetAssets() </span><span class="cov8" title="1">{
                                for asset, amt := range assets </span><span class="cov8" title="1">{
                                        found := false
                                        selectedSoFar := int64(0)
                                        usedIdxs := make([]int, 0)
                                        for idx, utxo := range available_utxos </span><span class="cov8" title="1">{
                                                ma := utxo.Output.GetValue().GetAssets()
                                                if ma.GetByPolicyAndId(pol, asset) &gt;= amt </span><span class="cov8" title="1">{
                                                        selectedUtxos = append(selectedUtxos, utxo)
                                                        selectedAmount = selectedAmount.Add(
                                                                utxo.Output.GetValue(),
                                                        )
                                                        usedIdxs = append(usedIdxs, idx)
                                                        b.usedUtxos = append(b.usedUtxos, utxo.GetKey())
                                                        found = true
                                                        break</span>
                                                } else<span class="cov8" title="1"> if ma.GetByPolicyAndId(pol, asset) &gt; 0 </span><span class="cov0" title="0">{
                                                        selectedUtxos = append(selectedUtxos, utxo)
                                                        selectedAmount = selectedAmount.Add(utxo.Output.GetValue())
                                                        usedIdxs = append(usedIdxs, idx)
                                                        b.usedUtxos = append(b.usedUtxos, utxo.GetKey())
                                                        selectedSoFar += ma.GetByPolicyAndId(pol, asset)
                                                        if selectedSoFar &gt;= amt </span><span class="cov0" title="0">{
                                                                found = true
                                                                break</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">newAvailUtxos := make([]UTxO.UTxO, 0)
                                        for idx, availutxo := range available_utxos </span><span class="cov8" title="1">{
                                                if !slices.Contains(usedIdxs, idx) </span><span class="cov8" title="1">{
                                                        newAvailUtxos = append(newAvailUtxos, availutxo)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">available_utxos = newAvailUtxos
                                        if !found </span><span class="cov0" title="0">{
                                                return nil, errors.New("missing required assets")
                                        }</span>

                                }
                        }
                }
                <span class="cov8" title="1">for !selectedAmount.Greater(
                        requestedAmount.Add(
                                Value.Value{Am: Amount.Amount{}, Coin: 1_000_000, HasAssets: false},
                        ),
                ) </span><span class="cov8" title="1">{

                        if len(available_utxos) == 0 </span><span class="cov0" title="0">{
                                return nil, errors.New("not enough funds")
                        }</span>
                        <span class="cov8" title="1">utxo := available_utxos[0]
                        selectedUtxos = append(selectedUtxos, utxo)
                        selectedAmount = selectedAmount.Add(utxo.Output.GetValue())
                        available_utxos = available_utxos[1:]
                        b.usedUtxos = append(b.usedUtxos, utxo.GetKey())</span>
                }

        }
        // ADD NEW SELECTED INPUTS TO PRE SELECTION
        <span class="cov8" title="1">b.preselectedUtxos = append(b.preselectedUtxos, selectedUtxos...)

        //SET REDEEMER INDEXES
        b = b.setRedeemerIndexes()
        //SET COLLATERAL
        b, err = b.setCollateral()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //UPDATE EXUNITS
        <span class="cov8" title="1">b, err = b.updateExUnits()
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        //ADDCHANGEANDFEE
        <span class="cov8" title="1">b, err = b.addChangeAndFee()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //FINALIZE TX
        <span class="cov8" title="1">body, err := b.buildTxBody()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">witnessSet := b.buildWitnessSet()
        b.tx = &amp;Transaction.Transaction{
                TransactionBody:       body,
                TransactionWitnessSet: witnessSet,
                AuxiliaryData:         b.auxiliaryData,
                Valid:                 true,
        }
        return b, nil</span>
}

/*
*

        Check if adding change to a transaction output would exceed
        the UTxO limit for the given address.

        Params:
                change: The change amount to add.
                address: The address for which change is being calculated.
                b: The ChainContext providing protocol parameters.

        Returns:


        bool: True if adding change would exceed the UTXO limit, false otherwise.
*/
func isOverUtxoLimit(
        change Value.Value,
        address Address.Address,
        b Base.ChainContext,
) (bool, error) <span class="cov8" title="1">{
        txOutput := TransactionOutput.SimpleTransactionOutput(
                address,
                Value.SimpleValue(0, change.GetAssets()),
        )
        encoded, _ := cbor.Marshal(txOutput)
        pps, err := b.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">maxValSize, _ := strconv.Atoi(pps.MaxValSize)
        return len(encoded) &gt; maxValSize, nil</span>

}

/*
*

        Split payments into multiple payments if adding change
        exceeds the UTxO limit.

        Params:
                c: The change amount.
                a: The address to which change is being sent.
                b: The ChainContext providing protocol parameters.

        Returns:


        []*Payment: An array of payment objects, split if necessary to avoid exceeding the UTxO limit.
*/
func splitPayments(
        c Value.Value,
        a Address.Address,
        b Base.ChainContext,
) ([]*Payment, error) <span class="cov8" title="1">{
        lovelace := c.GetCoin()
        assets := c.GetAssets()
        payments := make([]*Payment, 0)
        newPayment := new(Payment)
        newPayment.Receiver = a
        newPayment.Lovelace = 0
        newPayment.Units = make([]Unit, 0)
        for policy, assets := range assets </span><span class="cov8" title="1">{
                for asset, amt := range assets </span><span class="cov8" title="1">{
                        isOver, err := isOverUtxoLimit(newPayment.ToValue(), a, b)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if !isOver </span><span class="cov8" title="1">{
                                if amt &gt; 0 </span><span class="cov8" title="1">{
                                        newPayment.Units = append(newPayment.Units, Unit{
                                                PolicyId: policy.String(),
                                                Name:     asset.String(),
                                                Quantity: int(amt),
                                        })
                                }</span>
                        } else<span class="cov8" title="1"> {

                                minLovelace, err := Utils.MinLovelacePostAlonzo(
                                        *newPayment.ToTxOut(), b)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">newPayment.Lovelace = int(minLovelace)
                                lovelace -= minLovelace
                                payments = append(payments, newPayment)
                                newPayment = new(Payment)
                                newPayment.Receiver = a
                                newPayment.Lovelace = 0
                                newPayment.Units = make([]Unit, 0)
                                if amt &gt; 0 </span><span class="cov8" title="1">{
                                        newPayment.Units = append(newPayment.Units, Unit{
                                                PolicyId: policy.String(),
                                                Name:     asset.String(),
                                                Quantity: int(amt),
                                        })
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">payments = append(payments, newPayment)

        payments[len(payments)-1].Lovelace += int(lovelace)
        totalCoin := 0
        for _, payment := range payments </span><span class="cov8" title="1">{
                totalCoin += payment.Lovelace
        }</span>
        <span class="cov8" title="1">return payments, nil</span>

}

func (b *Apollo) GetBurns() (burns Value.Value) <span class="cov8" title="1">{
        burns = Value.Value{}
        for _, mintUnit := range b.mint </span><span class="cov8" title="1">{
                if mintUnit.Quantity &lt; 0 </span><span class="cov8" title="1">{
                        usedUnit := Unit{
                                PolicyId: mintUnit.PolicyId,
                                Name:     mintUnit.Name,
                                Quantity: -mintUnit.Quantity,
                        }
                        burns = burns.Add(usedUnit.ToValue())
                }</span>

        }
        <span class="cov8" title="1">return burns</span>

}

func (b *Apollo) getPositiveMints() (mints Value.Value) <span class="cov8" title="1">{
        mints = Value.Value{}
        for _, mintUnit := range b.mint </span><span class="cov8" title="1">{
                if mintUnit.Quantity &gt; 0 </span><span class="cov0" title="0">{
                        usedUnit := Unit{
                                PolicyId: mintUnit.PolicyId,
                                Name:     mintUnit.Name,
                                Quantity: mintUnit.Quantity,
                        }
                        mints = mints.Add(usedUnit.ToValue())
                }</span>

        }
        <span class="cov8" title="1">return mints</span>

}

/*
*
Add change and fees to the transaction.

Returns:

        *Apollo: A pointer to the Apollo object with change and fees added.
        error: An error if addChangeAndFee fails.
*/
func (b *Apollo) addChangeAndFee() (*Apollo, error) <span class="cov8" title="1">{
        burns := b.GetBurns()
        mints := b.getPositiveMints()
        providedAmount := Value.Value{}
        for _, utxo := range b.preselectedUtxos </span><span class="cov8" title="1">{
                providedAmount = providedAmount.Add(utxo.Output.GetValue())
        }</span>
        <span class="cov8" title="1">providedAmount = providedAmount.Add(mints)
        requestedAmount := Value.Value{}
        for _, payment := range b.payments </span><span class="cov8" title="1">{
                requestedAmount = requestedAmount.Add(payment.ToValue())
        }</span>
        <span class="cov8" title="1">if b.certificates != nil </span><span class="cov0" title="0">{
                requestedAmount = requestedAmount.Add(
                        Value.PureLovelaceValue(
                                int64(STAKE_DEPOSIT * len(*b.certificates)),
                        ),
                )
        }</span>
        <span class="cov8" title="1">requestedAmount = requestedAmount.Add(burns)
        var err error
        b.Fee, err = b.estimateFee()
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>

        <span class="cov8" title="1">requestedAmount.AddLovelace(b.Fee)
        change := providedAmount.Sub(requestedAmount)
        minLovelaceRequired, err := Utils.MinLovelacePostAlonzo(
                TransactionOutput.SimpleTransactionOutput(
                        b.inputAddresses[0],
                        Value.SimpleValue(0, change.GetAssets()),
                ),
                b.Context,
        )
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov8" title="1">if change.GetCoin() &lt; minLovelaceRequired </span><span class="cov8" title="1">{
                if len(b.getAvailableUtxos()) == 0 </span><span class="cov0" title="0">{
                        return b, errors.New("no remaining UTxOs")
                }</span>
                <span class="cov8" title="1">sortedUtxos := SortUtxos(b.getAvailableUtxos())
                if len(sortedUtxos) == 0 </span><span class="cov0" title="0">{
                        return b, errors.New("no remaining UTxOs")
                }</span>
                <span class="cov8" title="1">b.preselectedUtxos = append(b.preselectedUtxos, sortedUtxos[0])
                b.usedUtxos = append(b.usedUtxos, sortedUtxos[0].GetKey())
                return b.addChangeAndFee()</span>
        }
        <span class="cov8" title="1">isOver, err := isOverUtxoLimit(change, b.inputAddresses[0], b.Context)
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov8" title="1">if isOver </span><span class="cov8" title="1">{
                adjustedPayments, err := splitPayments(
                        change,
                        b.inputAddresses[0],
                        b.Context,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return b, err
                }</span>
                <span class="cov8" title="1">pp := b.payments[:]
                for _, payment := range adjustedPayments </span><span class="cov8" title="1">{
                        b.payments = append(b.payments, payment)
                }</span>
                <span class="cov8" title="1">newestFee, err := b.estimateFee()
                if err != nil </span><span class="cov0" title="0">{
                        return b, err
                }</span>
                <span class="cov8" title="1">if newestFee &gt; b.Fee </span><span class="cov8" title="1">{
                        difference := newestFee - b.Fee
                        adjustedPayments[len(adjustedPayments)-1].Lovelace -= int(
                                difference,
                        )
                        b.Fee = newestFee
                        b.payments = pp
                        for _, payment := range adjustedPayments </span><span class="cov8" title="1">{
                                b.payments = append(b.payments, payment)
                        }</span>
                }

        } else<span class="cov8" title="1"> {
                payment := Payment{
                        Receiver: b.inputAddresses[0],
                        Lovelace: int(change.GetCoin()),
                        Units:    make([]Unit, 0),
                }
                for policy, assets := range change.GetAssets() </span><span class="cov8" title="1">{
                        for asset, amt := range assets </span><span class="cov8" title="1">{
                                if amt &gt; 0 </span><span class="cov8" title="1">{
                                        payment.Units = append(payment.Units, Unit{
                                                PolicyId: policy.String(),
                                                Name:     asset.String(),
                                                Quantity: int(amt),
                                        })
                                }</span>
                        }
                }
                <span class="cov8" title="1">pp := b.payments[:]
                b.payments = append(b.payments, &amp;payment)

                newestFee, err := b.estimateFee()
                if err != nil </span><span class="cov0" title="0">{
                        return b, err
                }</span>
                <span class="cov8" title="1">if newestFee &gt; b.Fee </span><span class="cov8" title="1">{
                        difference := newestFee - b.Fee
                        payment.Lovelace -= int(difference)
                        b.payments = append(pp, &amp;payment)
                        b.Fee = newestFee
                }</span>
        }
        <span class="cov8" title="1">return b, nil</span>
}

/*
*

        Collect a UTXO and its associated redeemer for inclusion in the transaction.

        Params:
                inputUtxo: The UTXO to collect.
                redeemer: The redeemer associated with the UTXO.

        Returns:


        *Apollo: A pointer to the Apollo object with the collected UTXO and redeemer.
*/
func (b *Apollo) CollectFrom(
        inputUtxo UTxO.UTxO,
        redeemer Redeemer.Redeemer,
) *Apollo <span class="cov8" title="1">{
        b.isEstimateRequired = true
        b.preselectedUtxos = append(b.preselectedUtxos, inputUtxo)
        b.usedUtxos = append(b.usedUtxos, inputUtxo.GetKey())
        b.redeemersToUTxO[hex.EncodeToString(inputUtxo.Input.TransactionId)+strconv.Itoa(inputUtxo.Input.Index)] = redeemer
        return b
}</span>

/*
*

        Attach a Plutus V1 script to the Apollo transaction.

        Params:
                script: The Plutus V1 script to attach.

        Returns:
                *Apollo: A pointer to the Apollo objecy with the attached script.
*/
func (b *Apollo) AttachV1Script(script PlutusData.PlutusV1Script) *Apollo <span class="cov8" title="1">{
        hash := PlutusData.PlutusScriptHash(script)
        if slices.Contains(b.scriptHashes, hex.EncodeToString(hash.Bytes())) </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">b.v1scripts = append(b.v1scripts, script)
        b.scriptHashes = append(b.scriptHashes, hex.EncodeToString(hash.Bytes()))

        return b</span>
}

/*
*

        Attach a Plutus V2 script to the Apollo transaction.

        Params:
                script: The Plutus V2 script to attach.

        Returns:
                *Apollo: A pointer to the Apollo objecy with the attached script.
*/
func (b *Apollo) AttachV2Script(script PlutusData.PlutusV2Script) *Apollo <span class="cov8" title="1">{
        hash := PlutusData.PlutusScriptHash(script)
        if slices.Contains(b.scriptHashes, hex.EncodeToString(hash.Bytes())) </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">b.v2scripts = append(b.v2scripts, script)
        b.scriptHashes = append(b.scriptHashes, hex.EncodeToString(hash.Bytes()))
        return b</span>
}

func (b *Apollo) AttachV3Script(script PlutusData.PlutusV3Script) *Apollo <span class="cov0" title="0">{
        hash := PlutusData.PlutusScriptHash(script)
        if slices.Contains(b.scriptHashes, hex.EncodeToString(hash.Bytes())) </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov0" title="0">b.v3scripts = append(b.v3scripts, script)
        b.scriptHashes = append(b.scriptHashes, hex.EncodeToString(hash.Bytes()))
        return b</span>
}

/**
Set the wallet for the Apollo transaction using a mnemonic.

Params:
        menmonic: The menomic phrase used to generate the wallet.

Returns:
        *Apollo: A pointer to the Apollo object with the wallet set.
        error: an error if setWalletFromMnemonic fails.
*/

func (a *Apollo) SetWalletFromMnemonic(
        mnemonic string,
        network constants.Network,
) (*Apollo, error) <span class="cov0" title="0">{
        paymentPath := "m/1852'/1815'/0'/0/0"
        stakingPath := "m/1852'/1815'/0'/2/0"
        hdWall, err := HDWallet.NewHDWalletFromMnemonic(mnemonic, "")
        if err != nil </span><span class="cov0" title="0">{
                return a, err
        }</span>
        <span class="cov0" title="0">paymentKeyPath, err := hdWall.DerivePath(paymentPath)
        if err != nil </span><span class="cov0" title="0">{
                return a, err
        }</span>
        <span class="cov0" title="0">verificationKey_bytes := paymentKeyPath.XPrivKey.PublicKey()
        signingKey_bytes := paymentKeyPath.XPrivKey.Bytes()
        stakingKeyPath, err := hdWall.DerivePath(stakingPath)
        if err != nil </span><span class="cov0" title="0">{
                return a, err
        }</span>
        <span class="cov0" title="0">stakeVerificationKey_bytes := stakingKeyPath.XPrivKey.PublicKey()
        stakeSigningKey_bytes := stakingKeyPath.XPrivKey.Bytes()
        //stake := stakingKeyPath.RootXprivKey.Bytes()
        signingKey := Key.SigningKey{Payload: signingKey_bytes}
        verificationKey := Key.VerificationKey{Payload: verificationKey_bytes}
        stakeSigningKey := Key.SigningKey{Payload: stakeSigningKey_bytes}
        stakeVerificationKey := Key.VerificationKey{
                Payload: stakeVerificationKey_bytes,
        }
        stakeVerKey := Key.VerificationKey{Payload: stakeVerificationKey_bytes}
        skh, _ := stakeVerKey.Hash()
        vkh, _ := verificationKey.Hash()

        var addr Address.Address
        if network == constants.MAINNET </span><span class="cov0" title="0">{
                addr = Address.Address{
                        StakingPart: skh[:],
                        PaymentPart: vkh[:],
                        Network:     1,
                        AddressType: Address.KEY_KEY,
                        HeaderByte:  0b00000001,
                        Hrp:         "addr",
                }
        }</span> else<span class="cov0" title="0"> {
                addr = Address.Address{StakingPart: skh[:], PaymentPart: vkh[:], Network: 0, AddressType: Address.KEY_KEY, HeaderByte: 0b00000000, Hrp: "addr_test"}
        }</span>
        <span class="cov0" title="0">wallet := apollotypes.GenericWallet{
                SigningKey:           signingKey,
                VerificationKey:      verificationKey,
                Address:              addr,
                StakeSigningKey:      stakeSigningKey,
                StakeVerificationKey: stakeVerificationKey,
        }
        a.wallet = &amp;wallet
        return a, nil</span>
}

// For use with key pairs generated by cardano-cli
func (a *Apollo) SetWalletFromKeypair(
        vkey string,
        skey string,
        network constants.Network,
) *Apollo <span class="cov0" title="0">{
        verificationKey_bytes, err := hex.DecodeString(vkey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("SetWalletFromKeypair: Failed to decode vkey")
        }</span>
        <span class="cov0" title="0">signingKey_bytes, err := hex.DecodeString(skey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("SetWalletFromKeypair: Failed to decode skey")
        }</span>
        // There are two slightly different interpretations of ed25519,
        // depending on which thing you call the "private key".
        // cardano-cli and the golang library crypto/ed25519 take opposite
        // interpretations. NewKeyFromSeed performs the necessary conversion.
        <span class="cov0" title="0">signingKey := Key.SigningKey{
                Payload: ed25519.NewKeyFromSeed(signingKey_bytes),
        }
        verificationKey := Key.VerificationKey{Payload: verificationKey_bytes}
        vkh, _ := verificationKey.Hash()

        var addr Address.Address
        if network == constants.MAINNET </span><span class="cov0" title="0">{
                addr = Address.Address{
                        StakingPart: nil,
                        PaymentPart: vkh[:],
                        Network:     1,
                        AddressType: Address.KEY_NONE,
                        HeaderByte:  0b01100001,
                        Hrp:         "addr",
                }
        }</span> else<span class="cov0" title="0"> {
                addr = Address.Address{StakingPart: nil, PaymentPart: vkh[:], Network: 0, AddressType: Address.KEY_NONE, HeaderByte: 0b01100000, Hrp: "addr_test"}
        }</span>
        <span class="cov0" title="0">wallet := apollotypes.GenericWallet{
                SigningKey:           signingKey,
                VerificationKey:      verificationKey,
                Address:              addr,
                StakeSigningKey:      Key.SigningKey{},
                StakeVerificationKey: Key.VerificationKey{},
        }
        a.wallet = &amp;wallet
        return a</span>
}

/*
*

        Set the wallet for the Apollo transaction using a Bech32 address.

        Params:
                address: The Bech32 address to use as the wallet.

        Returns:
                *Apollo: A pointer to the Apollo object with the wallet set.
*/
func (a *Apollo) SetWalletFromBech32(address string) *Apollo <span class="cov8" title="1">{
        addr, err := Address.DecodeAddress(address)
        if err != nil </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">a.wallet = &amp;apollotypes.ExternalWallet{Address: addr}
        return a</span>
}

/*
*

        Set the wallet as the change address for the Apollo transaction.

        Returns:


        *Apollo: A pointer to the Apollo object with the wallet set as the change address.
*/
func (b *Apollo) SetWalletAsChangeAddress() (*Apollo, error) <span class="cov8" title="1">{
        if b.wallet == nil </span><span class="cov0" title="0">{
                return b, errors.New("WALLET COULD NOT BE SET")
        }</span>
        <span class="cov8" title="1">b.inputAddresses = append(b.inputAddresses, *b.wallet.GetAddress())
        return b, nil</span>
}

/*
*

        Sign the Apollo transaction using the wallet's keys.

        Returns:
                *Apollo: A pointer to the Apollo object with the transaction signed.
*/
func (b *Apollo) Sign() *Apollo <span class="cov0" title="0">{
        signatures := b.wallet.SignTx(
                *b.tx,
                append(b.preselectedUtxos, b.collaterals...),
        )
        b.tx.TransactionWitnessSet = signatures
        return b
}</span>

/*
*

        Sign the Apollo transaction with the given verification key and signing key.

        Parameters:
                vkey: The verification key to sign with.
                skey: The signing key to sign with.

        Returns:
                *Apollo: A pointer to the Apollo object with the transaction signed.
                error: An error if the signing fails.
*/
func (b *Apollo) SignWithSkey(
        vkey Key.VerificationKey,
        skey Key.SigningKey,
) (*Apollo, error) <span class="cov0" title="0">{
        witness_set := b.GetTx().TransactionWitnessSet
        txHash, err := b.GetTx().TransactionBody.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov0" title="0">signature, err := skey.Sign(txHash)
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov0" title="0">witness_set.VkeyWitnesses = append(
                witness_set.VkeyWitnesses,
                VerificationKeyWitness.VerificationKeyWitness{
                        Vkey:      vkey,
                        Signature: signature,
                },
        )
        b.GetTx().TransactionWitnessSet = witness_set
        return b, nil</span>
}

/*
*

        Submit function submits the constructed transaction to the blockchain
        network using the associated chain context.

        Returns:
                serialization.TransactionId: The ID of the submitted transaction.
                error: An error, if any, encountered during transaction submission.
*/
func (b *Apollo) Submit() (serialization.TransactionId, error) <span class="cov0" title="0">{
        return b.Context.SubmitTx(*b.tx)
}</span>

/*
*

        LoadTxCbor loads a transaction from its CBOR representation and updates
        the apollo instances.

        Params:
                txCbor (string): The CBOR-encoded representation of the transaction.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the loaded transaction.
        error: An error, if any, encountered during loading.
*/
func (b *Apollo) LoadTxCbor(txCbor string) (*Apollo, error) <span class="cov0" title="0">{
        tx := Transaction.Transaction{}
        cborBytes, err := hex.DecodeString(txCbor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = cbor.Unmarshal(cborBytes, &amp;tx)
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        <span class="cov0" title="0">b.tx = &amp;tx
        return b, nil</span>
}

/*
*

        UtxoFromRef retrieves a UTxO (Unspent Transaction Output) given its transaction hash and index.

        Params:


        txHash (string): The hexadecimal representation of the transaction hash.


                          txIndex (int): The index of the UTxO within the transaction's outputs.

                Returns:
                          *UTxO.UTxO: A pointer to the retrieved UTxO, or nil if not found.
*/
func (b *Apollo) UtxoFromRef(txHash string, txIndex int) (*UTxO.UTxO, error) <span class="cov0" title="0">{
        utxo, err := b.Context.GetUtxoFromRef(txHash, txIndex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if utxo == nil </span><span class="cov0" title="0">{
                return nil, errors.New("UTXO Doesn't exist")
        }</span>
        <span class="cov0" title="0">return utxo, nil</span>

}

/*
*

        AddVerificationKeyWitness adds a verification key witness to the transaction.

        Params:


                vkw (VerificationKeyWitness.VerificationKeyWitness): The verification key witness to add.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the added verification key witness.
*/
func (b *Apollo) AddVerificationKeyWitness(
        vkw VerificationKeyWitness.VerificationKeyWitness,
) *Apollo <span class="cov0" title="0">{
        b.tx.TransactionWitnessSet.VkeyWitnesses = append(
                b.tx.TransactionWitnessSet.VkeyWitnesses,
                vkw,
        )
        return b
}</span>

/*
*

        SetChangeAddressBech32 sets the change address for the transaction using a Bech32-encoded address.

        Params:


                          address (string): The Bech32-encoded address to set as the change address.

                Returns:


        *Apollo: A pointer to the modified Apollo instance with the change address set.
*/
func (b *Apollo) SetChangeAddressBech32(address string) *Apollo <span class="cov8" title="1">{
        addr, err := Address.DecodeAddress(address)
        if err != nil </span><span class="cov0" title="0">{
                return b
        }</span>
        <span class="cov8" title="1">b.inputAddresses = append(b.inputAddresses, addr)
        return b</span>
}

/*
*

                SetChangeAddress sets the change address for the transaction using an Address object.

                 Params:


                   address (Address.Address): The Address object to set as the change address.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the change address set.
*/
func (b *Apollo) SetChangeAddress(address Address.Address) *Apollo <span class="cov8" title="1">{
        b.inputAddresses = append(b.inputAddresses, address)
        return b
}</span>

/*
*

        SetTtl function sets the time-to-live (TTL) for the transaction.

        Params:
                ttl (int64): The TTL value to set fro the transaction.

        Returns:
                *Apollo: A pointer to the modified Apollo instance with the TTl set.
*/
func (b *Apollo) SetTtl(ttl int64) *Apollo <span class="cov8" title="1">{
        b.Ttl = ttl
        return b
}</span>

/*
*

        SetValidityStart function sets the validity start for the transaction.

        Params:


                invalidBefore (int64): The validity start value to set for the transaction.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the validity start set.
*/
func (b *Apollo) SetValidityStart(invalidBefore int64) *Apollo <span class="cov8" title="1">{
        b.ValidityStart = invalidBefore
        return b
}</span>

/*
*

        SetShelleyMetadata function sets the Shelley Mary metadata for the transaction's
        auxiliary data.

        Params:


                metadata (Metadata.ShelleyMaryMetadata): The Shelley Mary metadat to set.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the Shelley Mary metadata set.
*/
func (b *Apollo) SetShelleyMetadata(
        metadata Metadata.ShelleyMaryMetadata,
) *Apollo <span class="cov0" title="0">{
        if b.auxiliaryData == nil </span><span class="cov0" title="0">{
                b.auxiliaryData = &amp;Metadata.AuxiliaryData{}
                b.auxiliaryData.SetShelleyMetadata(metadata)
        }</span> else<span class="cov0" title="0"> {
                b.auxiliaryData.SetShelleyMetadata(metadata)
        }</span>
        <span class="cov0" title="0">return b</span>
}

/*
*

        GetUsedUTxOs returns the list of used UTxOs in the transaction.

        Returns:
           []string: The list of used UTxOs as strings.
*/
func (b *Apollo) GetUsedUTxOs() []string <span class="cov0" title="0">{
        return b.usedUtxos
}</span>

/*
*

        SetEstimationExUnitsRequired enables the estimation of execution units
        for the transaction.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with execution units estimation enabled.
*/
func (b *Apollo) SetEstimationExUnitsRequired() *Apollo <span class="cov8" title="1">{
        b.isEstimateRequired = true
        return b
}</span>

/*
*

        AddReferenceInput adds a reference input to the transaction.

        Params:


                txHash (string): The hexadecimal representation of the reference transaction hash.
                index (int): The index of the reference input within its transaction.

        Returns:


        *Apollo: A pointer to the modified Apollo instance with the added reference input.
*/
func (b *Apollo) AddReferenceInput(txHash string, index int) *Apollo <span class="cov8" title="1">{
        decodedHash, _ := hex.DecodeString(txHash)
        exists := false
        for _, input := range b.referenceInputs </span><span class="cov0" title="0">{
                if bytes.Equal(input.TransactionId, decodedHash) &amp;&amp;
                        input.Index == index </span><span class="cov0" title="0">{
                        exists = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov8" title="1">input := TransactionInput.TransactionInput{
                TransactionId: decodedHash,
                Index:         index,
        }
        b.referenceInputs = append(b.referenceInputs, input)
        return b</span>
}

func (b *Apollo) AddReferenceInputV3(txHash string, index int) *Apollo <span class="cov0" title="0">{
        decodedHash, _ := hex.DecodeString(txHash)
        exists := false
        for _, input := range b.referenceInputsV3 </span><span class="cov0" title="0">{
                if bytes.Equal(input.TransactionId, decodedHash) &amp;&amp;
                        input.Index == index </span><span class="cov0" title="0">{
                        exists = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov0" title="0">input := TransactionInput.TransactionInput{
                TransactionId: decodedHash,
                Index:         index,
        }
        b.referenceInputsV3 = append(b.referenceInputsV3, input)
        return b</span>
}

/*
*

                DisableExecutionUnitsEstimation disables the estimation of execution units for the transaction.

                 Returns:


        *Apollo: A pointer to the modified Apollo instance with execution units estimation disabled.
*/
func (b *Apollo) DisableExecutionUnitsEstimation() *Apollo <span class="cov0" title="0">{
        b.isEstimateRequired = false
        return b
}</span>

/*
*

                SetCollateralAmount sets the collateral amount for the transaction.

                 Returns:


        *Apollo: A pointer to the modified Apollo instance with the collateral amount set.
*/
func (b *Apollo) SetCollateralAmount(amount int) *Apollo <span class="cov0" title="0">{
        b.collateralAmount = amount
        return b
}</span>

func (b *Apollo) AddWithdrawal(
        address Address.Address,
        amount int,
        redeemerData PlutusData.PlutusData,
) *Apollo <span class="cov0" title="0">{
        if b.withdrawals == nil </span><span class="cov0" title="0">{
                newWithdrawal := Withdrawal.New()
                b.withdrawals = &amp;newWithdrawal
        }</span>
        <span class="cov0" title="0">var stakeAddr [29]byte
        stakeAddr[0] = address.HeaderByte
        if len(address.StakingPart) != 28 </span><span class="cov0" title="0">{
                fmt.Printf(
                        "AddWithdrawal: address has invalid or missing staking part: %v\n",
                        address.StakingPart,
                )
        }</span>
        <span class="cov0" title="0">copy(stakeAddr[1:], address.StakingPart)
        err := b.withdrawals.Add(stakeAddr, amount)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("AddWithdrawal: %v\n", err)
                return b
        }</span>
        <span class="cov0" title="0">newRedeemer := Redeemer.Redeemer{
                Tag:     Redeemer.REWARD,
                Index:   b.withdrawals.Size() - 1, // We just added a withdrawal
                Data:    redeemerData,
                ExUnits: Redeemer.ExecutionUnits{}, // This will be filled in when we eval later
        }
        b.stakeRedeemers[strconv.Itoa(b.withdrawals.Size()-1)] = newRedeemer
        return b</span>
}

func (b *Apollo) AddCollateral(utxo UTxO.UTxO) *Apollo <span class="cov8" title="1">{
        b.collaterals = append(b.collaterals, utxo)
        return b
}</span>

func (b *Apollo) CompleteExact(fee int) (*Apollo, error) <span class="cov8" title="1">{
        //SET REDEEMER INDEXES
        b = b.setRedeemerIndexes()
        //SET COLLATERAL
        b, err := b.setCollateral()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //UPDATE EXUNITS
        <span class="cov8" title="1">b, err = b.updateExUnitsExact(fee)
        if err != nil </span><span class="cov0" title="0">{
                return b, err
        }</span>
        //ADDCHANGEANDFEE
        <span class="cov8" title="1">b.Fee = int64(fee)
        //FINALIZE TX
        body, err := b.buildTxBody()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">witnessSet := b.buildWitnessSet()
        b.tx = &amp;Transaction.Transaction{
                TransactionBody:       body,
                TransactionWitnessSet: witnessSet,
                AuxiliaryData:         b.auxiliaryData,
                Valid:                 true,
        }
        return b, nil</span>
}

func (b *Apollo) estimateExunitsExact(
        fee int,
) (map[string]Redeemer.ExecutionUnits, error) <span class="cov8" title="1">{
        cloned_b := b.Clone()
        cloned_b.isEstimateRequired = false
        updated_b, _ := cloned_b.CompleteExact(fee)
        //updated_b = updated_b.fakeWitness()
        tx_cbor, _ := cbor.Marshal(updated_b.tx)
        return b.Context.EvaluateTx(tx_cbor)
}</span>

func (b *Apollo) updateExUnitsExact(fee int) (*Apollo, error) <span class="cov8" title="1">{
        if b.isEstimateRequired </span><span class="cov8" title="1">{
                estimated_execution_units, err := b.estimateExunitsExact(fee)
                if err != nil </span><span class="cov0" title="0">{
                        return b, err
                }</span>
                <span class="cov8" title="1">for k, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        key := fmt.Sprintf(
                                "%s:%d",
                                Redeemer.RedeemerTagNames[redeemer.Tag],
                                redeemer.Index,
                        )
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov8" title="1">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.redeemersToUTxO[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        key := fmt.Sprintf(
                                "%s:%d",
                                Redeemer.RedeemerTagNames[redeemer.Tag],
                                redeemer.Index,
                        )
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.stakeRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for k, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        key := fmt.Sprintf(
                                "%s:%d",
                                Redeemer.RedeemerTagNames[redeemer.Tag],
                                redeemer.Index,
                        )
                        if _, ok := estimated_execution_units[key]; ok </span><span class="cov0" title="0">{
                                redeemer.ExUnits = estimated_execution_units[key]
                                b.mintRedeemers[k] = redeemer
                        }</span>
                }
                <span class="cov8" title="1">for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)

                }</span>
        } else<span class="cov8" title="1"> {
                for _, redeemer := range b.redeemersToUTxO </span><span class="cov8" title="1">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.stakeRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>
                <span class="cov8" title="1">for _, redeemer := range b.mintRedeemers </span><span class="cov0" title="0">{
                        b.redeemers = append(b.redeemers, redeemer)
                }</span>

        }
        <span class="cov8" title="1">return b, nil</span>
}

func (b *Apollo) GetPaymentsLength() int <span class="cov0" title="0">{
        return len(b.payments)
}</span>

func (b *Apollo) GetRedeemers() map[string]Redeemer.Redeemer <span class="cov0" title="0">{
        return b.redeemersToUTxO
}</span>

func (b *Apollo) UpdateRedeemers(
        newRedeemers map[string]Redeemer.Redeemer,
) *Apollo <span class="cov0" title="0">{
        b.redeemersToUTxO = newRedeemers
        return b
}</span>

func (b *Apollo) GetSortedInputs() []UTxO.UTxO <span class="cov0" title="0">{
        return SortUtxos(b.preselectedUtxos)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package apollo

import (
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Policy"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/Value"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/Salvionied/apollo/txBuilding/Utils"
)

type Unit struct {
        PolicyId string
        Name     string
        Quantity int
}

/*
*

        ToValue converts a Unit to a Value object.

        Returns:
                Value: The constructed Value object representing the asset.
*/
func (u *Unit) ToValue() Value.Value <span class="cov8" title="1">{
        val := Value.Value{}
        policyId := Policy.PolicyId{Value: u.PolicyId}
        ma := MultiAsset.MultiAsset[int64]{}
        aname := AssetName.NewAssetNameFromString(u.Name)
        ma[policyId] = map[AssetName.AssetName]int64{aname: int64(u.Quantity)}
        val.AddAssets(ma)
        return val
}</span>

/*
*

        NewUnit creates a new Unit with the provided information.

        Params:
                policyId (string): The policy ID of the asset.
                name (string): The name of the asset.
                quantity (int): The quantity of the asset.

        Returns:
                Unit: The newly created Unit instance.
*/
func NewUnit(policyId string, name string, quantity int) Unit <span class="cov8" title="1">{
        return Unit{
                PolicyId: policyId,
                Name:     name,
                Quantity: quantity,
        }
}</span>

type PaymentI interface {
        EnsureMinUTXO(cc Base.ChainContext)
        ToTxOut() *TransactionOutput.TransactionOutput
        ToValue() Value.Value
}

type Payment struct {
        Lovelace  int
        Receiver  Address.Address
        Units     []Unit
        Datum     *PlutusData.PlutusData
        DatumHash []byte
        IsInline  bool
}

/*
*

        PaymentFromTxOut creates a Payment object from a TransactionOutput.

        Params:


                txOut (*TransactionOutput.TransactionOutput): The TransactionOutput to create the Payment.

        Returns:
                *Payment: The created Payment object.
*/
func PaymentFromTxOut(txOut *TransactionOutput.TransactionOutput) *Payment <span class="cov0" title="0">{
        payment := &amp;Payment{
                Receiver: txOut.GetAddress(),
                Lovelace: int(txOut.GetAmount().GetCoin()),
                IsInline: false,
        }
        hasDatumHash := false
        hasInlineDatum := false
        if txOut.GetDatumHash() != nil </span><span class="cov0" title="0">{
                payment.DatumHash = txOut.GetDatumHash().Payload
                hasDatumHash = true
        }</span>
        <span class="cov0" title="0">if !txOut.GetDatum().Equal(PlutusData.PlutusData{}) </span><span class="cov0" title="0">{
                payment.Datum = txOut.GetDatum()
                hasInlineDatum = true
        }</span>
        <span class="cov0" title="0">if hasDatumHash &amp;&amp; hasInlineDatum </span><span class="cov0" title="0">{
                payment.IsInline = true
        }</span>

        <span class="cov0" title="0">for policyId, assets := range txOut.GetAmount().GetAssets() </span><span class="cov0" title="0">{
                for assetName, quantity := range assets </span><span class="cov0" title="0">{
                        payment.Units = append(payment.Units, Unit{
                                PolicyId: policyId.Value,
                                Name:     assetName.String(),
                                Quantity: int(quantity),
                        })
                }</span>
        }
        <span class="cov0" title="0">return payment</span>
}

/*
*

        NewPayment creates a new Payment object.

        Params:
                receiver (string): The receiver's address.
                lovelace (int): The amount in Lovelace.
                units ([]Unit): The assets units to be included.

        Returns:
                *Payment: The newly created Payment object.
*/
func NewPayment(receiver string, lovelace int, units []Unit) *Payment <span class="cov8" title="1">{
        decoded_address, _ := Address.DecodeAddress(receiver)
        return &amp;Payment{
                Lovelace: lovelace,
                Receiver: decoded_address,
                Units:    units,
        }
}</span>

/*
*

        NewPaymentFromValue creates a new Payment object from an Address
        and Value object.

        Params:
                receiver (Address.Address): The receiver's address.
                value (Value.Value): The value object containing payment details.

        Returns:
                *Payment: The newly created Payment object.
*/
func NewPaymentFromValue(receiver Address.Address, value Value.Value) *Payment <span class="cov0" title="0">{
        payment := &amp;Payment{
                Receiver: receiver,
                Lovelace: int(value.GetCoin()),
        }
        for policyId, assets := range value.GetAssets() </span><span class="cov0" title="0">{
                for assetName, quantity := range assets </span><span class="cov0" title="0">{
                        payment.Units = append(payment.Units, Unit{
                                PolicyId: policyId.Value,
                                Name:     assetName.String(),
                                Quantity: int(quantity),
                        })
                }</span>
        }
        <span class="cov0" title="0">return payment</span>
}

/*
*

        ToValue converts a Payment to a Value object.

        Returns:
                Value.Value: The constructed Value object representing the payment.
*/
func (p *Payment) ToValue() Value.Value <span class="cov8" title="1">{
        v := Value.Value{}
        for _, unit := range p.Units </span><span class="cov8" title="1">{
                v.AddAssets(unit.ToValue().GetAssets())
        }</span>
        <span class="cov8" title="1">v.AddLovelace(int64(p.Lovelace))
        return v</span>
}

/*
*

        EnsureMinUTXO ensures that the payment amount meets the minimun UTXO requirement.

        Params:
                cc (Base.ChainContext): The chain context.
*/
func (p *Payment) EnsureMinUTXO(cc Base.ChainContext) <span class="cov8" title="1">{
        if len(p.Units) == 0 &amp;&amp; p.Lovelace &gt;= 1_000_000 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">txOut := p.ToTxOut()
        coins, err := Utils.MinLovelacePostAlonzo(*txOut, cc)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if int64(p.Lovelace) &lt; coins </span><span class="cov0" title="0">{
                p.Lovelace = int(coins)
        }</span>
}

/*
*

        ToTxOut converts a Payment object to a TransactionOutput object.

        Returns:


        *TransactionOutput.TransactionOutput: The created TransactionOutput object.
*/
func (p *Payment) ToTxOut() *TransactionOutput.TransactionOutput <span class="cov8" title="1">{
        txOut := TransactionOutput.SimpleTransactionOutput(p.Receiver, p.ToValue())
        if p.IsInline </span><span class="cov0" title="0">{
                txO := TransactionOutput.TransactionOutput{}
                txO.IsPostAlonzo = true
                l := PlutusData.DatumOptionInline(p.Datum)
                txO.PostAlonzo.Datum = &amp;l
                txO.PostAlonzo.Address = p.Receiver
                txO.PostAlonzo.Amount = p.ToValue().ToAlonzoValue()

                if p.Datum != nil </span><span class="cov0" title="0">{
                        txOut.SetDatum(p.Datum)
                }</span>
                <span class="cov0" title="0">return &amp;txO</span>
        } else<span class="cov8" title="1"> {
                if p.DatumHash != nil </span><span class="cov8" title="1">{
                        txOut.PreAlonzo.DatumHash = serialization.DatumHash{Payload: p.DatumHash}
                        txOut.PreAlonzo.HasDatum = true

                }</span>
        }

        <span class="cov8" title="1">return &amp;txOut</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package apollo

import (
        "encoding/hex"
        "sort"

        "github.com/Salvionied/apollo/serialization/UTxO"
)

/*
*
SortUtxos sorts a slice of UTxO objects in descending order
based on their amounts.

Params:

        utxos ([]UTxO.UTxO): A slice of UTxO objects to be sorted.

Returns:

        []UTxO.UTxO: A new slice of UTxO objects sorted by descending amounts.
*/
func SortUtxos(utxos []UTxO.UTxO) []UTxO.UTxO <span class="cov8" title="1">{
        res := make([]UTxO.UTxO, len(utxos))
        copy(res, utxos)
        // Sort UTXOs first by large ADA-only UTXOs, then by assets
        sort.Slice(res, func(i, j int) bool </span><span class="cov8" title="1">{
                if !res[i].Output.GetValue().HasAssets &amp;&amp;
                        !res[j].Output.GetValue().HasAssets </span><span class="cov8" title="1">{
                        return res[i].Output.Lovelace() &gt; res[j].Output.Lovelace()
                }</span> else<span class="cov8" title="1"> if res[i].Output.GetValue().HasAssets &amp;&amp; res[j].Output.GetValue().HasAssets </span><span class="cov8" title="1">{
                        return res[i].Output.GetAmount().Greater(res[j].Output.GetAmount())
                }</span> else<span class="cov8" title="1"> {
                        return res[j].Output.GetAmount().HasAssets
                }</span>
        })
        <span class="cov8" title="1">return res</span>
}

/*
*

        SortInputs sorts a slice of UTxO objects based on their strings.

        Params:
                inputs ([]UTxO.UTxO): A slice of UTxO objects to be sorted.

        Returns:
                []UTxO.UTxO: A new slice of UTxO objects sorted based on input strings.
*/
func SortInputs(inputs []UTxO.UTxO) []UTxO.UTxO <span class="cov8" title="1">{
        sortedInputs := make([]UTxO.UTxO, 0)
        sortedInputs = append(sortedInputs, inputs...)
        sort.Slice(sortedInputs, func(i, j int) bool </span><span class="cov8" title="1">{
                iTxId := hex.EncodeToString(sortedInputs[i].Input.TransactionId)
                jTxId := hex.EncodeToString(sortedInputs[j].Input.TransactionId)
                if iTxId != jTxId </span><span class="cov8" title="1">{
                        return iTxId &lt; jTxId
                }</span> else<span class="cov8" title="1"> {
                        return sortedInputs[i].Input.Index &lt; sortedInputs[j].Input.Index
                }</span>
        })
        <span class="cov8" title="1">return sortedInputs</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package apollotypes

import (
        "encoding/hex"
        "errors"

        "github.com/Salvionied/apollo/serialization/PlutusData"
)

type AikenPlutusJSON struct {
        Preamble struct {
                Title         string `json:"title"`
                Description   string `json:"description"`
                Version       string `json:"version"`
                PlutusVersion string `json:"plutusVersion"`
                License       string `json:"license"`
        } `json:"preamble"`
        Validators []struct {
                Title string `json:"title"`
                Datum struct {
                        Title  string `json:"title"`
                        Schema struct {
                                Ref string `json:"$ref"`
                        } `json:"schema"`
                } `json:"datum"`
                Redeemer struct {
                        Title  string `json:"title"`
                        Schema struct {
                                Ref string `json:"$ref"`
                        } `json:"schema"`
                } `json:"redeemer"`
                CompiledCode string `json:"compiledCode"`
                Hash         string `json:"hash"`
        } `json:"validators"`
        Definitions struct {
        } `json:"definitions"`
}

/*
*

        GetScript retrives a Plutus V2 script by its name from an AikenPlutusJSON object.
        It searches through the Validators and returns the script if found.

        Params:
                apj (*AikenPlutusJSON): A pointer to an AikenPlutusJSON object.
                name (string): the name of the script to retrieve.

        Returns:


        (*PlutusData.PlutusV2Script, error): A pointer to a Plutus V2 script and an error (if any).
*/
func (apj *AikenPlutusJSON) GetScript(
        name string,
) (*PlutusData.PlutusV2Script, error) <span class="cov0" title="0">{
        for _, validator := range apj.Validators </span><span class="cov0" title="0">{
                if validator.Title == name </span><span class="cov0" title="0">{
                        decoded_string, err := hex.DecodeString(validator.CompiledCode)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">p2Script := PlutusData.PlutusV2Script(decoded_string)
                        return &amp;p2Script, nil</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.New("script not found")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package apollotypes

import (
        "bytes"
        "slices"

        "github.com/Salvionied/apollo/serialization"
        serAddress "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Certificate"
        "github.com/Salvionied/apollo/serialization/Key"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionWitnessSet"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/VerificationKeyWitness"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
)

type Wallet interface {
        GetAddress() *serAddress.Address
        SignTx(
                tx Transaction.Transaction,
                usedUtxos []UTxO.UTxO,
        ) TransactionWitnessSet.TransactionWitnessSet
        PkeyHash() serialization.PubKeyHash
        SkeyHash() serialization.PubKeyHash
        //SignMessage(address serAddress.Address, message []uint8) []uint8
}

type ExternalWallet struct {
        Address serAddress.Address
}

/*
*

        GetAddress returns the address associated with an external wallet.

        Returns:
                *serAddress.Address: A pointer to the address of the external wallet.
*/
func (ew *ExternalWallet) GetAddress() *serAddress.Address <span class="cov0" title="0">{
        return &amp;ew.Address
}</span>

/*
*

        SignTx signs a transaction using an external wallet.

        Params:
                tx (Transaction.Transaction): The transaction to be signed.

        Returns:


        TransactionWitnessSet.TransactionWitnessSet: The withness set associated with the signed transaction.
*/
func (ew *ExternalWallet) SignTx(
        tx Transaction.Transaction,
        usedUtxos []UTxO.UTxO,
) TransactionWitnessSet.TransactionWitnessSet <span class="cov0" title="0">{
        return tx.TransactionWitnessSet
}</span>

/*
*

        PkeyHash returns the public key hash associated with an external wallet.
        It computes and returns the public key hash based on the PaymentPart
        of the wallet's address.

        Returns:
                serialization.PubKeyHash: The public key hash of the external wallet.
*/
func (ew *ExternalWallet) PkeyHash() serialization.PubKeyHash <span class="cov0" title="0">{
        res := serialization.PubKeyHash(ew.Address.PaymentPart)
        return res
}</span>

func (ew *ExternalWallet) SkeyHash() serialization.PubKeyHash <span class="cov0" title="0">{
        res := serialization.PubKeyHash(ew.Address.StakingPart)
        return res
}</span>

type GenericWallet struct {
        SigningKey           Key.SigningKey
        VerificationKey      Key.VerificationKey
        Address              serAddress.Address
        StakeSigningKey      Key.SigningKey
        StakeVerificationKey Key.VerificationKey
}

/*
*

        PkeyHash calculates and returns the public key hash associated with a generic wallet.


        It computes the public key hash by calling the Hash() method on the wallet's VerificationKey.
        Then it returns as a serialization.PubKeyHas type.

        Returns:


        serialization.PubKeyHash: The public key hash of the generic wallet.
*/
func (gw *GenericWallet) PkeyHash() serialization.PubKeyHash <span class="cov0" title="0">{
        res, _ := gw.VerificationKey.Hash()
        return res
}</span>

func (gw *GenericWallet) SkeyHash() serialization.PubKeyHash <span class="cov0" title="0">{
        res, _ := gw.StakeVerificationKey.Hash()
        return res
}</span>

/*
*

        GetAddress returns the address associated with a generic wallet.

        Returns:
                *serAddress.Address: A pointer to the address of a generic wallet.
*/
func (gw *GenericWallet) GetAddress() *serAddress.Address <span class="cov0" title="0">{
        return &amp;gw.Address
}</span>

/*
*

        SignTx signs a transaction using a generic wallet and returns the updated TransactionWitnessSet.


        It takes a transaction of type Transaction.Transaction and signs it using the wallet's SigningKey.


        Then it appends the corresponding VerificationKeyWitness to the TransactionWitnessSet and returns
        the updated witness set.

        Parameters:
                   wallet (*GenericWallet): A pointer to a generic wallet.
                tx (Transaction.Transaction): The transaction to be signed.

        Returns:


        TransactionWitnessSet.TransactionWitnessSet: The updated TransactionWitnessSet after signing the transaction.
*/
func (wallet *GenericWallet) SignTx(
        tx Transaction.Transaction,
        usedUtxos []UTxO.UTxO,
) TransactionWitnessSet.TransactionWitnessSet <span class="cov0" title="0">{
        witness_set := tx.TransactionWitnessSet
        txHash, _ := tx.TransactionBody.Hash()
        if isKeyHashUsedFromUtxos(usedUtxos, wallet.PkeyHash()) ||
                isKeyHashUsedFromTx(tx, wallet.PkeyHash()) </span><span class="cov0" title="0">{
                signature, _ := wallet.SigningKey.Sign(txHash)

                witness_set.VkeyWitnesses = append(
                        witness_set.VkeyWitnesses,
                        VerificationKeyWitness.VerificationKeyWitness{
                                Vkey:      wallet.VerificationKey,
                                Signature: signature,
                        },
                )
        }</span>

        <span class="cov0" title="0">if isKeyHashUsedFromUtxos(usedUtxos, wallet.SkeyHash()) ||
                isKeyHashUsedFromTx(tx, wallet.SkeyHash()) </span><span class="cov0" title="0">{
                signature, _ := wallet.StakeSigningKey.Sign(txHash)

                witness_set.VkeyWitnesses = append(
                        witness_set.VkeyWitnesses,
                        VerificationKeyWitness.VerificationKeyWitness{
                                Vkey:      Key.VerificationKey(wallet.StakeVerificationKey),
                                Signature: signature,
                        },
                )
        }</span>

        <span class="cov0" title="0">return witness_set</span>
}

func isKeyHashUsedFromUtxos(
        usedUtxos []UTxO.UTxO,
        keyHash serialization.PubKeyHash,
) bool <span class="cov0" title="0">{
        for _, utxo := range usedUtxos </span><span class="cov0" title="0">{
                utxoKeyHash := serialization.PubKeyHash(
                        utxo.Output.GetAddress().PaymentPart,
                )
                if utxoKeyHash == keyHash </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func checkCredentialKeyHash(
        cred *Certificate.Credential,
        keyHash serialization.PubKeyHash,
) bool <span class="cov0" title="0">{
        if cred != nil &amp;&amp; cred.Kind() == 0 &amp;&amp; cred.KeyHash() == keyHash </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isKeyHashUsedFromTx(
        tx Transaction.Transaction,
        keyHash serialization.PubKeyHash,
) bool <span class="cov0" title="0">{
        keyHashBytes := keyHash[:]
        if tx.TransactionBody.Certificates != nil </span><span class="cov0" title="0">{
                for _, certificate := range *tx.TransactionBody.Certificates </span><span class="cov0" title="0">{
                        // Check all credential types
                        if checkCredentialKeyHash(certificate.StakeCredential(), keyHash) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">if checkCredentialKeyHash(certificate.DrepCredential(), keyHash) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">if checkCredentialKeyHash(
                                certificate.AuthCommitteeHotCredential(),
                                keyHash,
                        ) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">if checkCredentialKeyHash(
                                certificate.AuthCommitteeColdCredential(),
                                keyHash,
                        ) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        // Check certificate-specific fields using type switch
                        <span class="cov0" title="0">switch cert := certificate.(type) </span>{
                        case Certificate.PoolRegistration:<span class="cov0" title="0">
                                if cert.Params.Operator == keyHash </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                                <span class="cov0" title="0">for _, owner := range cert.Params.PoolOwners </span><span class="cov0" title="0">{
                                        if owner == keyHash </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        case Certificate.PoolRetirement:<span class="cov0" title="0">
                                if cert.PoolKeyHash == keyHash </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        case Certificate.StakeDelegation:<span class="cov0" title="0">
                                if cert.PoolKeyHash == keyHash </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        case Certificate.StakeVoteDelegCert:<span class="cov0" title="0">
                                if cert.PoolKeyHash == keyHash </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        case Certificate.StakeRegDelegCert:<span class="cov0" title="0">
                                if cert.PoolKeyHash == keyHash </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        case Certificate.StakeVoteRegDelegCert:<span class="cov0" title="0">
                                if cert.PoolKeyHash == keyHash </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">if tx.TransactionBody.Withdrawals != nil </span><span class="cov0" title="0">{
                for withdrawal := range *tx.TransactionBody.Withdrawals </span><span class="cov0" title="0">{
                        withdrawalBytes := withdrawal[1:]
                        if bytes.Equal(withdrawalBytes, keyHashBytes) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">if slices.Contains(tx.TransactionBody.RequiredSigners, keyHash) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, nativeScript := range tx.TransactionWitnessSet.NativeScripts </span><span class="cov0" title="0">{
                if bytes.Equal(nativeScript.KeyHash, keyHashBytes) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

type Backend Base.ChainContext

type Address serAddress.Address
</pre>
		
		<pre class="file" id="file5" style="display: none">package apollo

import (
        "errors"

        "github.com/Salvionied/apollo/constants"

        "github.com/Salvionied/apollo/txBuilding/Backend/BlockFrostChainContext"
        "github.com/Salvionied/apollo/txBuilding/Backend/FixedChainContext"
        "github.com/Salvionied/apollo/txBuilding/Backend/MaestroChainContext"
)

/*
*
NewEmptyBackend creates and returns an empty FixedChainContext instance,
which is iused for cases where no specific backend context is required.

Returns:

        FixedChainContext.FixedChainContext: An empty FixedChainContext instance.
*/
func NewEmptyBackend() FixedChainContext.FixedChainContext <span class="cov8" title="1">{
        return FixedChainContext.InitFixedChainContext()
}</span>

/*
*

        NewBlockfrostBackend creates a BlockFrostChainContext instance based
        on the specified network and project ID.

        Params:
                projectId (string): The project ID to authenticate with BlockFrost.
                network (Network): The network to configure the BlockFrost context for.

        Returns:


        BlockFrostChainContext.BlockFrostChainContext: A BlockFrostChainContext instance configured for the specified network.
*/
func NewBlockfrostBackend(
        projectId string,
        network constants.Network,

) (BlockFrostChainContext.BlockFrostChainContext, error) <span class="cov0" title="0">{
        switch network </span>{
        case constants.MAINNET:<span class="cov0" title="0">
                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_MAINNET,
                        int(constants.MAINNET),
                        projectId,
                )</span>
        case constants.TESTNET:<span class="cov0" title="0">

                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_TESTNET,
                        int(constants.TESTNET),
                        projectId,
                )</span>
        case constants.PREVIEW:<span class="cov0" title="0">

                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_PREVIEW,
                        int(constants.TESTNET),
                        projectId,
                )</span>
        case constants.PREPROD:<span class="cov0" title="0">

                return BlockFrostChainContext.NewBlockfrostChainContext(
                        constants.BLOCKFROST_BASE_URL_PREPROD,
                        int(constants.TESTNET),
                        projectId,
                )</span>
        default:<span class="cov0" title="0">
                return BlockFrostChainContext.BlockFrostChainContext{}, errors.New(
                        "invalid network",
                )</span>
        }
}

// NewMaestroBackend
// NewMaestroBackend creates a MaestroChainContext instance based on the specified network and project ID.
// Params:
// projectId (string): The project ID to authenticate with Maestro.
// network (Network): The network to configure the Maestro context for.
// Returns:
// MaestroChainContext.MaestroChainContext: A MaestroChainContext instance configured for the specified network.
func NewMaestroBackend(
        projectId string,
        network constants.Network,
) (MaestroChainContext.MaestroChainContext, error) <span class="cov0" title="0">{
        return MaestroChainContext.NewMaestroChainContext(
                int(network),
                projectId,
        )

}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2017 The btcsuite developers
// Use of this source code is governed by an ISC
// license that can be found in the LICENSE file.

package bech32

import (
        "errors"
        "fmt"
        "strings"
)

const charset = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"

var gen = []int{0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3}

// Decode decodes a bech32 encoded string, returning the human-readable
// part and the data part excluding the checksum.
func Decode(bech string) (string, []byte, error) <span class="cov0" title="0">{
        // The maximum allowed length for a bech32 string is 90. It must also
        // be at least 8 characters, since it needs a non-empty HRP, a
        // separator, and a 6 character checksum.
        // if len(bech) &lt; 8 || len(bech) &gt; 90 {
        //         return "", nil, fmt.Errorf("invalid bech32 string length %d",
        //                 len(bech))
        // }
        // Only        ASCII characters between 33 and 126 are allowed.
        for i := range len(bech) </span><span class="cov0" title="0">{
                if bech[i] &lt; 33 || bech[i] &gt; 126 </span><span class="cov0" title="0">{
                        return "", nil, fmt.Errorf("invalid character in "+
                                "string: '%c'", bech[i])
                }</span>
        }

        // The characters must be either all lowercase or all uppercase.
        <span class="cov0" title="0">lower := strings.ToLower(bech)
        upper := strings.ToUpper(bech)
        if bech != lower &amp;&amp; bech != upper </span><span class="cov0" title="0">{
                return "", nil, errors.New("string not all lowercase or all " +
                        "uppercase")
        }</span>

        // We'll work with the lowercase string from now on.
        <span class="cov0" title="0">bech = lower

        // The string is invalid if the last '1' is non-existent, it is the
        // first character of the string (no human-readable part) or one of the
        // last 6 characters of the string (since checksum cannot contain '1'),
        // or if the string is more than 90 characters in total.
        one := strings.LastIndexByte(bech, '1')
        if one &lt; 1 || one+7 &gt; len(bech) </span><span class="cov0" title="0">{
                return "", nil, errors.New("invalid index of 1")
        }</span>

        // The human-readable part is everything before the last '1'.
        <span class="cov0" title="0">hrp := bech[:one]
        data := bech[one+1:]

        // Each character corresponds to the byte with value of the index in
        // 'charset'.
        decoded, err := toBytes(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("failed converting data to bytes: "+
                        "%v", err)
        }</span>

        <span class="cov0" title="0">if !bech32VerifyChecksum(hrp, decoded) </span><span class="cov0" title="0">{
                moreInfo := ""
                checksum := bech[len(bech)-6:]
                expected, err := toChars(bech32Checksum(hrp,
                        decoded[:len(decoded)-6]))
                if err == nil </span><span class="cov0" title="0">{
                        moreInfo = fmt.Sprintf("Expected %v, got %v.",
                                expected, checksum)
                }</span>
                <span class="cov0" title="0">return "", nil, fmt.Errorf("checksum failed. %s", moreInfo)</span>
        }

        // We exclude the last 6 bytes, which is the checksum.
        <span class="cov0" title="0">return hrp, decoded[:len(decoded)-6], nil</span>
}

// Encode encodes a byte slice into a bech32 string with the
// human-readable part hrb. Note that the bytes must each encode 5 bits
// (base32).
func Encode(hrp string, data []byte) (string, error) <span class="cov0" title="0">{
        // Calculate the checksum of the data and append it at the end.
        checksum := bech32Checksum(hrp, data)
        combined := append(data, checksum...)

        // The resulting bech32 string is the concatenation of the hrp, the
        // separator 1, data and checksum. Everything after the separator is
        // represented using the specified charset.
        dataChars, err := toChars(combined)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unable to convert data bytes to chars: "+
                        "%v", err)
        }</span>
        <span class="cov0" title="0">return hrp + "1" + dataChars, nil</span>
}

// toBytes converts each character in the string 'chars' to the value of the
// index of the correspoding character in 'charset'.
func toBytes(chars string) ([]byte, error) <span class="cov0" title="0">{
        decoded := make([]byte, 0, len(chars))
        for i := range len(chars) </span><span class="cov0" title="0">{
                index := strings.IndexByte(charset, chars[i])
                if index &lt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid character not part of "+
                                "charset: %v", chars[i])
                }</span>
                <span class="cov0" title="0">decoded = append(decoded, byte(index))</span>
        }
        <span class="cov0" title="0">return decoded, nil</span>
}

// toChars converts the byte slice 'data' to a string where each byte in 'data'
// encodes the index of a character in 'charset'.
func toChars(data []byte) (string, error) <span class="cov0" title="0">{
        result := make([]byte, 0, len(data))
        for _, b := range data </span><span class="cov0" title="0">{
                if int(b) &gt;= len(charset) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid data byte: %v", b)
                }</span>
                <span class="cov0" title="0">result = append(result, charset[b])</span>
        }
        <span class="cov0" title="0">return string(result), nil</span>
}

// ConvertBits converts a byte slice where each byte is encoding fromBits bits,
// to a byte slice where each byte is encoding toBits bits.
func ConvertBits(
        data []byte,
        fromBits, toBits uint8,
        pad bool,
) ([]byte, error) <span class="cov0" title="0">{
        if fromBits &lt; 1 || fromBits &gt; 8 || toBits &lt; 1 || toBits &gt; 8 </span><span class="cov0" title="0">{
                return nil, errors.New("only bit groups between 1 and 8 allowed")
        }</span>

        // The final bytes, each byte encoding toBits bits.
        <span class="cov0" title="0">var regrouped []byte

        // Keep track of the next byte we create and how many bits we have
        //added to it out of the toBits goal.
        nextByte := byte(0)
        filledBits := uint8(0)

        for _, b := range data </span><span class="cov0" title="0">{

                // Discard unused bits.
                b = b &lt;&lt; (8 - fromBits)

                // How many bits remaining to extract from the input data.
                remFromBits := fromBits
                for remFromBits &gt; 0 </span><span class="cov0" title="0">{
                        // How many bits remaining to be added to the next byte.
                        remToBits := toBits - filledBits

                        // The number of bytes to next extract is the minimum of
                        // remFromBits and remToBits.
                        toExtract := min(remToBits, remFromBits)

                        // Add the next bits to nextByte, shifting the already
                        // added bits to the left.
                        nextByte = (nextByte &lt;&lt; toExtract) | (b &gt;&gt; (8 - toExtract))

                        // Discard the bits we just extracted and get ready for
                        // next iteration.
                        b = b &lt;&lt; toExtract
                        remFromBits -= toExtract
                        filledBits += toExtract

                        // If the nextByte is completely filled, we add it to
                        //our regrouped bytes and start on the next byte.
                        if filledBits == toBits </span><span class="cov0" title="0">{
                                regrouped = append(regrouped, nextByte)
                                filledBits = 0
                                nextByte = 0
                        }</span>
                }
        }

        // We pad any unfinished group if specified.
        <span class="cov0" title="0">if pad &amp;&amp; filledBits &gt; 0 </span><span class="cov0" title="0">{
                nextByte = nextByte &lt;&lt; (toBits - filledBits)
                regrouped = append(regrouped, nextByte)
                filledBits = 0
                nextByte = 0
        }</span>

        // Any incomplete group must be &lt;= 4 bits, and all zeroes.
        <span class="cov0" title="0">if filledBits &gt; 0 &amp;&amp; (filledBits &gt; 4 || nextByte != 0) </span><span class="cov0" title="0">{
                return nil, errors.New("invalid incomplete group")
        }</span>

        <span class="cov0" title="0">return regrouped, nil</span>
}

// For more details on the checksum calculation, please refer to BIP 173.
func bech32Checksum(hrp string, data []byte) []byte <span class="cov0" title="0">{
        // Convert the bytes to list of integers, as this is needed for the
        // checksum calculation.
        integers := make([]int, len(data))
        for i, b := range data </span><span class="cov0" title="0">{
                integers[i] = int(b)
        }</span>
        <span class="cov0" title="0">values := append(bech32HrpExpand(hrp), integers...)
        values = append(values, []int{0, 0, 0, 0, 0, 0}...)
        polymod := bech32Polymod(values) ^ 1
        res := []byte{}
        for i := range 6 </span><span class="cov0" title="0">{
                res = append(res, byte((polymod&gt;&gt;uint(5*(5-i)))&amp;31))
        }</span>
        <span class="cov0" title="0">return res</span>
}

// For more details on the polymod calculation, please refer to BIP 173.
func bech32Polymod(values []int) int <span class="cov0" title="0">{
        chk := 1
        for _, v := range values </span><span class="cov0" title="0">{
                b := chk &gt;&gt; 25
                chk = (chk&amp;0x1ffffff)&lt;&lt;5 ^ v
                for i := range 5 </span><span class="cov0" title="0">{
                        if (b&gt;&gt;uint(i))&amp;1 == 1 </span><span class="cov0" title="0">{
                                chk ^= gen[i]
                        }</span>
                }
        }
        <span class="cov0" title="0">return chk</span>
}

// For more details on HRP expansion, please refer to BIP 173.
func bech32HrpExpand(hrp string) []int <span class="cov0" title="0">{
        v := make([]int, 0, len(hrp)*2+1)
        for i := range len(hrp) </span><span class="cov0" title="0">{
                v = append(v, int(hrp[i]&gt;&gt;5))
        }</span>
        <span class="cov0" title="0">v = append(v, 0)
        for i := range len(hrp) </span><span class="cov0" title="0">{
                v = append(v, int(hrp[i]&amp;31))
        }</span>
        <span class="cov0" title="0">return v</span>
}

// For more details on the checksum verification, please refer to BIP 173.
func bech32VerifyChecksum(hrp string, data []byte) bool <span class="cov0" title="0">{
        integers := make([]int, len(data))
        for i, b := range data </span><span class="cov0" title="0">{
                integers[i] = int(b)
        }</span>
        <span class="cov0" title="0">concat := append(bech32HrpExpand(hrp), integers...)
        return bech32Polymod(concat) == 1</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package bip32

import "github.com/Salvionied/apollo/crypto/edwards25519"

func add28Mul8(kl, zl []byte) *[32]byte <span class="cov0" title="0">{
        var carry uint16 = 0
        var out [32]byte

        for i := range 28 </span><span class="cov0" title="0">{
                r := uint16(kl[i]) + uint16(zl[i])&lt;&lt;3 + carry
                out[i] = byte(r &amp; 0xff)
                carry = r &gt;&gt; 8
        }</span>

        <span class="cov0" title="0">for i := 28; i &lt; 32; i++ </span><span class="cov0" title="0">{
                r := uint16(kl[i]) + carry
                out[i] = byte(r &amp; 0xff)
                carry = r &gt;&gt; 8
        }</span>

        <span class="cov0" title="0">return &amp;out</span>
}

func add256Bits(kr, zr []byte) *[32]byte <span class="cov0" title="0">{
        var carry uint16 = 0
        var out [32]byte

        for i := range 32 </span><span class="cov0" title="0">{
                r := uint16(kr[i]) + uint16(zr[i]) + carry
                out[i] = byte(r)
                carry = r &gt;&gt; 8
        }</span>

        <span class="cov0" title="0">return &amp;out</span>
}

func pointOfTrunc28Mul8(zl []byte) *[32]byte <span class="cov0" title="0">{
        copy := add28Mul8(make([]byte, 32), zl)
        var Ap edwards25519.ExtendedGroupElement
        edwards25519.GeScalarMultBase(&amp;Ap, copy)

        var zl8b [32]byte
        Ap.ToBytes(&amp;zl8b)
        return &amp;zl8b
}</span>

func pointPlus(pk, zl8 *[32]byte) (*[32]byte, bool) <span class="cov0" title="0">{
        var a edwards25519.ExtendedGroupElement
        if !a.FromBytes(pk) </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">var b edwards25519.ExtendedGroupElement
        if !b.FromBytes(zl8) </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">var c edwards25519.CachedGroupElement
        b.ToCached(&amp;c)

        var r edwards25519.CompletedGroupElement
        edwards25519.GeAdd(&amp;r, &amp;a, &amp;c)

        var p2 edwards25519.ProjectiveGroupElement
        r.ToProjective(&amp;p2)

        var res [32]byte
        p2.ToBytes(&amp;res)

        return &amp;res, true</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package bip32

import (
        "crypto/hmac"
        "crypto/sha256"
        "crypto/sha512"
        "encoding/binary"
        "encoding/hex"
        "errors"
        "slices"

        "github.com/Salvionied/apollo/crypto/edwards25519"
)

const (
        XPrvSize  = 96
        XPubSize  = 64
        HardIndex = 0x80000000
)

// XPrv is exntend private key for ed25519
type XPrv struct {
        xprv []byte
}

// NewXPrv creates XPrv by plain xprv bytes
func NewXPrv(raw []byte) (XPrv, error) <span class="cov0" title="0">{
        if len(raw) != XPrvSize </span><span class="cov0" title="0">{
                return XPrv{}, errors.New(
                        "bip32-ed25519: NewXPrv: size should be 96 bytes",
                )
        }</span>

        <span class="cov0" title="0">if (raw[0] &amp; 0b0000_0111) != 0b0000_0000 </span><span class="cov0" title="0">{
                return XPrv{}, errors.New(
                        "bip32-ed25519: NewXPrv: the lowest 3 bits of the first byte of seed should be cleared",
                )
        }</span>

        <span class="cov0" title="0">if (raw[31] &amp; 0b1100_0000) != 0b0100_0000 </span><span class="cov0" title="0">{
                return XPrv{}, errors.New(
                        "bip32-ed25519: NewXPrv: the highest bit of the last byte of seed should be cleared",
                )
        }</span>

        <span class="cov0" title="0">return XPrv{xprv: slices.Clone(raw)}, nil</span>
}

// NewRootXPrv creates XPrv by seed(bip39),the seed size should be 32 bytes at least
func NewRootXPrv(seed []byte) XPrv <span class="cov0" title="0">{
        // Let k(seed) be 256-bit master secret
        // Then derive k = H512(k)and denote its left 32-byte by kL and right one by kR.
        secretKey := sha512.Sum512(seed[:32])

        // Modify kL:
        // the lowest 3 bits of the first byte are cleared
        secretKey[0] &amp;= 0b1111_1000
        // the highest bit of the last byte is cleared
        // and third highest bit also should clear according bip32-ed25519 spec
        secretKey[31] &amp;= 0b0101_1111
        // and the second highest bit of the last byte is set
        secretKey[31] |= 0b0100_0000

        xprv := make([]byte, XPrvSize)
        copy(xprv[:64], secretKey[:])

        // Derive c  H256(0x01||k), where H256 is SHA-256, and call it the root chain code
        chaincode := sha256.Sum256(append([]byte{1}, seed...))
        copy(xprv[64:], chaincode[:])
        return XPrv{xprv}
}</span>

// String implements Stringer interface and returns plain hex string
func (x XPrv) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(x.xprv)
}</span>

// Bytes returns intenal bytes
func (x XPrv) Bytes() []byte <span class="cov0" title="0">{
        return slices.Clone(x.xprv)
}</span>

// ChainCode returns chain code bytes
func (x XPrv) ChainCode() []byte <span class="cov0" title="0">{
        return slices.Clone(x.xprv[64:])
}</span>

// Derive derives new XPrv by an index
func (x XPrv) Derive(index uint32) XPrv <span class="cov0" title="0">{
        /*
                cP is the chain code.
                kP is (klP,krP) extended private key
                aP is the public key.
                ser32(i) serializes a uint32 i as a 4-byte little endian bytes

                If hardened child:
                        let Z = HMAC-SHA512(Key = cP, Data = 0x00 || kP || ser32(i)).
                        let I = HMAC-SHA512(Key = cP, Data = 0x01 || kP || ser32(i)).

                If normal child:
                        let Z = HMAC-SHA512(Key = cP, Data = 0x02 || aP || ser32(i)).
                        let I = HMAC-SHA512(Key = cP, Data = 0x03 || aP || ser32(i)).

                chain code
                The I is truncated to right 32 bytes.
        */

        ekey := slices.Clone(x.xprv[:64])
        chaincode := slices.Clone(x.xprv[64:96])

        kl := slices.Clone(x.xprv[:32])
        kr := slices.Clone(x.xprv[32:64])

        zmac := hmac.New(sha512.New, chaincode)
        imac := hmac.New(sha512.New, chaincode)

        seri := make([]byte, 4)
        binary.LittleEndian.PutUint32(seri, index)

        if index &gt;= HardIndex </span><span class="cov0" title="0">{
                _, _ = zmac.Write([]byte{0})
                _, _ = zmac.Write(ekey)
                _, _ = zmac.Write(seri)

                _, _ = imac.Write([]byte{1})
                _, _ = imac.Write(ekey)
                _, _ = imac.Write(seri)
        }</span> else<span class="cov0" title="0"> {
                pubkey := x.PublicKey()
                _, _ = zmac.Write([]byte{2})
                _, _ = zmac.Write(pubkey[:])
                _, _ = zmac.Write(seri)

                _, _ = imac.Write([]byte{3})
                _, _ = imac.Write(pubkey[:])
                _, _ = imac.Write(seri)
        }</span>

        <span class="cov0" title="0">zout, iout := zmac.Sum(nil), imac.Sum(nil)
        zl, zr := zout[0:32], zout[32:64]

        result := make([]byte, 96)
        copy(result[0:32], add28Mul8(kl, zl)[:])   // kl
        copy(result[32:64], add256Bits(kr, zr)[:]) // kr
        copy(result[64:96], iout[32:])             // chain code

        return XPrv{result}</span>
}

// DeriveHard derives new XPrv by a hardened index
func (x XPrv) DeriveHard(index uint32) XPrv <span class="cov0" title="0">{
        if index &gt; HardIndex </span><span class="cov0" title="0">{
                panic("bip32-ed25519: xprv.DeriveHard: overflow")</span>
        }
        <span class="cov0" title="0">return x.Derive(HardIndex + index)</span>
}

// PublicKey returns the public key
func (x XPrv) PublicKey() []byte <span class="cov0" title="0">{
        var A edwards25519.ExtendedGroupElement

        var hBytes [32]byte
        copy(hBytes[:], x.xprv[:32]) // make sure prvkey is 32 bytes

        edwards25519.GeScalarMultBase(&amp;A, &amp;hBytes)
        var publicKeyBytes [32]byte
        A.ToBytes(&amp;publicKeyBytes)

        return publicKeyBytes[:]
}</span>

// Sign signs message
func (x XPrv) Sign(message []byte) []byte <span class="cov0" title="0">{
        var hsout [64]byte

        hasher := sha512.New()
        _, _ = hasher.Write(x.xprv[32:64])
        _, _ = hasher.Write(message)
        hasher.Sum(hsout[:0])

        var nonce [32]byte
        edwards25519.ScReduce(&amp;nonce, &amp;hsout)

        var r [32]byte
        var R edwards25519.ExtendedGroupElement
        edwards25519.GeScalarMultBase(&amp;R, &amp;nonce)
        R.ToBytes(&amp;r)

        var sig [edwards25519.SignatureSize]byte
        copy(sig[:32], r[:])
        copy(sig[32:], x.PublicKey()[:])

        hasher.Reset()
        _, _ = hasher.Write(sig[:])
        _, _ = hasher.Write(message)
        hasher.Sum(hsout[:0])

        var a [32]byte
        edwards25519.ScReduce(&amp;a, &amp;hsout)

        var s, b [32]byte
        copy(b[:], x.xprv[:32])
        edwards25519.ScMulAdd(&amp;s, &amp;a, &amp;b, &amp;nonce)
        copy(sig[32:], s[:])

        return sig[:]
}</span>

// Verify verifies signature by message
func (x XPrv) Verify(msg, sig []byte) bool <span class="cov0" title="0">{
        return edwards25519.Verify(x.PublicKey(), msg, sig)
}</span>

// XPub returns extends public key for current XPrv
func (x XPrv) XPub() XPub <span class="cov0" title="0">{
        var xpub [64]byte
        copy(xpub[:32], x.PublicKey())
        copy(xpub[32:], x.xprv[64:96])
        return XPub{xpub: xpub[:]}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package bip32

import (
        "crypto/ed25519"
        "crypto/hmac"
        "crypto/sha512"
        "encoding/binary"
        "encoding/hex"
        "slices"
)

// XPub is exntend public key for ed25519
type XPub struct {
        xpub []byte
}

// NewXPub create XPub by plain xpub bytes
func NewXPub(raw []byte) XPub <span class="cov0" title="0">{
        if len(raw) != XPubSize </span><span class="cov0" title="0">{
                panic("bip32-ed25519: NewXPub: size should be 64 bytes")</span>
        }
        <span class="cov0" title="0">return XPub{xpub: slices.Clone(raw)}</span>
}

// String implements Stringer interface and returns plain hex string
func (x XPub) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(x.xpub)
}</span>

// Bytes returns intenal bytes
func (x XPub) Bytes() []byte <span class="cov0" title="0">{
        return slices.Clone(x.xpub)
}</span>

// PublicKey returns the current public key
func (x XPub) PublicKey() []byte <span class="cov0" title="0">{
        return slices.Clone(x.xpub[:32])
}</span>

// ChainCode returns chain code bytes
func (x XPub) ChainCode() []byte <span class="cov0" title="0">{
        return slices.Clone(x.xpub[32:])
}</span>

// Derive derives new XPub by a soft index
func (x XPub) Derive(index uint32) XPub <span class="cov0" title="0">{
        if index &gt; HardIndex </span><span class="cov0" title="0">{
                panic("bip32-ed25519: xpub.Derive: expected a soft derivation")</span>
        }

        <span class="cov0" title="0">var pubkey [32]byte
        copy(pubkey[:], x.xpub[:32])
        chaincode := slices.Clone(x.xpub[32:])

        zmac := hmac.New(sha512.New, chaincode)
        imac := hmac.New(sha512.New, chaincode)

        seri := make([]byte, 4)
        binary.LittleEndian.PutUint32(seri, index)

        _, _ = zmac.Write([]byte{2})
        _, _ = zmac.Write(pubkey[:])
        _, _ = zmac.Write(seri)

        _, _ = imac.Write([]byte{3})
        _, _ = imac.Write(pubkey[:])
        _, _ = imac.Write(seri)

        left, ok := pointPlus(&amp;pubkey, pointOfTrunc28Mul8(zmac.Sum(nil)[:32]))
        if !ok </span><span class="cov0" title="0">{
                panic(
                        "bip32-ed25519: can't convert bytes to edwards25519.ExtendedGroupElement",
                )</span>
        }

        <span class="cov0" title="0">var out [64]byte
        copy(out[:32], left[:32])
        copy(out[32:], imac.Sum(nil)[32:])
        return XPub{xpub: out[:]}</span>
}

// Verify verifies signature by message
func (x XPub) Verify(msg, sig []byte) bool <span class="cov0" title="0">{
        pk := x.xpub[:32]
        return ed25519.Verify(pk, msg, sig)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package ed25519 implements the Ed25519 signature algorithm. See
// https://ed25519.cr.yp.to/.
//
// These functions are also compatible with the Ed25519 function defined in
// RFC 8032. However, unlike RFC 8032's formulation, this package's private key
// representation includes a public key suffix to make multiple signing
// operations with the same key more efficient. This package refers to the RFC
// 8032 private key as the seed.
package ed25519

import (
        "bytes"
        "crypto"
        cryptorand "crypto/rand"
        "crypto/sha512"
        "errors"
        "io"
        "strconv"

        "filippo.io/edwards25519"
)

const (
        // PublicKeySize is the size, in bytes, of public keys as used in this package.
        PublicKeySize = 32
        // PrivateKeySize is the size, in bytes, of private keys as used in this package.
        PrivateKeySize = 64
        // SignatureSize is the size, in bytes, of signatures generated and verified by this package.
        SignatureSize = 64
        // SeedSize is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032.
        SeedSize = 32
)

// PublicKey is the type of Ed25519 public keys.
type PublicKey []byte

// Any methods implemented on PublicKey might need to also be implemented on
// PrivateKey, as the latter embeds the former and will expose its methods.

// Equal reports whether pub and x have the same value.
func (pub PublicKey) Equal(x crypto.PublicKey) bool <span class="cov0" title="0">{
        xx, ok := x.(PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return bytes.Equal(pub, xx)</span>
}

// PrivateKey is the type of Ed25519 private keys. It implements [crypto.Signer].
type PrivateKey []byte

// Public returns the [PublicKey] corresponding to priv.
func (priv PrivateKey) Public() crypto.PublicKey <span class="cov0" title="0">{
        publicKey := make([]byte, PublicKeySize)
        copy(publicKey, priv[32:])
        return PublicKey(publicKey)
}</span>

// Equal reports whether priv and x have the same value.
func (priv PrivateKey) Equal(x crypto.PrivateKey) bool <span class="cov0" title="0">{
        xx, ok := x.(PrivateKey)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return bytes.Equal(priv, xx)</span>
}

// Seed returns the private key seed corresponding to priv. It is provided for
// interoperability with RFC 8032. RFC 8032's private keys correspond to seeds
// in this package.
func (priv PrivateKey) Seed() []byte <span class="cov0" title="0">{
        return bytes.Clone(priv[:SeedSize])
}</span>

// Sign signs the given message with priv. rand is ignored.
//
// If opts.HashFunc() is [crypto.SHA512], the pre-hashed variant Ed25519ph is used
// and message is expected to be a SHA-512 hash, otherwise opts.HashFunc() must
// be [crypto.Hash](0) and the message must not be hashed, as Ed25519 performs two
// passes over messages to be signed.
//
// A value of type [Options] can be used as opts, or crypto.Hash(0) or
// crypto.SHA512 directly to select plain Ed25519 or Ed25519ph, respectively.
func (priv PrivateKey) Sign(
        rand io.Reader,
        message []byte,
        opts crypto.SignerOpts,
) (signature []byte, err error) <span class="cov0" title="0">{
        hash := opts.HashFunc()
        context := ""
        if opts, ok := opts.(*Options); ok </span><span class="cov0" title="0">{
                context = opts.Context
        }</span>
        <span class="cov0" title="0">if l := len(context); l &gt; 255 </span><span class="cov0" title="0">{
                return nil, errors.New(
                        "ed25519: bad Ed25519ph context length: " + strconv.Itoa(l),
                )
        }</span>
        <span class="cov0" title="0">switch </span>{
        case hash == crypto.SHA512:<span class="cov0" title="0"> // Ed25519ph
                if l := len(message); l != sha512.Size </span><span class="cov0" title="0">{
                        return nil, errors.New(
                                "ed25519: bad Ed25519ph message hash length: " + strconv.Itoa(
                                        l,
                                ),
                        )
                }</span>
                <span class="cov0" title="0">signature := make([]byte, SignatureSize)
                sign(signature, priv, message, domPrefixPh, context)
                return signature, nil</span>
        case hash == crypto.Hash(0) &amp;&amp; context != "":<span class="cov0" title="0"> // Ed25519ctx
                signature := make([]byte, SignatureSize)
                sign(signature, priv, message, domPrefixCtx, context)
                return signature, nil</span>
        case hash == crypto.Hash(0):<span class="cov0" title="0"> // Ed25519
                return Sign(priv, message), nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(
                        "ed25519: expected opts.HashFunc() zero (unhashed message, for standard Ed25519) or SHA-512 (for Ed25519ph)",
                )</span>
        }
}

// Options can be used with [PrivateKey.Sign] or [VerifyWithOptions]
// to select Ed25519 variants.
type Options struct {
        // Hash can be zero for regular Ed25519, or crypto.SHA512 for Ed25519ph.
        Hash crypto.Hash

        // Context, if not empty, selects Ed25519ctx or provides the context string
        // for Ed25519ph. It can be at most 255 bytes in length.
        Context string
}

// HashFunc returns o.Hash.
func (o *Options) HashFunc() crypto.Hash <span class="cov0" title="0">{ return o.Hash }</span>

// GenerateKey generates a public/private key pair using entropy from rand.
// If rand is nil, [crypto/rand.Reader] will be used.
func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error) <span class="cov0" title="0">{
        if rand == nil </span><span class="cov0" title="0">{
                rand = cryptorand.Reader
        }</span>

        <span class="cov0" title="0">seed := make([]byte, SeedSize)
        if _, err := io.ReadFull(rand, seed); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">privateKey := NewKeyFromSeed(seed)
        publicKey := make([]byte, PublicKeySize)
        copy(publicKey, privateKey[32:])

        return publicKey, privateKey, nil</span>
}

// NewKeyFromSeed calculates a private key from a seed. It will panic if
// len(seed) is not [SeedSize]. This function is provided for interoperability
// with RFC 8032. RFC 8032's private keys correspond to seeds in this
// package.
func NewKeyFromSeed(seed []byte) PrivateKey <span class="cov0" title="0">{
        // Outline the function body so that the returned key can be stack-allocated.
        privateKey := make([]byte, PrivateKeySize)
        newKeyFromSeed(privateKey, seed)
        return privateKey
}</span>

func newKeyFromSeed(privateKey, seed []byte) <span class="cov0" title="0">{
        if l := len(seed); l != SeedSize </span><span class="cov0" title="0">{
                panic("ed25519: bad seed length: " + strconv.Itoa(l))</span>
        }

        <span class="cov0" title="0">h := sha512.Sum512(seed)
        s, err := edwards25519.NewScalar().SetBytesWithClamping(h[:32])
        if err != nil </span><span class="cov0" title="0">{
                panic("ed25519: internal error: setting scalar failed")</span>
        }
        <span class="cov0" title="0">A := (&amp;edwards25519.Point{}).ScalarBaseMult(s)

        publicKey := A.Bytes()

        copy(privateKey, seed)
        copy(privateKey[32:], publicKey)</span>
}

// Sign signs the message with privateKey and returns a signature. It will
// panic if len(privateKey) is not [PrivateKeySize].
func Sign(privateKey PrivateKey, message []byte) []byte <span class="cov0" title="0">{
        // Outline the function body so that the returned signature can be
        // stack-allocated.
        signature := make([]byte, SignatureSize)
        sign(signature, privateKey, message, domPrefixPure, "")
        return signature
}</span>

// Domain separation prefixes used to disambiguate Ed25519/Ed25519ph/Ed25519ctx.
// See RFC 8032, Section 2 and Section 5.1.
const (
        // domPrefixPure is empty for pure Ed25519.
        domPrefixPure = ""
        // domPrefixPh is dom2(phflag=1) for Ed25519ph. It must be followed by the
        // uint8-length prefixed context.
        domPrefixPh = "SigEd25519 no Ed25519 collisions\x01"
        // domPrefixCtx is dom2(phflag=0) for Ed25519ctx. It must be followed by the
        // uint8-length prefixed context.
        domPrefixCtx = "SigEd25519 no Ed25519 collisions\x00"
)

func sign(signature, privateKey, message []byte, domPrefix, context string) <span class="cov0" title="0">{
        if l := len(privateKey); l != PrivateKeySize </span><span class="cov0" title="0">{
                panic("ed25519: bad private key length: " + strconv.Itoa(l))</span>
        }
        <span class="cov0" title="0">seed, publicKey := privateKey[:SeedSize], privateKey[SeedSize:]

        h := sha512.Sum512(seed)
        s, err := edwards25519.NewScalar().SetBytesWithClamping(h[:32])
        if err != nil </span><span class="cov0" title="0">{
                panic("ed25519: internal error: setting scalar failed")</span>
        }
        <span class="cov0" title="0">prefix := h[32:]

        mh := sha512.New()
        if domPrefix != domPrefixPure </span><span class="cov0" title="0">{
                mh.Write([]byte(domPrefix))
                mh.Write([]byte{byte(len(context))})
                mh.Write([]byte(context))
        }</span>
        <span class="cov0" title="0">mh.Write(prefix)
        mh.Write(message)
        messageDigest := make([]byte, 0, sha512.Size)
        messageDigest = mh.Sum(messageDigest)
        r, err := edwards25519.NewScalar().SetUniformBytes(messageDigest)
        if err != nil </span><span class="cov0" title="0">{
                panic("ed25519: internal error: setting scalar failed")</span>
        }

        <span class="cov0" title="0">R := (&amp;edwards25519.Point{}).ScalarBaseMult(r)

        kh := sha512.New()
        if domPrefix != domPrefixPure </span><span class="cov0" title="0">{
                kh.Write([]byte(domPrefix))
                kh.Write([]byte{byte(len(context))})
                kh.Write([]byte(context))
        }</span>
        <span class="cov0" title="0">kh.Write(R.Bytes())
        kh.Write(publicKey)
        kh.Write(message)
        hramDigest := make([]byte, 0, sha512.Size)
        hramDigest = kh.Sum(hramDigest)
        k, err := edwards25519.NewScalar().SetUniformBytes(hramDigest)
        if err != nil </span><span class="cov0" title="0">{
                panic("ed25519: internal error: setting scalar failed")</span>
        }

        <span class="cov0" title="0">S := edwards25519.NewScalar().MultiplyAdd(k, s, r)

        copy(signature[:32], R.Bytes())
        copy(signature[32:], S.Bytes())</span>
}

// Verify reports whether sig is a valid signature of message by publicKey. It
// will panic if len(publicKey) is not [PublicKeySize].
func Verify(publicKey PublicKey, message, sig []byte) bool <span class="cov0" title="0">{
        return verify(publicKey, message, sig, domPrefixPure, "")
}</span>

// VerifyWithOptions reports whether sig is a valid signature of message by
// publicKey. A valid signature is indicated by returning a nil error. It will
// panic if len(publicKey) is not [PublicKeySize].
//
// If opts.Hash is [crypto.SHA512], the pre-hashed variant Ed25519ph is used and
// message is expected to be a SHA-512 hash, otherwise opts.Hash must be
// [crypto.Hash](0) and the message must not be hashed, as Ed25519 performs two
// passes over messages to be signed.
func VerifyWithOptions(
        publicKey PublicKey,
        message, sig []byte,
        opts *Options,
) error <span class="cov0" title="0">{
        switch </span>{
        case opts.Hash == crypto.SHA512:<span class="cov0" title="0"> // Ed25519ph
                if l := len(message); l != sha512.Size </span><span class="cov0" title="0">{
                        return errors.New(
                                "ed25519: bad Ed25519ph message hash length: " + strconv.Itoa(
                                        l,
                                ),
                        )
                }</span>
                <span class="cov0" title="0">if l := len(opts.Context); l &gt; 255 </span><span class="cov0" title="0">{
                        return errors.New(
                                "ed25519: bad Ed25519ph context length: " + strconv.Itoa(l),
                        )
                }</span>
                <span class="cov0" title="0">if !verify(publicKey, message, sig, domPrefixPh, opts.Context) </span><span class="cov0" title="0">{
                        return errors.New("ed25519: invalid signature")
                }</span>
                <span class="cov0" title="0">return nil</span>
        case opts.Hash == crypto.Hash(0) &amp;&amp; opts.Context != "":<span class="cov0" title="0"> // Ed25519ctx
                if l := len(opts.Context); l &gt; 255 </span><span class="cov0" title="0">{
                        return errors.New(
                                "ed25519: bad Ed25519ctx context length: " + strconv.Itoa(l),
                        )
                }</span>
                <span class="cov0" title="0">if !verify(publicKey, message, sig, domPrefixCtx, opts.Context) </span><span class="cov0" title="0">{
                        return errors.New("ed25519: invalid signature")
                }</span>
                <span class="cov0" title="0">return nil</span>
        case opts.Hash == crypto.Hash(0):<span class="cov0" title="0"> // Ed25519
                if !verify(publicKey, message, sig, domPrefixPure, "") </span><span class="cov0" title="0">{
                        return errors.New("ed25519: invalid signature")
                }</span>
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return errors.New(
                        "ed25519: expected opts.Hash zero (unhashed message, for standard Ed25519) or SHA-512 (for Ed25519ph)",
                )</span>
        }
}

func verify(
        publicKey PublicKey,
        message, sig []byte,
        domPrefix, context string,
) bool <span class="cov0" title="0">{
        if l := len(publicKey); l != PublicKeySize </span><span class="cov0" title="0">{
                panic("ed25519: bad public key length: " + strconv.Itoa(l))</span>
        }

        <span class="cov0" title="0">if len(sig) != SignatureSize || sig[63]&amp;224 != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">A, err := (&amp;edwards25519.Point{}).SetBytes(publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">kh := sha512.New()
        if domPrefix != domPrefixPure </span><span class="cov0" title="0">{
                kh.Write([]byte(domPrefix))
                kh.Write([]byte{byte(len(context))})
                kh.Write([]byte(context))
        }</span>
        <span class="cov0" title="0">kh.Write(sig[:32])
        kh.Write(publicKey)
        kh.Write(message)
        hramDigest := make([]byte, 0, sha512.Size)
        hramDigest = kh.Sum(hramDigest)
        k, err := edwards25519.NewScalar().SetUniformBytes(hramDigest)
        if err != nil </span><span class="cov0" title="0">{
                panic("ed25519: internal error: setting scalar failed")</span>
        }

        <span class="cov0" title="0">S, err := edwards25519.NewScalar().SetCanonicalBytes(sig[32:])
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // [S]B = R + [k]A --&gt; [k](-A) + [S]B = R
        <span class="cov0" title="0">minusA := (&amp;edwards25519.Point{}).Negate(A)
        R := (&amp;edwards25519.Point{}).VarTimeDoubleScalarBaseMult(k, minusA, S)

        return bytes.Equal(sig[:32], R.Bytes())</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package edwards25519

import "encoding/binary"

// This code is a port of the public domain, ref10 implementation of ed25519
// from SUPERCOP.

// FieldElement represents an element of the field GF(2^255 - 19).  An element
// t, entries t[0]...t[9], represents the integer t[0]+2^26 t[1]+2^51 t[2]+2^77
// t[3]+2^102 t[4]+...+2^230 t[9].  Bounds on each t[i] vary depending on
// context.
type FieldElement [10]int32

var zero FieldElement

func FeZero(fe *FieldElement) <span class="cov0" title="0">{
        copy(fe[:], zero[:])
}</span>

func FeOne(fe *FieldElement) <span class="cov0" title="0">{
        FeZero(fe)
        fe[0] = 1
}</span>

func FeAdd(dst, a, b *FieldElement) <span class="cov0" title="0">{
        dst[0] = a[0] + b[0]
        dst[1] = a[1] + b[1]
        dst[2] = a[2] + b[2]
        dst[3] = a[3] + b[3]
        dst[4] = a[4] + b[4]
        dst[5] = a[5] + b[5]
        dst[6] = a[6] + b[6]
        dst[7] = a[7] + b[7]
        dst[8] = a[8] + b[8]
        dst[9] = a[9] + b[9]
}</span>

func FeSub(dst, a, b *FieldElement) <span class="cov0" title="0">{
        dst[0] = a[0] - b[0]
        dst[1] = a[1] - b[1]
        dst[2] = a[2] - b[2]
        dst[3] = a[3] - b[3]
        dst[4] = a[4] - b[4]
        dst[5] = a[5] - b[5]
        dst[6] = a[6] - b[6]
        dst[7] = a[7] - b[7]
        dst[8] = a[8] - b[8]
        dst[9] = a[9] - b[9]
}</span>

func FeCopy(dst, src *FieldElement) <span class="cov0" title="0">{
        copy(dst[:], src[:])
}</span>

// Replace (f,g) with (g,g) if b == 1;
// replace (f,g) with (f,g) if b == 0.
//
// Preconditions: b in {0,1}.
func FeCMove(f, g *FieldElement, b int32) <span class="cov0" title="0">{
        b = -b
        f[0] ^= b &amp; (f[0] ^ g[0])
        f[1] ^= b &amp; (f[1] ^ g[1])
        f[2] ^= b &amp; (f[2] ^ g[2])
        f[3] ^= b &amp; (f[3] ^ g[3])
        f[4] ^= b &amp; (f[4] ^ g[4])
        f[5] ^= b &amp; (f[5] ^ g[5])
        f[6] ^= b &amp; (f[6] ^ g[6])
        f[7] ^= b &amp; (f[7] ^ g[7])
        f[8] ^= b &amp; (f[8] ^ g[8])
        f[9] ^= b &amp; (f[9] ^ g[9])
}</span>

func load3(in []byte) int64 <span class="cov0" title="0">{
        var r int64
        r = int64(in[0])
        r |= int64(in[1]) &lt;&lt; 8
        r |= int64(in[2]) &lt;&lt; 16
        return r
}</span>

func load4(in []byte) int64 <span class="cov0" title="0">{
        var r int64
        r = int64(in[0])
        r |= int64(in[1]) &lt;&lt; 8
        r |= int64(in[2]) &lt;&lt; 16
        r |= int64(in[3]) &lt;&lt; 24
        return r
}</span>

func FeFromBytes(dst *FieldElement, src *[32]byte) <span class="cov0" title="0">{
        h0 := load4(src[:])
        h1 := load3(src[4:]) &lt;&lt; 6
        h2 := load3(src[7:]) &lt;&lt; 5
        h3 := load3(src[10:]) &lt;&lt; 3
        h4 := load3(src[13:]) &lt;&lt; 2
        h5 := load4(src[16:])
        h6 := load3(src[20:]) &lt;&lt; 7
        h7 := load3(src[23:]) &lt;&lt; 5
        h8 := load3(src[26:]) &lt;&lt; 4
        h9 := (load3(src[29:]) &amp; 8388607) &lt;&lt; 2

        FeCombine(dst, h0, h1, h2, h3, h4, h5, h6, h7, h8, h9)
}</span>

// FeToBytes marshals h to s.
// Preconditions:
//
//        |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
//
// Write p=2^255-19; q=floor(h/p).
// Basic claim: q = floor(2^(-255)(h + 19 2^(-25)h9 + 2^(-1))).
//
// Proof:
//
//        Have |h|&lt;=p so |q|&lt;=1 so |19^2 2^(-255) q|&lt;1/4.
//        Also have |h-2^230 h9|&lt;2^230 so |19 2^(-255)(h-2^230 h9)|&lt;1/4.
//
//        Write y=2^(-1)-19^2 2^(-255)q-19 2^(-255)(h-2^230 h9).
//        Then 0&lt;y&lt;1.
//
//        Write r=h-pq.
//        Have 0&lt;=r&lt;=p-1=2^255-20.
//        Thus 0&lt;=r+19(2^-255)r&lt;r+19(2^-255)2^255&lt;=2^255-1.
//
//        Write x=r+19(2^-255)r+y.
//        Then 0&lt;x&lt;2^255 so floor(2^(-255)x) = 0 so floor(q+2^(-255)x) = q.
//
//        Have q+2^(-255)x = 2^(-255)(h + 19 2^(-25) h9 + 2^(-1))
//        so floor(2^(-255)(h + 19 2^(-25) h9 + 2^(-1))) = q.
func FeToBytes(s *[32]byte, h *FieldElement) <span class="cov0" title="0">{
        var carry [10]int32

        q := (19*h[9] + (1 &lt;&lt; 24)) &gt;&gt; 25
        q = (h[0] + q) &gt;&gt; 26
        q = (h[1] + q) &gt;&gt; 25
        q = (h[2] + q) &gt;&gt; 26
        q = (h[3] + q) &gt;&gt; 25
        q = (h[4] + q) &gt;&gt; 26
        q = (h[5] + q) &gt;&gt; 25
        q = (h[6] + q) &gt;&gt; 26
        q = (h[7] + q) &gt;&gt; 25
        q = (h[8] + q) &gt;&gt; 26
        q = (h[9] + q) &gt;&gt; 25

        // Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20.
        h[0] += 19 * q
        // Goal: Output h-2^255 q, which is between 0 and 2^255-20.

        carry[0] = h[0] &gt;&gt; 26
        h[1] += carry[0]
        h[0] -= carry[0] &lt;&lt; 26
        carry[1] = h[1] &gt;&gt; 25
        h[2] += carry[1]
        h[1] -= carry[1] &lt;&lt; 25
        carry[2] = h[2] &gt;&gt; 26
        h[3] += carry[2]
        h[2] -= carry[2] &lt;&lt; 26
        carry[3] = h[3] &gt;&gt; 25
        h[4] += carry[3]
        h[3] -= carry[3] &lt;&lt; 25
        carry[4] = h[4] &gt;&gt; 26
        h[5] += carry[4]
        h[4] -= carry[4] &lt;&lt; 26
        carry[5] = h[5] &gt;&gt; 25
        h[6] += carry[5]
        h[5] -= carry[5] &lt;&lt; 25
        carry[6] = h[6] &gt;&gt; 26
        h[7] += carry[6]
        h[6] -= carry[6] &lt;&lt; 26
        carry[7] = h[7] &gt;&gt; 25
        h[8] += carry[7]
        h[7] -= carry[7] &lt;&lt; 25
        carry[8] = h[8] &gt;&gt; 26
        h[9] += carry[8]
        h[8] -= carry[8] &lt;&lt; 26
        carry[9] = h[9] &gt;&gt; 25
        h[9] -= carry[9] &lt;&lt; 25
        // h10 = carry9

        // Goal: Output h[0]+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
        // Have h[0]+...+2^230 h[9] between 0 and 2^255-1;
        // evidently 2^255 h10-2^255 q = 0.
        // Goal: Output h[0]+...+2^230 h[9].

        s[0] = byte(h[0] &gt;&gt; 0)
        s[1] = byte(h[0] &gt;&gt; 8)
        s[2] = byte(h[0] &gt;&gt; 16)
        s[3] = byte((h[0] &gt;&gt; 24) | (h[1] &lt;&lt; 2))
        s[4] = byte(h[1] &gt;&gt; 6)
        s[5] = byte(h[1] &gt;&gt; 14)
        s[6] = byte((h[1] &gt;&gt; 22) | (h[2] &lt;&lt; 3))
        s[7] = byte(h[2] &gt;&gt; 5)
        s[8] = byte(h[2] &gt;&gt; 13)
        s[9] = byte((h[2] &gt;&gt; 21) | (h[3] &lt;&lt; 5))
        s[10] = byte(h[3] &gt;&gt; 3)
        s[11] = byte(h[3] &gt;&gt; 11)
        s[12] = byte((h[3] &gt;&gt; 19) | (h[4] &lt;&lt; 6))
        s[13] = byte(h[4] &gt;&gt; 2)
        s[14] = byte(h[4] &gt;&gt; 10)
        s[15] = byte(h[4] &gt;&gt; 18)
        s[16] = byte(h[5] &gt;&gt; 0)
        s[17] = byte(h[5] &gt;&gt; 8)
        s[18] = byte(h[5] &gt;&gt; 16)
        s[19] = byte((h[5] &gt;&gt; 24) | (h[6] &lt;&lt; 1))
        s[20] = byte(h[6] &gt;&gt; 7)
        s[21] = byte(h[6] &gt;&gt; 15)
        s[22] = byte((h[6] &gt;&gt; 23) | (h[7] &lt;&lt; 3))
        s[23] = byte(h[7] &gt;&gt; 5)
        s[24] = byte(h[7] &gt;&gt; 13)
        s[25] = byte((h[7] &gt;&gt; 21) | (h[8] &lt;&lt; 4))
        s[26] = byte(h[8] &gt;&gt; 4)
        s[27] = byte(h[8] &gt;&gt; 12)
        s[28] = byte((h[8] &gt;&gt; 20) | (h[9] &lt;&lt; 6))
        s[29] = byte(h[9] &gt;&gt; 2)
        s[30] = byte(h[9] &gt;&gt; 10)
        s[31] = byte(h[9] &gt;&gt; 18)
}</span>

func FeIsNegative(f *FieldElement) byte <span class="cov0" title="0">{
        var s [32]byte
        FeToBytes(&amp;s, f)
        return s[0] &amp; 1
}</span>

func FeIsNonZero(f *FieldElement) int32 <span class="cov0" title="0">{
        var s [32]byte
        FeToBytes(&amp;s, f)
        var x uint8
        for _, b := range s </span><span class="cov0" title="0">{
                x |= b
        }</span>
        <span class="cov0" title="0">x |= x &gt;&gt; 4
        x |= x &gt;&gt; 2
        x |= x &gt;&gt; 1
        return int32(x &amp; 1)</span>
}

// FeNeg sets h = -f
//
// Preconditions:
//
//        |f| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
//
// Postconditions:
//
//        |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
func FeNeg(h, f *FieldElement) <span class="cov0" title="0">{
        h[0] = -f[0]
        h[1] = -f[1]
        h[2] = -f[2]
        h[3] = -f[3]
        h[4] = -f[4]
        h[5] = -f[5]
        h[6] = -f[6]
        h[7] = -f[7]
        h[8] = -f[8]
        h[9] = -f[9]
}</span>

func FeCombine(h *FieldElement, h0, h1, h2, h3, h4, h5, h6, h7, h8, h9 int64) <span class="cov0" title="0">{
        var c0, c1, c2, c3, c4, c5, c6, c7, c8, c9 int64

        /*
          |h0| &lt;= (1.1*1.1*2^52*(1+19+19+19+19)+1.1*1.1*2^50*(38+38+38+38+38))
            i.e. |h0| &lt;= 1.2*2^59; narrower ranges for h2, h4, h6, h8
          |h1| &lt;= (1.1*1.1*2^51*(1+1+19+19+19+19+19+19+19+19))
            i.e. |h1| &lt;= 1.5*2^58; narrower ranges for h3, h5, h7, h9
        */

        c0 = (h0 + (1 &lt;&lt; 25)) &gt;&gt; 26
        h1 += c0
        h0 -= c0 &lt;&lt; 26
        c4 = (h4 + (1 &lt;&lt; 25)) &gt;&gt; 26
        h5 += c4
        h4 -= c4 &lt;&lt; 26
        /* |h0| &lt;= 2^25 */
        /* |h4| &lt;= 2^25 */
        /* |h1| &lt;= 1.51*2^58 */
        /* |h5| &lt;= 1.51*2^58 */

        c1 = (h1 + (1 &lt;&lt; 24)) &gt;&gt; 25
        h2 += c1
        h1 -= c1 &lt;&lt; 25
        c5 = (h5 + (1 &lt;&lt; 24)) &gt;&gt; 25
        h6 += c5
        h5 -= c5 &lt;&lt; 25
        /* |h1| &lt;= 2^24; from now on fits into int32 */
        /* |h5| &lt;= 2^24; from now on fits into int32 */
        /* |h2| &lt;= 1.21*2^59 */
        /* |h6| &lt;= 1.21*2^59 */

        c2 = (h2 + (1 &lt;&lt; 25)) &gt;&gt; 26
        h3 += c2
        h2 -= c2 &lt;&lt; 26
        c6 = (h6 + (1 &lt;&lt; 25)) &gt;&gt; 26
        h7 += c6
        h6 -= c6 &lt;&lt; 26
        /* |h2| &lt;= 2^25; from now on fits into int32 unchanged */
        /* |h6| &lt;= 2^25; from now on fits into int32 unchanged */
        /* |h3| &lt;= 1.51*2^58 */
        /* |h7| &lt;= 1.51*2^58 */

        c3 = (h3 + (1 &lt;&lt; 24)) &gt;&gt; 25
        h4 += c3
        h3 -= c3 &lt;&lt; 25
        c7 = (h7 + (1 &lt;&lt; 24)) &gt;&gt; 25
        h8 += c7
        h7 -= c7 &lt;&lt; 25
        /* |h3| &lt;= 2^24; from now on fits into int32 unchanged */
        /* |h7| &lt;= 2^24; from now on fits into int32 unchanged */
        /* |h4| &lt;= 1.52*2^33 */
        /* |h8| &lt;= 1.52*2^33 */

        c4 = (h4 + (1 &lt;&lt; 25)) &gt;&gt; 26
        h5 += c4
        h4 -= c4 &lt;&lt; 26
        c8 = (h8 + (1 &lt;&lt; 25)) &gt;&gt; 26
        h9 += c8
        h8 -= c8 &lt;&lt; 26
        /* |h4| &lt;= 2^25; from now on fits into int32 unchanged */
        /* |h8| &lt;= 2^25; from now on fits into int32 unchanged */
        /* |h5| &lt;= 1.01*2^24 */
        /* |h9| &lt;= 1.51*2^58 */

        c9 = (h9 + (1 &lt;&lt; 24)) &gt;&gt; 25
        h0 += c9 * 19
        h9 -= c9 &lt;&lt; 25
        /* |h9| &lt;= 2^24; from now on fits into int32 unchanged */
        /* |h0| &lt;= 1.8*2^37 */

        c0 = (h0 + (1 &lt;&lt; 25)) &gt;&gt; 26
        h1 += c0
        h0 -= c0 &lt;&lt; 26
        /* |h0| &lt;= 2^25; from now on fits into int32 unchanged */
        /* |h1| &lt;= 1.01*2^24 */

        h[0] = int32(h0)
        h[1] = int32(h1)
        h[2] = int32(h2)
        h[3] = int32(h3)
        h[4] = int32(h4)
        h[5] = int32(h5)
        h[6] = int32(h6)
        h[7] = int32(h7)
        h[8] = int32(h8)
        h[9] = int32(h9)
}</span>

// FeMul calculates h = f * g
// Can overlap h with f or g.
//
// Preconditions:
//
//        |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
//        |g| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
//
// Postconditions:
//
//        |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
//
// Notes on implementation strategy:
//
// Using schoolbook multiplication.
// Karatsuba would save a little in some cost models.
//
// Most multiplications by 2 and 19 are 32-bit precomputations;
// cheaper than 64-bit postcomputations.
//
// There is one remaining multiplication by 19 in the carry chain;
// one *19 precomputation can be merged into this,
// but the resulting data flow is considerably less clean.
//
// There are 12 carries below.
// 10 of them are 2-way parallelizable and vectorizable.
// Can get away with 11 carries, but then data flow is much deeper.
//
// With tighter constraints on inputs, can squeeze carries into int32.
func FeMul(h, f, g *FieldElement) <span class="cov0" title="0">{
        f0 := int64(f[0])
        f1 := int64(f[1])
        f2 := int64(f[2])
        f3 := int64(f[3])
        f4 := int64(f[4])
        f5 := int64(f[5])
        f6 := int64(f[6])
        f7 := int64(f[7])
        f8 := int64(f[8])
        f9 := int64(f[9])

        f1_2 := int64(2 * f[1])
        f3_2 := int64(2 * f[3])
        f5_2 := int64(2 * f[5])
        f7_2 := int64(2 * f[7])
        f9_2 := int64(2 * f[9])

        g0 := int64(g[0])
        g1 := int64(g[1])
        g2 := int64(g[2])
        g3 := int64(g[3])
        g4 := int64(g[4])
        g5 := int64(g[5])
        g6 := int64(g[6])
        g7 := int64(g[7])
        g8 := int64(g[8])
        g9 := int64(g[9])

        g1_19 := int64(19 * g[1]) /* 1.4*2^29 */
        g2_19 := int64(19 * g[2]) /* 1.4*2^30; still ok */
        g3_19 := int64(19 * g[3])
        g4_19 := int64(19 * g[4])
        g5_19 := int64(19 * g[5])
        g6_19 := int64(19 * g[6])
        g7_19 := int64(19 * g[7])
        g8_19 := int64(19 * g[8])
        g9_19 := int64(19 * g[9])

        h0 := f0*g0 + f1_2*g9_19 + f2*g8_19 + f3_2*g7_19 + f4*g6_19 + f5_2*g5_19 + f6*g4_19 + f7_2*g3_19 + f8*g2_19 + f9_2*g1_19
        h1 := f0*g1 + f1*g0 + f2*g9_19 + f3*g8_19 + f4*g7_19 + f5*g6_19 + f6*g5_19 + f7*g4_19 + f8*g3_19 + f9*g2_19
        h2 := f0*g2 + f1_2*g1 + f2*g0 + f3_2*g9_19 + f4*g8_19 + f5_2*g7_19 + f6*g6_19 + f7_2*g5_19 + f8*g4_19 + f9_2*g3_19
        h3 := f0*g3 + f1*g2 + f2*g1 + f3*g0 + f4*g9_19 + f5*g8_19 + f6*g7_19 + f7*g6_19 + f8*g5_19 + f9*g4_19
        h4 := f0*g4 + f1_2*g3 + f2*g2 + f3_2*g1 + f4*g0 + f5_2*g9_19 + f6*g8_19 + f7_2*g7_19 + f8*g6_19 + f9_2*g5_19
        h5 := f0*g5 + f1*g4 + f2*g3 + f3*g2 + f4*g1 + f5*g0 + f6*g9_19 + f7*g8_19 + f8*g7_19 + f9*g6_19
        h6 := f0*g6 + f1_2*g5 + f2*g4 + f3_2*g3 + f4*g2 + f5_2*g1 + f6*g0 + f7_2*g9_19 + f8*g8_19 + f9_2*g7_19
        h7 := f0*g7 + f1*g6 + f2*g5 + f3*g4 + f4*g3 + f5*g2 + f6*g1 + f7*g0 + f8*g9_19 + f9*g8_19
        h8 := f0*g8 + f1_2*g7 + f2*g6 + f3_2*g5 + f4*g4 + f5_2*g3 + f6*g2 + f7_2*g1 + f8*g0 + f9_2*g9_19
        h9 := f0*g9 + f1*g8 + f2*g7 + f3*g6 + f4*g5 + f5*g4 + f6*g3 + f7*g2 + f8*g1 + f9*g0

        FeCombine(h, h0, h1, h2, h3, h4, h5, h6, h7, h8, h9)
}</span>

func feSquare(f *FieldElement) (h0, h1, h2, h3, h4, h5, h6, h7, h8, h9 int64) <span class="cov0" title="0">{
        f0 := int64(f[0])
        f1 := int64(f[1])
        f2 := int64(f[2])
        f3 := int64(f[3])
        f4 := int64(f[4])
        f5 := int64(f[5])
        f6 := int64(f[6])
        f7 := int64(f[7])
        f8 := int64(f[8])
        f9 := int64(f[9])
        f0_2 := int64(2 * f[0])
        f1_2 := int64(2 * f[1])
        f2_2 := int64(2 * f[2])
        f3_2 := int64(2 * f[3])
        f4_2 := int64(2 * f[4])
        f5_2 := int64(2 * f[5])
        f6_2 := int64(2 * f[6])
        f7_2 := int64(2 * f[7])
        f5_38 := 38 * f5 // 1.31*2^30
        f6_19 := 19 * f6 // 1.31*2^30
        f7_38 := 38 * f7 // 1.31*2^30
        f8_19 := 19 * f8 // 1.31*2^30
        f9_38 := 38 * f9 // 1.31*2^30

        h0 = f0*f0 + f1_2*f9_38 + f2_2*f8_19 + f3_2*f7_38 + f4_2*f6_19 + f5*f5_38
        h1 = f0_2*f1 + f2*f9_38 + f3_2*f8_19 + f4*f7_38 + f5_2*f6_19
        h2 = f0_2*f2 + f1_2*f1 + f3_2*f9_38 + f4_2*f8_19 + f5_2*f7_38 + f6*f6_19
        h3 = f0_2*f3 + f1_2*f2 + f4*f9_38 + f5_2*f8_19 + f6*f7_38
        h4 = f0_2*f4 + f1_2*f3_2 + f2*f2 + f5_2*f9_38 + f6_2*f8_19 + f7*f7_38
        h5 = f0_2*f5 + f1_2*f4 + f2_2*f3 + f6*f9_38 + f7_2*f8_19
        h6 = f0_2*f6 + f1_2*f5_2 + f2_2*f4 + f3_2*f3 + f7_2*f9_38 + f8*f8_19
        h7 = f0_2*f7 + f1_2*f6 + f2_2*f5 + f3_2*f4 + f8*f9_38
        h8 = f0_2*f8 + f1_2*f7_2 + f2_2*f6 + f3_2*f5_2 + f4*f4 + f9*f9_38
        h9 = f0_2*f9 + f1_2*f8 + f2_2*f7 + f3_2*f6 + f4_2*f5

        return
}</span>

// FeSquare calculates h = f*f. Can overlap h with f.
//
// Preconditions:
//
//        |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
//
// Postconditions:
//
//        |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
func FeSquare(h, f *FieldElement) <span class="cov0" title="0">{
        h0, h1, h2, h3, h4, h5, h6, h7, h8, h9 := feSquare(f)
        FeCombine(h, h0, h1, h2, h3, h4, h5, h6, h7, h8, h9)
}</span>

// FeSquare2 sets h = 2 * f * f
//
// Can overlap h with f.
//
// Preconditions:
//
//        |f| bounded by 1.65*2^26,1.65*2^25,1.65*2^26,1.65*2^25,etc.
//
// Postconditions:
//
//        |h| bounded by 1.01*2^25,1.01*2^24,1.01*2^25,1.01*2^24,etc.
//
// See fe_mul.c for discussion of implementation strategy.
func FeSquare2(h, f *FieldElement) <span class="cov0" title="0">{
        h0, h1, h2, h3, h4, h5, h6, h7, h8, h9 := feSquare(f)

        h0 += h0
        h1 += h1
        h2 += h2
        h3 += h3
        h4 += h4
        h5 += h5
        h6 += h6
        h7 += h7
        h8 += h8
        h9 += h9

        FeCombine(h, h0, h1, h2, h3, h4, h5, h6, h7, h8, h9)
}</span>

func FeInvert(out, z *FieldElement) <span class="cov0" title="0">{
        var t0, t1, t2, t3 FieldElement
        var i int

        FeSquare(&amp;t0, z)        // 2^1
        FeSquare(&amp;t1, &amp;t0)      // 2^2
        for i = 1; i &lt; 2; i++ </span><span class="cov0" title="0">{ // 2^3
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, z, &amp;t1)      // 2^3 + 2^0
        FeMul(&amp;t0, &amp;t0, &amp;t1)    // 2^3 + 2^1 + 2^0
        FeSquare(&amp;t2, &amp;t0)      // 2^4 + 2^2 + 2^1
        FeMul(&amp;t1, &amp;t1, &amp;t2)    // 2^4 + 2^3 + 2^2 + 2^1 + 2^0
        FeSquare(&amp;t2, &amp;t1)      // 5,4,3,2,1
        for i = 1; i &lt; 5; i++ </span><span class="cov0" title="0">{ // 9,8,7,6,5
                FeSquare(&amp;t2, &amp;t2)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, &amp;t2, &amp;t1)     // 9,8,7,6,5,4,3,2,1,0
        FeSquare(&amp;t2, &amp;t1)       // 10..1
        for i = 1; i &lt; 10; i++ </span><span class="cov0" title="0">{ // 19..10
                FeSquare(&amp;t2, &amp;t2)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t2, &amp;t2, &amp;t1)     // 19..0
        FeSquare(&amp;t3, &amp;t2)       // 20..1
        for i = 1; i &lt; 20; i++ </span><span class="cov0" title="0">{ // 39..20
                FeSquare(&amp;t3, &amp;t3)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t2, &amp;t3, &amp;t2)     // 39..0
        FeSquare(&amp;t2, &amp;t2)       // 40..1
        for i = 1; i &lt; 10; i++ </span><span class="cov0" title="0">{ // 49..10
                FeSquare(&amp;t2, &amp;t2)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, &amp;t2, &amp;t1)     // 49..0
        FeSquare(&amp;t2, &amp;t1)       // 50..1
        for i = 1; i &lt; 50; i++ </span><span class="cov0" title="0">{ // 99..50
                FeSquare(&amp;t2, &amp;t2)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t2, &amp;t2, &amp;t1)      // 99..0
        FeSquare(&amp;t3, &amp;t2)        // 100..1
        for i = 1; i &lt; 100; i++ </span><span class="cov0" title="0">{ // 199..100
                FeSquare(&amp;t3, &amp;t3)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t2, &amp;t3, &amp;t2)     // 199..0
        FeSquare(&amp;t2, &amp;t2)       // 200..1
        for i = 1; i &lt; 50; i++ </span><span class="cov0" title="0">{ // 249..50
                FeSquare(&amp;t2, &amp;t2)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, &amp;t2, &amp;t1)    // 249..0
        FeSquare(&amp;t1, &amp;t1)      // 250..1
        for i = 1; i &lt; 5; i++ </span><span class="cov0" title="0">{ // 254..5
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(out, &amp;t1, &amp;t0)</span> // 254..5,3,1,0
}

func fePow22523(out, z *FieldElement) <span class="cov0" title="0">{
        var t0, t1, t2 FieldElement
        var i int

        FeSquare(&amp;t0, z)
        for i = 1; i &lt; 1; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t0, &amp;t0)
        }</span>
        <span class="cov0" title="0">FeSquare(&amp;t1, &amp;t0)
        for i = 1; i &lt; 2; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, z, &amp;t1)
        FeMul(&amp;t0, &amp;t0, &amp;t1)
        FeSquare(&amp;t0, &amp;t0)
        for i = 1; i &lt; 1; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t0, &amp;t0)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t0, &amp;t1, &amp;t0)
        FeSquare(&amp;t1, &amp;t0)
        for i = 1; i &lt; 5; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t0, &amp;t1, &amp;t0)
        FeSquare(&amp;t1, &amp;t0)
        for i = 1; i &lt; 10; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, &amp;t1, &amp;t0)
        FeSquare(&amp;t2, &amp;t1)
        for i = 1; i &lt; 20; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t2, &amp;t2)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, &amp;t2, &amp;t1)
        FeSquare(&amp;t1, &amp;t1)
        for i = 1; i &lt; 10; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t0, &amp;t1, &amp;t0)
        FeSquare(&amp;t1, &amp;t0)
        for i = 1; i &lt; 50; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, &amp;t1, &amp;t0)
        FeSquare(&amp;t2, &amp;t1)
        for i = 1; i &lt; 100; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t2, &amp;t2)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t1, &amp;t2, &amp;t1)
        FeSquare(&amp;t1, &amp;t1)
        for i = 1; i &lt; 50; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t1, &amp;t1)
        }</span>
        <span class="cov0" title="0">FeMul(&amp;t0, &amp;t1, &amp;t0)
        FeSquare(&amp;t0, &amp;t0)
        for i = 1; i &lt; 2; i++ </span><span class="cov0" title="0">{
                FeSquare(&amp;t0, &amp;t0)
        }</span>
        <span class="cov0" title="0">FeMul(out, &amp;t0, z)</span>
}

// Group elements are members of the elliptic curve -x^2 + y^2 = 1 + d * x^2 *
// y^2 where d = -121665/121666.
//
// Several representations are used:
//   ProjectiveGroupElement: (X:Y:Z) satisfying x=X/Z, y=Y/Z
//   ExtendedGroupElement: (X:Y:Z:T) satisfying x=X/Z, y=Y/Z, XY=ZT
//   CompletedGroupElement: ((X:Z),(Y:T)) satisfying x=X/Z, y=Y/T
//   PreComputedGroupElement: (y+x,y-x,2dxy)

type ProjectiveGroupElement struct {
        X, Y, Z FieldElement
}

type ExtendedGroupElement struct {
        X, Y, Z, T FieldElement
}

type CompletedGroupElement struct {
        X, Y, Z, T FieldElement
}

type PreComputedGroupElement struct {
        yPlusX, yMinusX, xy2d FieldElement
}

type CachedGroupElement struct {
        yPlusX, yMinusX, Z, T2d FieldElement
}

func (p *ProjectiveGroupElement) Zero() <span class="cov0" title="0">{
        FeZero(&amp;p.X)
        FeOne(&amp;p.Y)
        FeOne(&amp;p.Z)
}</span>

func (p *ProjectiveGroupElement) Double(r *CompletedGroupElement) <span class="cov0" title="0">{
        var t0 FieldElement

        FeSquare(&amp;r.X, &amp;p.X)
        FeSquare(&amp;r.Z, &amp;p.Y)
        FeSquare2(&amp;r.T, &amp;p.Z)
        FeAdd(&amp;r.Y, &amp;p.X, &amp;p.Y)
        FeSquare(&amp;t0, &amp;r.Y)
        FeAdd(&amp;r.Y, &amp;r.Z, &amp;r.X)
        FeSub(&amp;r.Z, &amp;r.Z, &amp;r.X)
        FeSub(&amp;r.X, &amp;t0, &amp;r.Y)
        FeSub(&amp;r.T, &amp;r.T, &amp;r.Z)
}</span>

func (p *ProjectiveGroupElement) ToBytes(s *[32]byte) <span class="cov0" title="0">{
        var recip, x, y FieldElement

        FeInvert(&amp;recip, &amp;p.Z)
        FeMul(&amp;x, &amp;p.X, &amp;recip)
        FeMul(&amp;y, &amp;p.Y, &amp;recip)
        FeToBytes(s, &amp;y)
        s[31] ^= FeIsNegative(&amp;x) &lt;&lt; 7
}</span>

func (p *ExtendedGroupElement) Zero() <span class="cov0" title="0">{
        FeZero(&amp;p.X)
        FeOne(&amp;p.Y)
        FeOne(&amp;p.Z)
        FeZero(&amp;p.T)
}</span>

func (p *ExtendedGroupElement) Double(r *CompletedGroupElement) <span class="cov0" title="0">{
        var q ProjectiveGroupElement
        p.ToProjective(&amp;q)
        q.Double(r)
}</span>

func (p *ExtendedGroupElement) ToCached(r *CachedGroupElement) <span class="cov0" title="0">{
        FeAdd(&amp;r.yPlusX, &amp;p.Y, &amp;p.X)
        FeSub(&amp;r.yMinusX, &amp;p.Y, &amp;p.X)
        FeCopy(&amp;r.Z, &amp;p.Z)
        FeMul(&amp;r.T2d, &amp;p.T, &amp;d2)
}</span>

func (p *ExtendedGroupElement) ToProjective(r *ProjectiveGroupElement) <span class="cov0" title="0">{
        FeCopy(&amp;r.X, &amp;p.X)
        FeCopy(&amp;r.Y, &amp;p.Y)
        FeCopy(&amp;r.Z, &amp;p.Z)
}</span>

func (p *ExtendedGroupElement) ToBytes(s *[32]byte) <span class="cov0" title="0">{
        var recip, x, y FieldElement

        FeInvert(&amp;recip, &amp;p.Z)
        FeMul(&amp;x, &amp;p.X, &amp;recip)
        FeMul(&amp;y, &amp;p.Y, &amp;recip)
        FeToBytes(s, &amp;y)
        s[31] ^= FeIsNegative(&amp;x) &lt;&lt; 7
}</span>

func (p *ExtendedGroupElement) FromBytes(s *[32]byte) bool <span class="cov0" title="0">{
        var u, v, v3, vxx, check FieldElement

        FeFromBytes(&amp;p.Y, s)
        FeOne(&amp;p.Z)
        FeSquare(&amp;u, &amp;p.Y)
        FeMul(&amp;v, &amp;u, &amp;d)
        FeSub(&amp;u, &amp;u, &amp;p.Z) // y = y^2-1
        FeAdd(&amp;v, &amp;v, &amp;p.Z) // v = dy^2+1

        FeSquare(&amp;v3, &amp;v)
        FeMul(&amp;v3, &amp;v3, &amp;v) // v3 = v^3
        FeSquare(&amp;p.X, &amp;v3)
        FeMul(&amp;p.X, &amp;p.X, &amp;v)
        FeMul(&amp;p.X, &amp;p.X, &amp;u) // x = uv^7

        fePow22523(&amp;p.X, &amp;p.X) // x = (uv^7)^((q-5)/8)
        FeMul(&amp;p.X, &amp;p.X, &amp;v3)
        FeMul(&amp;p.X, &amp;p.X, &amp;u) // x = uv^3(uv^7)^((q-5)/8)

        var tmpX, tmp2 [32]byte

        FeSquare(&amp;vxx, &amp;p.X)
        FeMul(&amp;vxx, &amp;vxx, &amp;v)
        FeSub(&amp;check, &amp;vxx, &amp;u) // vx^2-u
        if FeIsNonZero(&amp;check) == 1 </span><span class="cov0" title="0">{
                FeAdd(&amp;check, &amp;vxx, &amp;u) // vx^2+u
                if FeIsNonZero(&amp;check) == 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">FeMul(&amp;p.X, &amp;p.X, &amp;SqrtM1)

                FeToBytes(&amp;tmpX, &amp;p.X)
                for i, v := range tmpX </span><span class="cov0" title="0">{
                        tmp2[31-i] = v
                }</span>
        }

        <span class="cov0" title="0">if FeIsNegative(&amp;p.X) != (s[31] &gt;&gt; 7) </span><span class="cov0" title="0">{
                FeNeg(&amp;p.X, &amp;p.X)
        }</span>

        <span class="cov0" title="0">FeMul(&amp;p.T, &amp;p.X, &amp;p.Y)
        return true</span>
}

func (p *CompletedGroupElement) ToProjective(r *ProjectiveGroupElement) <span class="cov0" title="0">{
        FeMul(&amp;r.X, &amp;p.X, &amp;p.T)
        FeMul(&amp;r.Y, &amp;p.Y, &amp;p.Z)
        FeMul(&amp;r.Z, &amp;p.Z, &amp;p.T)
}</span>

func (p *CompletedGroupElement) ToExtended(r *ExtendedGroupElement) <span class="cov0" title="0">{
        FeMul(&amp;r.X, &amp;p.X, &amp;p.T)
        FeMul(&amp;r.Y, &amp;p.Y, &amp;p.Z)
        FeMul(&amp;r.Z, &amp;p.Z, &amp;p.T)
        FeMul(&amp;r.T, &amp;p.X, &amp;p.Y)
}</span>

func (p *PreComputedGroupElement) Zero() <span class="cov0" title="0">{
        FeOne(&amp;p.yPlusX)
        FeOne(&amp;p.yMinusX)
        FeZero(&amp;p.xy2d)
}</span>

func GeAdd(
        r *CompletedGroupElement,
        p *ExtendedGroupElement,
        q *CachedGroupElement,
) <span class="cov0" title="0">{
        var t0 FieldElement

        FeAdd(&amp;r.X, &amp;p.Y, &amp;p.X)
        FeSub(&amp;r.Y, &amp;p.Y, &amp;p.X)
        FeMul(&amp;r.Z, &amp;r.X, &amp;q.yPlusX)
        FeMul(&amp;r.Y, &amp;r.Y, &amp;q.yMinusX)
        FeMul(&amp;r.T, &amp;q.T2d, &amp;p.T)
        FeMul(&amp;r.X, &amp;p.Z, &amp;q.Z)
        FeAdd(&amp;t0, &amp;r.X, &amp;r.X)
        FeSub(&amp;r.X, &amp;r.Z, &amp;r.Y)
        FeAdd(&amp;r.Y, &amp;r.Z, &amp;r.Y)
        FeAdd(&amp;r.Z, &amp;t0, &amp;r.T)
        FeSub(&amp;r.T, &amp;t0, &amp;r.T)
}</span>

func geSub(
        r *CompletedGroupElement,
        p *ExtendedGroupElement,
        q *CachedGroupElement,
) <span class="cov0" title="0">{
        var t0 FieldElement

        FeAdd(&amp;r.X, &amp;p.Y, &amp;p.X)
        FeSub(&amp;r.Y, &amp;p.Y, &amp;p.X)
        FeMul(&amp;r.Z, &amp;r.X, &amp;q.yMinusX)
        FeMul(&amp;r.Y, &amp;r.Y, &amp;q.yPlusX)
        FeMul(&amp;r.T, &amp;q.T2d, &amp;p.T)
        FeMul(&amp;r.X, &amp;p.Z, &amp;q.Z)
        FeAdd(&amp;t0, &amp;r.X, &amp;r.X)
        FeSub(&amp;r.X, &amp;r.Z, &amp;r.Y)
        FeAdd(&amp;r.Y, &amp;r.Z, &amp;r.Y)
        FeSub(&amp;r.Z, &amp;t0, &amp;r.T)
        FeAdd(&amp;r.T, &amp;t0, &amp;r.T)
}</span>

func geMixedAdd(
        r *CompletedGroupElement,
        p *ExtendedGroupElement,
        q *PreComputedGroupElement,
) <span class="cov0" title="0">{
        var t0 FieldElement

        FeAdd(&amp;r.X, &amp;p.Y, &amp;p.X)
        FeSub(&amp;r.Y, &amp;p.Y, &amp;p.X)
        FeMul(&amp;r.Z, &amp;r.X, &amp;q.yPlusX)
        FeMul(&amp;r.Y, &amp;r.Y, &amp;q.yMinusX)
        FeMul(&amp;r.T, &amp;q.xy2d, &amp;p.T)
        FeAdd(&amp;t0, &amp;p.Z, &amp;p.Z)
        FeSub(&amp;r.X, &amp;r.Z, &amp;r.Y)
        FeAdd(&amp;r.Y, &amp;r.Z, &amp;r.Y)
        FeAdd(&amp;r.Z, &amp;t0, &amp;r.T)
        FeSub(&amp;r.T, &amp;t0, &amp;r.T)
}</span>

func geMixedSub(
        r *CompletedGroupElement,
        p *ExtendedGroupElement,
        q *PreComputedGroupElement,
) <span class="cov0" title="0">{
        var t0 FieldElement

        FeAdd(&amp;r.X, &amp;p.Y, &amp;p.X)
        FeSub(&amp;r.Y, &amp;p.Y, &amp;p.X)
        FeMul(&amp;r.Z, &amp;r.X, &amp;q.yMinusX)
        FeMul(&amp;r.Y, &amp;r.Y, &amp;q.yPlusX)
        FeMul(&amp;r.T, &amp;q.xy2d, &amp;p.T)
        FeAdd(&amp;t0, &amp;p.Z, &amp;p.Z)
        FeSub(&amp;r.X, &amp;r.Z, &amp;r.Y)
        FeAdd(&amp;r.Y, &amp;r.Z, &amp;r.Y)
        FeSub(&amp;r.Z, &amp;t0, &amp;r.T)
        FeAdd(&amp;r.T, &amp;t0, &amp;r.T)
}</span>

func slide(r *[256]int8, a *[32]byte) <span class="cov0" title="0">{
        for i := range r </span><span class="cov0" title="0">{
                r[i] = int8(1 &amp; (a[i&gt;&gt;3] &gt;&gt; uint(i&amp;7)))
        }</span>

        <span class="cov0" title="0">for i := range r </span><span class="cov0" title="0">{
                if r[i] != 0 </span><span class="cov0" title="0">{
                        for b := 1; b &lt;= 6 &amp;&amp; i+b &lt; 256; b++ </span><span class="cov0" title="0">{
                                if r[i+b] != 0 </span><span class="cov0" title="0">{
                                        if r[i]+(r[i+b]&lt;&lt;uint(b)) &lt;= 15 </span><span class="cov0" title="0">{
                                                r[i] += r[i+b] &lt;&lt; uint(b)
                                                r[i+b] = 0
                                        }</span> else<span class="cov0" title="0"> if r[i]-(r[i+b]&lt;&lt;uint(b)) &gt;= -15 </span><span class="cov0" title="0">{
                                                r[i] -= r[i+b] &lt;&lt; uint(b)
                                                for k := i + b; k &lt; 256; k++ </span><span class="cov0" title="0">{
                                                        if r[k] == 0 </span><span class="cov0" title="0">{
                                                                r[k] = 1
                                                                break</span>
                                                        }
                                                        <span class="cov0" title="0">r[k] = 0</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                break</span>
                                        }
                                }
                        }
                }
        }
}

// GeDoubleScalarMultVartime sets r = a*A + b*B
// where a = a[0]+256*a[1]+...+256^31 a[31].
// and b = b[0]+256*b[1]+...+256^31 b[31].
// B is the Ed25519 base point (x,4/5) with x positive.
func GeDoubleScalarMultVartime(
        r *ProjectiveGroupElement,
        a *[32]byte,
        A *ExtendedGroupElement,
        b *[32]byte,
) <span class="cov0" title="0">{
        var aSlide, bSlide [256]int8
        var Ai [8]CachedGroupElement // A,3A,5A,7A,9A,11A,13A,15A
        var t CompletedGroupElement
        var u, A2 ExtendedGroupElement
        var i int

        slide(&amp;aSlide, a)
        slide(&amp;bSlide, b)

        A.ToCached(&amp;Ai[0])
        A.Double(&amp;t)
        t.ToExtended(&amp;A2)

        for i := range 7 </span><span class="cov0" title="0">{
                GeAdd(&amp;t, &amp;A2, &amp;Ai[i])
                t.ToExtended(&amp;u)
                u.ToCached(&amp;Ai[i+1])
        }</span>

        <span class="cov0" title="0">r.Zero()

        for i = 255; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if aSlide[i] != 0 || bSlide[i] != 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">for ; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                r.Double(&amp;t)

                if aSlide[i] &gt; 0 </span><span class="cov0" title="0">{
                        t.ToExtended(&amp;u)
                        GeAdd(&amp;t, &amp;u, &amp;Ai[aSlide[i]/2])
                }</span> else<span class="cov0" title="0"> if aSlide[i] &lt; 0 </span><span class="cov0" title="0">{
                        t.ToExtended(&amp;u)
                        geSub(&amp;t, &amp;u, &amp;Ai[(-aSlide[i])/2])
                }</span>

                <span class="cov0" title="0">if bSlide[i] &gt; 0 </span><span class="cov0" title="0">{
                        t.ToExtended(&amp;u)
                        geMixedAdd(&amp;t, &amp;u, &amp;bi[bSlide[i]/2])
                }</span> else<span class="cov0" title="0"> if bSlide[i] &lt; 0 </span><span class="cov0" title="0">{
                        t.ToExtended(&amp;u)
                        geMixedSub(&amp;t, &amp;u, &amp;bi[(-bSlide[i])/2])
                }</span>

                <span class="cov0" title="0">t.ToProjective(r)</span>
        }
}

// equal returns 1 if b == c and 0 otherwise, assuming that b and c are
// non-negative.
func equal(b, c int32) int32 <span class="cov0" title="0">{
        x := uint32(b ^ c)
        x--
        return int32(x &gt;&gt; 31)
}</span>

// negative returns 1 if b &lt; 0 and 0 otherwise.
func negative(b int32) int32 <span class="cov0" title="0">{
        return (b &gt;&gt; 31) &amp; 1
}</span>

func PreComputedGroupElementCMove(t, u *PreComputedGroupElement, b int32) <span class="cov0" title="0">{
        FeCMove(&amp;t.yPlusX, &amp;u.yPlusX, b)
        FeCMove(&amp;t.yMinusX, &amp;u.yMinusX, b)
        FeCMove(&amp;t.xy2d, &amp;u.xy2d, b)
}</span>

func selectPoint(t *PreComputedGroupElement, pos int32, b int32) <span class="cov0" title="0">{
        var minusT PreComputedGroupElement
        bNegative := negative(b)
        bAbs := b - (((-bNegative) &amp; b) &lt;&lt; 1)

        t.Zero()
        for i := range int32(8) </span><span class="cov0" title="0">{
                PreComputedGroupElementCMove(t, &amp;base[pos][i], equal(bAbs, i+1))
        }</span>
        <span class="cov0" title="0">FeCopy(&amp;minusT.yPlusX, &amp;t.yMinusX)
        FeCopy(&amp;minusT.yMinusX, &amp;t.yPlusX)
        FeNeg(&amp;minusT.xy2d, &amp;t.xy2d)
        PreComputedGroupElementCMove(t, &amp;minusT, bNegative)</span>
}

// GeScalarMultBase computes h = a*B, where
//
//        a = a[0]+256*a[1]+...+256^31 a[31]
//        B is the Ed25519 base point (x,4/5) with x positive.
//
// Preconditions:
//
//        a[31] &lt;= 127
func GeScalarMultBase(h *ExtendedGroupElement, a *[32]byte) <span class="cov0" title="0">{
        var e [64]int8

        for i, v := range a </span><span class="cov0" title="0">{
                e[2*i] = int8(v &amp; 15)
                e[2*i+1] = int8((v &gt;&gt; 4) &amp; 15)
        }</span>

        // each e[i] is between 0 and 15 and e[63] is between 0 and 7.

        <span class="cov0" title="0">carry := int8(0)
        for i := range 63 </span><span class="cov0" title="0">{
                e[i] += carry
                carry = (e[i] + 8) &gt;&gt; 4
                e[i] -= carry &lt;&lt; 4
        }</span>
        <span class="cov0" title="0">e[63] += carry
        // each e[i] is between -8 and 8.

        h.Zero()
        var t PreComputedGroupElement
        var r CompletedGroupElement
        for i := int32(1); i &lt; 64; i += 2 </span><span class="cov0" title="0">{
                selectPoint(&amp;t, i/2, int32(e[i]))
                geMixedAdd(&amp;r, h, &amp;t)
                r.ToExtended(h)
        }</span>

        <span class="cov0" title="0">var s ProjectiveGroupElement

        h.Double(&amp;r)
        r.ToProjective(&amp;s)
        s.Double(&amp;r)
        r.ToProjective(&amp;s)
        s.Double(&amp;r)
        r.ToProjective(&amp;s)
        s.Double(&amp;r)
        r.ToExtended(h)

        for i := int32(0); i &lt; 64; i += 2 </span><span class="cov0" title="0">{
                selectPoint(&amp;t, i/2, int32(e[i]))
                geMixedAdd(&amp;r, h, &amp;t)
                r.ToExtended(h)
        }</span>
}

// The scalars are GF(2^252 + 27742317777372353535851937790883648493).

// Input:
//
//        a[0]+256*a[1]+...+256^31*a[31] = a
//        b[0]+256*b[1]+...+256^31*b[31] = b
//        c[0]+256*c[1]+...+256^31*c[31] = c
//
// Output:
//
//        s[0]+256*s[1]+...+256^31*s[31] = (ab+c) mod l
//        where l = 2^252 + 27742317777372353535851937790883648493.
func ScMulAdd(s, a, b, c *[32]byte) <span class="cov0" title="0">{
        a0 := 2097151 &amp; load3(a[:])
        a1 := 2097151 &amp; (load4(a[2:]) &gt;&gt; 5)
        a2 := 2097151 &amp; (load3(a[5:]) &gt;&gt; 2)
        a3 := 2097151 &amp; (load4(a[7:]) &gt;&gt; 7)
        a4 := 2097151 &amp; (load4(a[10:]) &gt;&gt; 4)
        a5 := 2097151 &amp; (load3(a[13:]) &gt;&gt; 1)
        a6 := 2097151 &amp; (load4(a[15:]) &gt;&gt; 6)
        a7 := 2097151 &amp; (load3(a[18:]) &gt;&gt; 3)
        a8 := 2097151 &amp; load3(a[21:])
        a9 := 2097151 &amp; (load4(a[23:]) &gt;&gt; 5)
        a10 := 2097151 &amp; (load3(a[26:]) &gt;&gt; 2)
        a11 := (load4(a[28:]) &gt;&gt; 7)
        b0 := 2097151 &amp; load3(b[:])
        b1 := 2097151 &amp; (load4(b[2:]) &gt;&gt; 5)
        b2 := 2097151 &amp; (load3(b[5:]) &gt;&gt; 2)
        b3 := 2097151 &amp; (load4(b[7:]) &gt;&gt; 7)
        b4 := 2097151 &amp; (load4(b[10:]) &gt;&gt; 4)
        b5 := 2097151 &amp; (load3(b[13:]) &gt;&gt; 1)
        b6 := 2097151 &amp; (load4(b[15:]) &gt;&gt; 6)
        b7 := 2097151 &amp; (load3(b[18:]) &gt;&gt; 3)
        b8 := 2097151 &amp; load3(b[21:])
        b9 := 2097151 &amp; (load4(b[23:]) &gt;&gt; 5)
        b10 := 2097151 &amp; (load3(b[26:]) &gt;&gt; 2)
        b11 := (load4(b[28:]) &gt;&gt; 7)
        c0 := 2097151 &amp; load3(c[:])
        c1 := 2097151 &amp; (load4(c[2:]) &gt;&gt; 5)
        c2 := 2097151 &amp; (load3(c[5:]) &gt;&gt; 2)
        c3 := 2097151 &amp; (load4(c[7:]) &gt;&gt; 7)
        c4 := 2097151 &amp; (load4(c[10:]) &gt;&gt; 4)
        c5 := 2097151 &amp; (load3(c[13:]) &gt;&gt; 1)
        c6 := 2097151 &amp; (load4(c[15:]) &gt;&gt; 6)
        c7 := 2097151 &amp; (load3(c[18:]) &gt;&gt; 3)
        c8 := 2097151 &amp; load3(c[21:])
        c9 := 2097151 &amp; (load4(c[23:]) &gt;&gt; 5)
        c10 := 2097151 &amp; (load3(c[26:]) &gt;&gt; 2)
        c11 := (load4(c[28:]) &gt;&gt; 7)
        var carry [23]int64

        s0 := c0 + a0*b0
        s1 := c1 + a0*b1 + a1*b0
        s2 := c2 + a0*b2 + a1*b1 + a2*b0
        s3 := c3 + a0*b3 + a1*b2 + a2*b1 + a3*b0
        s4 := c4 + a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0
        s5 := c5 + a0*b5 + a1*b4 + a2*b3 + a3*b2 + a4*b1 + a5*b0
        s6 := c6 + a0*b6 + a1*b5 + a2*b4 + a3*b3 + a4*b2 + a5*b1 + a6*b0
        s7 := c7 + a0*b7 + a1*b6 + a2*b5 + a3*b4 + a4*b3 + a5*b2 + a6*b1 + a7*b0
        s8 := c8 + a0*b8 + a1*b7 + a2*b6 + a3*b5 + a4*b4 + a5*b3 + a6*b2 + a7*b1 + a8*b0
        s9 := c9 + a0*b9 + a1*b8 + a2*b7 + a3*b6 + a4*b5 + a5*b4 + a6*b3 + a7*b2 + a8*b1 + a9*b0
        s10 := c10 + a0*b10 + a1*b9 + a2*b8 + a3*b7 + a4*b6 + a5*b5 + a6*b4 + a7*b3 + a8*b2 + a9*b1 + a10*b0
        s11 := c11 + a0*b11 + a1*b10 + a2*b9 + a3*b8 + a4*b7 + a5*b6 + a6*b5 + a7*b4 + a8*b3 + a9*b2 + a10*b1 + a11*b0
        s12 := a1*b11 + a2*b10 + a3*b9 + a4*b8 + a5*b7 + a6*b6 + a7*b5 + a8*b4 + a9*b3 + a10*b2 + a11*b1
        s13 := a2*b11 + a3*b10 + a4*b9 + a5*b8 + a6*b7 + a7*b6 + a8*b5 + a9*b4 + a10*b3 + a11*b2
        s14 := a3*b11 + a4*b10 + a5*b9 + a6*b8 + a7*b7 + a8*b6 + a9*b5 + a10*b4 + a11*b3
        s15 := a4*b11 + a5*b10 + a6*b9 + a7*b8 + a8*b7 + a9*b6 + a10*b5 + a11*b4
        s16 := a5*b11 + a6*b10 + a7*b9 + a8*b8 + a9*b7 + a10*b6 + a11*b5
        s17 := a6*b11 + a7*b10 + a8*b9 + a9*b8 + a10*b7 + a11*b6
        s18 := a7*b11 + a8*b10 + a9*b9 + a10*b8 + a11*b7
        s19 := a8*b11 + a9*b10 + a10*b9 + a11*b8
        s20 := a9*b11 + a10*b10 + a11*b9
        s21 := a10*b11 + a11*b10
        s22 := a11 * b11
        s23 := int64(0)

        carry[0] = (s0 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s1 += carry[0]
        s0 -= carry[0] &lt;&lt; 21
        carry[2] = (s2 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s3 += carry[2]
        s2 -= carry[2] &lt;&lt; 21
        carry[4] = (s4 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s5 += carry[4]
        s4 -= carry[4] &lt;&lt; 21
        carry[6] = (s6 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[8] = (s8 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[10] = (s10 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21
        carry[12] = (s12 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s13 += carry[12]
        s12 -= carry[12] &lt;&lt; 21
        carry[14] = (s14 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s15 += carry[14]
        s14 -= carry[14] &lt;&lt; 21
        carry[16] = (s16 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s17 += carry[16]
        s16 -= carry[16] &lt;&lt; 21
        carry[18] = (s18 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s19 += carry[18]
        s18 -= carry[18] &lt;&lt; 21
        carry[20] = (s20 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s21 += carry[20]
        s20 -= carry[20] &lt;&lt; 21
        carry[22] = (s22 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s23 += carry[22]
        s22 -= carry[22] &lt;&lt; 21

        carry[1] = (s1 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s2 += carry[1]
        s1 -= carry[1] &lt;&lt; 21
        carry[3] = (s3 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s4 += carry[3]
        s3 -= carry[3] &lt;&lt; 21
        carry[5] = (s5 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s6 += carry[5]
        s5 -= carry[5] &lt;&lt; 21
        carry[7] = (s7 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[9] = (s9 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[11] = (s11 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s12 += carry[11]
        s11 -= carry[11] &lt;&lt; 21
        carry[13] = (s13 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s14 += carry[13]
        s13 -= carry[13] &lt;&lt; 21
        carry[15] = (s15 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s16 += carry[15]
        s15 -= carry[15] &lt;&lt; 21
        carry[17] = (s17 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s18 += carry[17]
        s17 -= carry[17] &lt;&lt; 21
        carry[19] = (s19 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s20 += carry[19]
        s19 -= carry[19] &lt;&lt; 21
        carry[21] = (s21 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s22 += carry[21]
        s21 -= carry[21] &lt;&lt; 21

        s11 += s23 * 666643
        s12 += s23 * 470296
        s13 += s23 * 654183
        s14 -= s23 * 997805
        s15 += s23 * 136657
        s16 -= s23 * 683901
        s23 = 0 //nolint:ineffassign

        s10 += s22 * 666643
        s11 += s22 * 470296
        s12 += s22 * 654183
        s13 -= s22 * 997805
        s14 += s22 * 136657
        s15 -= s22 * 683901
        s22 = 0 //nolint:ineffassign

        s9 += s21 * 666643
        s10 += s21 * 470296
        s11 += s21 * 654183
        s12 -= s21 * 997805
        s13 += s21 * 136657
        s14 -= s21 * 683901
        s21 = 0 //nolint:ineffassign

        s8 += s20 * 666643
        s9 += s20 * 470296
        s10 += s20 * 654183
        s11 -= s20 * 997805
        s12 += s20 * 136657
        s13 -= s20 * 683901
        s20 = 0 //nolint:ineffassign

        s7 += s19 * 666643
        s8 += s19 * 470296
        s9 += s19 * 654183
        s10 -= s19 * 997805
        s11 += s19 * 136657
        s12 -= s19 * 683901
        s19 = 0 //nolint:ineffassign

        s6 += s18 * 666643
        s7 += s18 * 470296
        s8 += s18 * 654183
        s9 -= s18 * 997805
        s10 += s18 * 136657
        s11 -= s18 * 683901
        s18 = 0 //nolint:ineffassign

        carry[6] = (s6 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[8] = (s8 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[10] = (s10 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21
        carry[12] = (s12 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s13 += carry[12]
        s12 -= carry[12] &lt;&lt; 21
        carry[14] = (s14 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s15 += carry[14]
        s14 -= carry[14] &lt;&lt; 21
        carry[16] = (s16 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s17 += carry[16]
        s16 -= carry[16] &lt;&lt; 21

        carry[7] = (s7 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[9] = (s9 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[11] = (s11 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s12 += carry[11]
        s11 -= carry[11] &lt;&lt; 21
        carry[13] = (s13 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s14 += carry[13]
        s13 -= carry[13] &lt;&lt; 21
        carry[15] = (s15 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s16 += carry[15]
        s15 -= carry[15] &lt;&lt; 21

        s5 += s17 * 666643
        s6 += s17 * 470296
        s7 += s17 * 654183
        s8 -= s17 * 997805
        s9 += s17 * 136657
        s10 -= s17 * 683901
        s17 = 0 //nolint:ineffassign

        s4 += s16 * 666643
        s5 += s16 * 470296
        s6 += s16 * 654183
        s7 -= s16 * 997805
        s8 += s16 * 136657
        s9 -= s16 * 683901
        s16 = 0 //nolint:ineffassign

        s3 += s15 * 666643
        s4 += s15 * 470296
        s5 += s15 * 654183
        s6 -= s15 * 997805
        s7 += s15 * 136657
        s8 -= s15 * 683901
        s15 = 0 //nolint:ineffassign

        s2 += s14 * 666643
        s3 += s14 * 470296
        s4 += s14 * 654183
        s5 -= s14 * 997805
        s6 += s14 * 136657
        s7 -= s14 * 683901
        s14 = 0 //nolint:ineffassign

        s1 += s13 * 666643
        s2 += s13 * 470296
        s3 += s13 * 654183
        s4 -= s13 * 997805
        s5 += s13 * 136657
        s6 -= s13 * 683901
        s13 = 0 //nolint:ineffassign

        s0 += s12 * 666643
        s1 += s12 * 470296
        s2 += s12 * 654183
        s3 -= s12 * 997805
        s4 += s12 * 136657
        s5 -= s12 * 683901
        s12 = 0

        carry[0] = (s0 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s1 += carry[0]
        s0 -= carry[0] &lt;&lt; 21
        carry[2] = (s2 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s3 += carry[2]
        s2 -= carry[2] &lt;&lt; 21
        carry[4] = (s4 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s5 += carry[4]
        s4 -= carry[4] &lt;&lt; 21
        carry[6] = (s6 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[8] = (s8 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[10] = (s10 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21

        carry[1] = (s1 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s2 += carry[1]
        s1 -= carry[1] &lt;&lt; 21
        carry[3] = (s3 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s4 += carry[3]
        s3 -= carry[3] &lt;&lt; 21
        carry[5] = (s5 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s6 += carry[5]
        s5 -= carry[5] &lt;&lt; 21
        carry[7] = (s7 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[9] = (s9 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[11] = (s11 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s12 += carry[11]
        s11 -= carry[11] &lt;&lt; 21

        s0 += s12 * 666643
        s1 += s12 * 470296
        s2 += s12 * 654183
        s3 -= s12 * 997805
        s4 += s12 * 136657
        s5 -= s12 * 683901
        s12 = 0

        carry[0] = s0 &gt;&gt; 21
        s1 += carry[0]
        s0 -= carry[0] &lt;&lt; 21
        carry[1] = s1 &gt;&gt; 21
        s2 += carry[1]
        s1 -= carry[1] &lt;&lt; 21
        carry[2] = s2 &gt;&gt; 21
        s3 += carry[2]
        s2 -= carry[2] &lt;&lt; 21
        carry[3] = s3 &gt;&gt; 21
        s4 += carry[3]
        s3 -= carry[3] &lt;&lt; 21
        carry[4] = s4 &gt;&gt; 21
        s5 += carry[4]
        s4 -= carry[4] &lt;&lt; 21
        carry[5] = s5 &gt;&gt; 21
        s6 += carry[5]
        s5 -= carry[5] &lt;&lt; 21
        carry[6] = s6 &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[7] = s7 &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[8] = s8 &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[9] = s9 &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[10] = s10 &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21
        carry[11] = s11 &gt;&gt; 21
        s12 += carry[11]
        s11 -= carry[11] &lt;&lt; 21

        s0 += s12 * 666643
        s1 += s12 * 470296
        s2 += s12 * 654183
        s3 -= s12 * 997805
        s4 += s12 * 136657
        s5 -= s12 * 683901
        s12 = 0 //nolint:ineffassign

        carry[0] = s0 &gt;&gt; 21
        s1 += carry[0]
        s0 -= carry[0] &lt;&lt; 21
        carry[1] = s1 &gt;&gt; 21
        s2 += carry[1]
        s1 -= carry[1] &lt;&lt; 21
        carry[2] = s2 &gt;&gt; 21
        s3 += carry[2]
        s2 -= carry[2] &lt;&lt; 21
        carry[3] = s3 &gt;&gt; 21
        s4 += carry[3]
        s3 -= carry[3] &lt;&lt; 21
        carry[4] = s4 &gt;&gt; 21
        s5 += carry[4]
        s4 -= carry[4] &lt;&lt; 21
        carry[5] = s5 &gt;&gt; 21
        s6 += carry[5]
        s5 -= carry[5] &lt;&lt; 21
        carry[6] = s6 &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[7] = s7 &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[8] = s8 &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[9] = s9 &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[10] = s10 &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21

        s[0] = byte(s0 &gt;&gt; 0)
        s[1] = byte(s0 &gt;&gt; 8)
        s[2] = byte((s0 &gt;&gt; 16) | (s1 &lt;&lt; 5))
        s[3] = byte(s1 &gt;&gt; 3)
        s[4] = byte(s1 &gt;&gt; 11)
        s[5] = byte((s1 &gt;&gt; 19) | (s2 &lt;&lt; 2))
        s[6] = byte(s2 &gt;&gt; 6)
        s[7] = byte((s2 &gt;&gt; 14) | (s3 &lt;&lt; 7))
        s[8] = byte(s3 &gt;&gt; 1)
        s[9] = byte(s3 &gt;&gt; 9)
        s[10] = byte((s3 &gt;&gt; 17) | (s4 &lt;&lt; 4))
        s[11] = byte(s4 &gt;&gt; 4)
        s[12] = byte(s4 &gt;&gt; 12)
        s[13] = byte((s4 &gt;&gt; 20) | (s5 &lt;&lt; 1))
        s[14] = byte(s5 &gt;&gt; 7)
        s[15] = byte((s5 &gt;&gt; 15) | (s6 &lt;&lt; 6))
        s[16] = byte(s6 &gt;&gt; 2)
        s[17] = byte(s6 &gt;&gt; 10)
        s[18] = byte((s6 &gt;&gt; 18) | (s7 &lt;&lt; 3))
        s[19] = byte(s7 &gt;&gt; 5)
        s[20] = byte(s7 &gt;&gt; 13)
        s[21] = byte(s8 &gt;&gt; 0)
        s[22] = byte(s8 &gt;&gt; 8)
        s[23] = byte((s8 &gt;&gt; 16) | (s9 &lt;&lt; 5))
        s[24] = byte(s9 &gt;&gt; 3)
        s[25] = byte(s9 &gt;&gt; 11)
        s[26] = byte((s9 &gt;&gt; 19) | (s10 &lt;&lt; 2))
        s[27] = byte(s10 &gt;&gt; 6)
        s[28] = byte((s10 &gt;&gt; 14) | (s11 &lt;&lt; 7))
        s[29] = byte(s11 &gt;&gt; 1)
        s[30] = byte(s11 &gt;&gt; 9)
        s[31] = byte(s11 &gt;&gt; 17)
}</span>

// Input:
//
//        s[0]+256*s[1]+...+256^63*s[63] = s
//
// Output:
//
//        s[0]+256*s[1]+...+256^31*s[31] = s mod l
//        where l = 2^252 + 27742317777372353535851937790883648493.
func ScReduce(out *[32]byte, s *[64]byte) <span class="cov0" title="0">{
        s0 := 2097151 &amp; load3(s[:])
        s1 := 2097151 &amp; (load4(s[2:]) &gt;&gt; 5)
        s2 := 2097151 &amp; (load3(s[5:]) &gt;&gt; 2)
        s3 := 2097151 &amp; (load4(s[7:]) &gt;&gt; 7)
        s4 := 2097151 &amp; (load4(s[10:]) &gt;&gt; 4)
        s5 := 2097151 &amp; (load3(s[13:]) &gt;&gt; 1)
        s6 := 2097151 &amp; (load4(s[15:]) &gt;&gt; 6)
        s7 := 2097151 &amp; (load3(s[18:]) &gt;&gt; 3)
        s8 := 2097151 &amp; load3(s[21:])
        s9 := 2097151 &amp; (load4(s[23:]) &gt;&gt; 5)
        s10 := 2097151 &amp; (load3(s[26:]) &gt;&gt; 2)
        s11 := 2097151 &amp; (load4(s[28:]) &gt;&gt; 7)
        s12 := 2097151 &amp; (load4(s[31:]) &gt;&gt; 4)
        s13 := 2097151 &amp; (load3(s[34:]) &gt;&gt; 1)
        s14 := 2097151 &amp; (load4(s[36:]) &gt;&gt; 6)
        s15 := 2097151 &amp; (load3(s[39:]) &gt;&gt; 3)
        s16 := 2097151 &amp; load3(s[42:])
        s17 := 2097151 &amp; (load4(s[44:]) &gt;&gt; 5)
        s18 := 2097151 &amp; (load3(s[47:]) &gt;&gt; 2)
        s19 := 2097151 &amp; (load4(s[49:]) &gt;&gt; 7)
        s20 := 2097151 &amp; (load4(s[52:]) &gt;&gt; 4)
        s21 := 2097151 &amp; (load3(s[55:]) &gt;&gt; 1)
        s22 := 2097151 &amp; (load4(s[57:]) &gt;&gt; 6)
        s23 := (load4(s[60:]) &gt;&gt; 3)

        s11 += s23 * 666643
        s12 += s23 * 470296
        s13 += s23 * 654183
        s14 -= s23 * 997805
        s15 += s23 * 136657
        s16 -= s23 * 683901
        s23 = 0 //nolint:ineffassign

        s10 += s22 * 666643
        s11 += s22 * 470296
        s12 += s22 * 654183
        s13 -= s22 * 997805
        s14 += s22 * 136657
        s15 -= s22 * 683901
        s22 = 0 //nolint:ineffassign

        s9 += s21 * 666643
        s10 += s21 * 470296
        s11 += s21 * 654183
        s12 -= s21 * 997805
        s13 += s21 * 136657
        s14 -= s21 * 683901
        s21 = 0 //nolint:ineffassign

        s8 += s20 * 666643
        s9 += s20 * 470296
        s10 += s20 * 654183
        s11 -= s20 * 997805
        s12 += s20 * 136657
        s13 -= s20 * 683901
        s20 = 0 //nolint:ineffassign

        s7 += s19 * 666643
        s8 += s19 * 470296
        s9 += s19 * 654183
        s10 -= s19 * 997805
        s11 += s19 * 136657
        s12 -= s19 * 683901
        s19 = 0 //nolint:ineffassign

        s6 += s18 * 666643
        s7 += s18 * 470296
        s8 += s18 * 654183
        s9 -= s18 * 997805
        s10 += s18 * 136657
        s11 -= s18 * 683901
        s18 = 0 //nolint:ineffassign

        var carry [17]int64

        carry[6] = (s6 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[8] = (s8 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[10] = (s10 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21
        carry[12] = (s12 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s13 += carry[12]
        s12 -= carry[12] &lt;&lt; 21
        carry[14] = (s14 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s15 += carry[14]
        s14 -= carry[14] &lt;&lt; 21
        carry[16] = (s16 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s17 += carry[16]
        s16 -= carry[16] &lt;&lt; 21

        carry[7] = (s7 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[9] = (s9 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[11] = (s11 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s12 += carry[11]
        s11 -= carry[11] &lt;&lt; 21
        carry[13] = (s13 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s14 += carry[13]
        s13 -= carry[13] &lt;&lt; 21
        carry[15] = (s15 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s16 += carry[15]
        s15 -= carry[15] &lt;&lt; 21

        s5 += s17 * 666643
        s6 += s17 * 470296
        s7 += s17 * 654183
        s8 -= s17 * 997805
        s9 += s17 * 136657
        s10 -= s17 * 683901
        s17 = 0 //nolint:ineffassign

        s4 += s16 * 666643
        s5 += s16 * 470296
        s6 += s16 * 654183
        s7 -= s16 * 997805
        s8 += s16 * 136657
        s9 -= s16 * 683901
        s16 = 0 //nolint:ineffassign

        s3 += s15 * 666643
        s4 += s15 * 470296
        s5 += s15 * 654183
        s6 -= s15 * 997805
        s7 += s15 * 136657
        s8 -= s15 * 683901
        s15 = 0 //nolint:ineffassign

        s2 += s14 * 666643
        s3 += s14 * 470296
        s4 += s14 * 654183
        s5 -= s14 * 997805
        s6 += s14 * 136657
        s7 -= s14 * 683901
        s14 = 0 //nolint:ineffassign

        s1 += s13 * 666643
        s2 += s13 * 470296
        s3 += s13 * 654183
        s4 -= s13 * 997805
        s5 += s13 * 136657
        s6 -= s13 * 683901
        s13 = 0 //nolint:ineffassign

        s0 += s12 * 666643
        s1 += s12 * 470296
        s2 += s12 * 654183
        s3 -= s12 * 997805
        s4 += s12 * 136657
        s5 -= s12 * 683901
        s12 = 0

        carry[0] = (s0 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s1 += carry[0]
        s0 -= carry[0] &lt;&lt; 21
        carry[2] = (s2 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s3 += carry[2]
        s2 -= carry[2] &lt;&lt; 21
        carry[4] = (s4 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s5 += carry[4]
        s4 -= carry[4] &lt;&lt; 21
        carry[6] = (s6 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[8] = (s8 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[10] = (s10 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21

        carry[1] = (s1 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s2 += carry[1]
        s1 -= carry[1] &lt;&lt; 21
        carry[3] = (s3 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s4 += carry[3]
        s3 -= carry[3] &lt;&lt; 21
        carry[5] = (s5 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s6 += carry[5]
        s5 -= carry[5] &lt;&lt; 21
        carry[7] = (s7 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[9] = (s9 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[11] = (s11 + (1 &lt;&lt; 20)) &gt;&gt; 21
        s12 += carry[11]
        s11 -= carry[11] &lt;&lt; 21

        s0 += s12 * 666643
        s1 += s12 * 470296
        s2 += s12 * 654183
        s3 -= s12 * 997805
        s4 += s12 * 136657
        s5 -= s12 * 683901
        s12 = 0

        carry[0] = s0 &gt;&gt; 21
        s1 += carry[0]
        s0 -= carry[0] &lt;&lt; 21
        carry[1] = s1 &gt;&gt; 21
        s2 += carry[1]
        s1 -= carry[1] &lt;&lt; 21
        carry[2] = s2 &gt;&gt; 21
        s3 += carry[2]
        s2 -= carry[2] &lt;&lt; 21
        carry[3] = s3 &gt;&gt; 21
        s4 += carry[3]
        s3 -= carry[3] &lt;&lt; 21
        carry[4] = s4 &gt;&gt; 21
        s5 += carry[4]
        s4 -= carry[4] &lt;&lt; 21
        carry[5] = s5 &gt;&gt; 21
        s6 += carry[5]
        s5 -= carry[5] &lt;&lt; 21
        carry[6] = s6 &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[7] = s7 &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[8] = s8 &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[9] = s9 &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[10] = s10 &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21
        carry[11] = s11 &gt;&gt; 21
        s12 += carry[11]
        s11 -= carry[11] &lt;&lt; 21

        s0 += s12 * 666643
        s1 += s12 * 470296
        s2 += s12 * 654183
        s3 -= s12 * 997805
        s4 += s12 * 136657
        s5 -= s12 * 683901
        s12 = 0 //nolint:ineffassign

        carry[0] = s0 &gt;&gt; 21
        s1 += carry[0]
        s0 -= carry[0] &lt;&lt; 21
        carry[1] = s1 &gt;&gt; 21
        s2 += carry[1]
        s1 -= carry[1] &lt;&lt; 21
        carry[2] = s2 &gt;&gt; 21
        s3 += carry[2]
        s2 -= carry[2] &lt;&lt; 21
        carry[3] = s3 &gt;&gt; 21
        s4 += carry[3]
        s3 -= carry[3] &lt;&lt; 21
        carry[4] = s4 &gt;&gt; 21
        s5 += carry[4]
        s4 -= carry[4] &lt;&lt; 21
        carry[5] = s5 &gt;&gt; 21
        s6 += carry[5]
        s5 -= carry[5] &lt;&lt; 21
        carry[6] = s6 &gt;&gt; 21
        s7 += carry[6]
        s6 -= carry[6] &lt;&lt; 21
        carry[7] = s7 &gt;&gt; 21
        s8 += carry[7]
        s7 -= carry[7] &lt;&lt; 21
        carry[8] = s8 &gt;&gt; 21
        s9 += carry[8]
        s8 -= carry[8] &lt;&lt; 21
        carry[9] = s9 &gt;&gt; 21
        s10 += carry[9]
        s9 -= carry[9] &lt;&lt; 21
        carry[10] = s10 &gt;&gt; 21
        s11 += carry[10]
        s10 -= carry[10] &lt;&lt; 21

        out[0] = byte(s0 &gt;&gt; 0)
        out[1] = byte(s0 &gt;&gt; 8)
        out[2] = byte((s0 &gt;&gt; 16) | (s1 &lt;&lt; 5))
        out[3] = byte(s1 &gt;&gt; 3)
        out[4] = byte(s1 &gt;&gt; 11)
        out[5] = byte((s1 &gt;&gt; 19) | (s2 &lt;&lt; 2))
        out[6] = byte(s2 &gt;&gt; 6)
        out[7] = byte((s2 &gt;&gt; 14) | (s3 &lt;&lt; 7))
        out[8] = byte(s3 &gt;&gt; 1)
        out[9] = byte(s3 &gt;&gt; 9)
        out[10] = byte((s3 &gt;&gt; 17) | (s4 &lt;&lt; 4))
        out[11] = byte(s4 &gt;&gt; 4)
        out[12] = byte(s4 &gt;&gt; 12)
        out[13] = byte((s4 &gt;&gt; 20) | (s5 &lt;&lt; 1))
        out[14] = byte(s5 &gt;&gt; 7)
        out[15] = byte((s5 &gt;&gt; 15) | (s6 &lt;&lt; 6))
        out[16] = byte(s6 &gt;&gt; 2)
        out[17] = byte(s6 &gt;&gt; 10)
        out[18] = byte((s6 &gt;&gt; 18) | (s7 &lt;&lt; 3))
        out[19] = byte(s7 &gt;&gt; 5)
        out[20] = byte(s7 &gt;&gt; 13)
        out[21] = byte(s8 &gt;&gt; 0)
        out[22] = byte(s8 &gt;&gt; 8)
        out[23] = byte((s8 &gt;&gt; 16) | (s9 &lt;&lt; 5))
        out[24] = byte(s9 &gt;&gt; 3)
        out[25] = byte(s9 &gt;&gt; 11)
        out[26] = byte((s9 &gt;&gt; 19) | (s10 &lt;&lt; 2))
        out[27] = byte(s10 &gt;&gt; 6)
        out[28] = byte((s10 &gt;&gt; 14) | (s11 &lt;&lt; 7))
        out[29] = byte(s11 &gt;&gt; 1)
        out[30] = byte(s11 &gt;&gt; 9)
        out[31] = byte(s11 &gt;&gt; 17)
}</span>

// order is the order of Curve25519 in little-endian form.
var order = [4]uint64{
        0x5812631a5cf5d3ed,
        0x14def9dea2f79cd6,
        0,
        0x1000000000000000,
}

// ScMinimal returns true if the given scalar is less than the order of the
// curve.
func ScMinimal(scalar *[32]byte) bool <span class="cov0" title="0">{
        for i := 3; ; i-- </span><span class="cov0" title="0">{
                v := binary.LittleEndian.Uint64(scalar[i*8:])
                if v &gt; order[i] </span><span class="cov0" title="0">{
                        return false
                }</span> else<span class="cov0" title="0"> if v &lt; order[i] </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if i == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package edwards25519

import (
        "bytes"
        "crypto/sha512"
)

const SignatureSize = 64

func Verify(pub, msg, sig []byte) bool <span class="cov0" title="0">{
        if len(sig) != SignatureSize || sig[63]&amp;224 != 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">var A ExtendedGroupElement
        var publicKeyBytes [32]byte
        copy(publicKeyBytes[:], pub)
        if !A.FromBytes(&amp;publicKeyBytes) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">FeNeg(&amp;A.X, &amp;A.X)
        FeNeg(&amp;A.T, &amp;A.T)

        h := sha512.New()
        _, _ = h.Write(sig[:32])
        _, _ = h.Write(pub[:])
        _, _ = h.Write(msg)
        var digest [64]byte
        h.Sum(digest[:0])

        var hReduced [32]byte
        ScReduce(&amp;hReduced, &amp;digest)

        var R ProjectiveGroupElement
        var s [32]byte
        copy(s[:], sig[32:])

        // https://tools.ietf.org/html/rfc8032#section-5.1.7 requires that s be in
        // the range [0, order) in order to prevent signature malleability.
        if !ScMinimal(&amp;s) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">GeDoubleScalarMultVartime(&amp;R, &amp;hReduced, &amp;A, &amp;s)

        var checkR [32]byte
        R.ToBytes(&amp;checkR)
        return bytes.Equal(sig[:32], checkR[:])</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package plutusencoder

import (
        "errors"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/PlutusData"
)

// SUPPORT FOR ASSETAMOUNTS AND ASSETIDS
// SAMPLE CBOR
// a140a1401a05f5e100

type PlutusMarshaler interface {
        ToPlutusData() (PlutusData.PlutusData, error)
        FromPlutusData(pd PlutusData.PlutusData, res any) error
}

type Asset map[serialization.CustomBytes]map[serialization.CustomBytes]int64

func GetAssetPlutusData(assets Asset) PlutusData.PlutusData <span class="cov8" title="1">{
        outermap := map[serialization.CustomBytes]PlutusData.PlutusData{}
        for key, asset := range assets </span><span class="cov8" title="1">{
                inner := map[serialization.CustomBytes]PlutusData.PlutusData{}
                for k, v := range asset </span><span class="cov8" title="1">{
                        inner[k] = PlutusData.PlutusData{
                                PlutusDataType: PlutusData.PlutusInt,
                                Value:          v,
                        }
                }</span>
                <span class="cov8" title="1">outermap[key] = PlutusData.PlutusData{
                        PlutusDataType: PlutusData.PlutusMap,
                        Value:          inner,
                }</span>
        }
        <span class="cov8" title="1">assetData := PlutusData.PlutusData{
                PlutusDataType: PlutusData.PlutusMap,
                Value:          outermap,
        }
        return assetData</span>
}

// / ADDRESS SUPPORT
func DecodePlutusAsset(pd PlutusData.PlutusData) Asset <span class="cov8" title="1">{
        assets := Asset{}
        val, _ := pd.Value.(map[serialization.CustomBytes]PlutusData.PlutusData)
        for key, asset := range val </span><span class="cov8" title="1">{
                innerval, _ := asset.Value.(map[serialization.CustomBytes]PlutusData.PlutusData)
                inner := map[serialization.CustomBytes]int64{}
                for k, v := range innerval </span><span class="cov8" title="1">{
                        x, ok := v.Value.(int64)
                        if !ok </span><span class="cov8" title="1">{
                                y, ok := v.Value.(uint64)

                                if !ok </span><span class="cov0" title="0">{
                                        panic("error: Int Data field is not int64")</span>
                                }
                                <span class="cov8" title="1">x = int64(y)</span>
                        }

                        <span class="cov8" title="1">inner[k] = x</span>
                }
                <span class="cov8" title="1">assets[key] = inner</span>
        }
        <span class="cov8" title="1">return assets</span>
}

func GetAddressPlutusData(
        address Address.Address,
) (*PlutusData.PlutusData, error) <span class="cov8" title="1">{
        switch address.AddressType </span>{
        case Address.KEY_KEY:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          121,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>

        case Address.SCRIPT_KEY:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          121,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>
        case Address.KEY_SCRIPT:<span class="cov0" title="0">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          122,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>
        case Address.SCRIPT_SCRIPT:<span class="cov0" title="0">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          121,
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value: PlutusData.PlutusIndefArray{
                                                                PlutusData.PlutusData{
                                                                        TagNr:          122,
                                                                        PlutusDataType: PlutusData.PlutusArray,
                                                                        Value: PlutusData.PlutusIndefArray{
                                                                                PlutusData.PlutusData{
                                                                                        TagNr:          0,
                                                                                        Value:          address.StakingPart,
                                                                                        PlutusDataType: PlutusData.PlutusBytes},
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }, nil</span>
        case Address.KEY_NONE:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          121,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value:          PlutusData.PlutusIndefArray{},
                                },
                        },
                }, nil</span>
        case Address.SCRIPT_NONE:<span class="cov8" title="1">
                return &amp;PlutusData.PlutusData{
                        TagNr:          121,
                        PlutusDataType: PlutusData.PlutusArray,
                        Value: PlutusData.PlutusIndefArray{
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value: PlutusData.PlutusIndefArray{
                                                PlutusData.PlutusData{
                                                        TagNr:          0,
                                                        Value:          address.PaymentPart,
                                                        PlutusDataType: PlutusData.PlutusBytes,
                                                },
                                        },
                                },
                                PlutusData.PlutusData{
                                        TagNr:          122,
                                        PlutusDataType: PlutusData.PlutusArray,
                                        Value:          PlutusData.PlutusIndefArray{},
                                },
                        },
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("error: Pointer Addresses are not supported")</span>
        }
}

func DecodePlutusAddress(
        data PlutusData.PlutusData,
        network byte,
) (Address.Address, error) <span class="cov8" title="1">{
        if data.PlutusDataType != PlutusData.PlutusArray &amp;&amp; data.TagNr != 121 &amp;&amp;
                len(data.Value.(PlutusData.PlutusIndefArray)) != 2 </span><span class="cov0" title="0">{
                return Address.Address{}, errors.New("error: Invalid Address Data")
        }</span>
        <span class="cov8" title="1">var isIndef bool
        switch data.Value.(type) </span>{
        case PlutusData.PlutusDefArray:<span class="cov0" title="0">
                isIndef = false</span>
        case PlutusData.PlutusIndefArray:<span class="cov8" title="1">
                isIndef = true</span>
        default:<span class="cov8" title="1">
                return Address.Address{}, errors.New("error: Invalid Address Data")</span>
        }
        <span class="cov8" title="1">if isIndef </span><span class="cov8" title="1">{
                pkh := data.Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.([]byte)
                is_script := data.Value.(PlutusData.PlutusIndefArray)[0].TagNr == 122
                skh := []byte{}
                skh_exists := data.Value.(PlutusData.PlutusIndefArray)[1].TagNr == 121
                is_skh_script := false
                if skh_exists </span><span class="cov8" title="1">{
                        is_skh_script = data.Value.(PlutusData.PlutusIndefArray)[1].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].TagNr == 122
                        skh = data.Value.(PlutusData.PlutusIndefArray)[1].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.(PlutusData.PlutusIndefArray)[0].Value.([]byte)
                }</span>
                <span class="cov8" title="1">var addrType byte
                if is_script </span><span class="cov8" title="1">{
                        if skh_exists </span><span class="cov8" title="1">{
                                if is_skh_script </span><span class="cov0" title="0">{
                                        addrType = Address.SCRIPT_SCRIPT
                                }</span> else<span class="cov8" title="1"> {
                                        addrType = Address.SCRIPT_KEY
                                }</span>
                        } else<span class="cov8" title="1"> {
                                addrType = Address.SCRIPT_NONE
                        }</span>
                } else<span class="cov8" title="1"> {
                        if skh_exists </span><span class="cov8" title="1">{
                                if is_skh_script </span><span class="cov0" title="0">{
                                        addrType = Address.KEY_SCRIPT
                                }</span> else<span class="cov8" title="1"> {
                                        addrType = Address.KEY_KEY
                                }</span>
                        } else<span class="cov0" title="0"> {
                                addrType = Address.KEY_NONE
                        }</span>
                }
                <span class="cov8" title="1">hrp := Address.ComputeHrp(addrType, network)
                header := addrType&lt;&lt;4 | network
                addr := Address.Address{
                        PaymentPart: pkh,
                        StakingPart: skh,
                        AddressType: addrType,
                        Network:     network,
                        HeaderByte:  header,
                        Hrp:         hrp}
                return addr, nil</span>
        } else<span class="cov0" title="0"> {
                pkh := data.Value.(PlutusData.PlutusDefArray)[0].Value.(PlutusData.PlutusDefArray)[0].Value.([]byte)
                is_script := data.Value.(PlutusData.PlutusDefArray)[0].TagNr == 122
                skh := []byte{}
                skh_exists := data.Value.(PlutusData.PlutusDefArray)[1].TagNr == 121
                is_skh_script := false
                if skh_exists </span><span class="cov0" title="0">{
                        is_skh_script = data.Value.(PlutusData.PlutusDefArray)[1].Value.(PlutusData.PlutusDefArray)[0].Value.(PlutusData.PlutusDefArray)[0].Value.(PlutusData.PlutusDefArray)[0].TagNr == 122
                        skh = data.Value.(PlutusData.PlutusDefArray)[1].Value.(PlutusData.PlutusDefArray)[0].Value.(PlutusData.PlutusDefArray)[0].Value.(PlutusData.PlutusDefArray)[0].Value.([]byte)
                }</span>
                <span class="cov0" title="0">var addrType byte
                if is_script </span><span class="cov0" title="0">{
                        if skh_exists </span><span class="cov0" title="0">{
                                if is_skh_script </span><span class="cov0" title="0">{
                                        addrType = Address.SCRIPT_SCRIPT
                                }</span> else<span class="cov0" title="0"> {
                                        addrType = Address.SCRIPT_KEY
                                }</span>
                        } else<span class="cov0" title="0"> {
                                addrType = Address.SCRIPT_NONE
                        }</span>
                } else<span class="cov0" title="0"> {
                        if skh_exists </span><span class="cov0" title="0">{
                                if is_skh_script </span><span class="cov0" title="0">{
                                        addrType = Address.KEY_SCRIPT
                                }</span> else<span class="cov0" title="0"> {
                                        addrType = Address.KEY_KEY
                                }</span>
                        } else<span class="cov0" title="0"> {
                                addrType = Address.KEY_NONE
                        }</span>
                }
                <span class="cov0" title="0">hrp := Address.ComputeHrp(addrType, network)
                header := addrType&lt;&lt;4 | network
                addr := Address.Address{
                        PaymentPart: pkh,
                        StakingPart: skh,
                        AddressType: addrType,
                        Network:     network,
                        HeaderByte:  header,
                        Hrp:         hrp}
                return addr, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package plutusencoder

import (
        "encoding/hex"
        "errors"
        "fmt"
        "math/big"
        "reflect"
        "strconv"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/fxamacker/cbor/v2"
)

func MarshalPlutus(v any) (*PlutusData.PlutusData, error) <span class="cov8" title="1">{
        var overallContainer any
        var containerConstr = uint64(0)
        var isMap = false
        var isIndef = true
        types := reflect.TypeOf(v)
        values := reflect.ValueOf(v)
        //get Container type
        ok := types.Kind() == reflect.Struct
        if ok </span><span class="cov8" title="1">{
                fields, _ := types.FieldByName("_")
                typeOfStruct := fields.Tag.Get("plutusType")
                if typeOfStruct == "Map" </span><span class="cov8" title="1">{
                        isMap = true
                }</span>
                <span class="cov8" title="1">Constr := fields.Tag.Get("plutusConstr")
                if Constr != "" </span><span class="cov8" title="1">{
                        parsedConstr, err := strconv.Atoi(Constr)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error parsing constructor: %w", err)
                        }</span>
                        <span class="cov8" title="1">if parsedConstr &lt; 7 </span><span class="cov8" title="1">{
                                containerConstr = 121 + uint64(parsedConstr)
                        }</span> else<span class="cov8" title="1"> if 7 &lt;= parsedConstr &amp;&amp; parsedConstr &lt;= 1400 </span><span class="cov8" title="1">{
                                containerConstr = 1280 + uint64(parsedConstr-7)
                        }</span> else<span class="cov8" title="1"> {
                                return nil, errors.New("parsedConstr value is above 1400")
                        }</span>
                }
                <span class="cov8" title="1">switch typeOfStruct </span>{
                case "IndefList":<span class="cov8" title="1">
                        overallContainer = PlutusData.PlutusIndefArray{}</span>
                case "Map":<span class="cov8" title="1">
                        overallContainer = map[serialization.CustomBytes]PlutusData.PlutusData{}
                        isMap = true</span>
                case "DefList":<span class="cov8" title="1">
                        overallContainer = PlutusData.PlutusDefArray{}
                        isIndef = false</span>
                default:<span class="cov8" title="1">
                        return nil, errors.New("error: unknown type")</span>
                }
                //get fields
                <span class="cov8" title="1">for i := range types.NumField() </span><span class="cov8" title="1">{
                        f := types.Field(i)
                        if !f.IsExported() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">tag := f.Tag
                        name := f.Name
                        if tag.Get("plutusKey") != "" </span><span class="cov0" title="0">{
                                name = tag.Get("plutusKey")
                        }</span>
                        <span class="cov8" title="1">constr := uint64(0)
                        typeOfField := tag.Get("plutusType")
                        constrOfField := tag.Get("plutusConstr")
                        if constrOfField != "" </span><span class="cov8" title="1">{
                                parsedConstr, err := strconv.Atoi(constrOfField)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("error parsing constructor: %w", err)
                                }</span>
                                <span class="cov8" title="1">if parsedConstr &lt; 7 </span><span class="cov8" title="1">{
                                        constr = 121 + uint64(parsedConstr)
                                }</span> else<span class="cov8" title="1"> if 7 &lt;= parsedConstr &amp;&amp; parsedConstr &lt;= 1400 </span><span class="cov8" title="1">{
                                        constr = 1280 + uint64(parsedConstr-7)
                                }</span> else<span class="cov8" title="1"> {
                                        return nil, errors.New("parsedConstr value is above 1400")
                                }</span>
                        }
                        <span class="cov8" title="1">switch typeOfField </span>{
                        case "IndefBool":<span class="cov0" title="0">
                                if values.Field(i).Kind() != reflect.Bool </span><span class="cov0" title="0">{
                                        return nil, errors.New("error: Bool field is not bool")
                                }</span>
                                <span class="cov0" title="0">var boolPD PlutusData.PlutusData
                                switch values.Field(i).Bool() </span>{
                                case true:<span class="cov0" title="0">
                                        boolPD = PlutusData.PlutusData{
                                                TagNr:          122,
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          PlutusData.PlutusIndefArray{},
                                        }</span>
                                case false:<span class="cov0" title="0">
                                        boolPD = PlutusData.PlutusData{
                                                TagNr:          121,
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          PlutusData.PlutusIndefArray{},
                                        }</span>
                                }
                                <span class="cov0" title="0">if isMap </span><span class="cov0" title="0">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = boolPD
                                }</span> else<span class="cov0" title="0"> {
                                        if isIndef </span><span class="cov0" title="0">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), boolPD)
                                        }</span> else<span class="cov0" title="0"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), boolPD)
                                        }</span>
                                }
                        case "Bool":<span class="cov0" title="0">
                                if values.Field(i).Kind() != reflect.Bool </span><span class="cov0" title="0">{
                                        return nil, errors.New("error: Bool field is not bool")
                                }</span>
                                <span class="cov0" title="0">var boolPD PlutusData.PlutusData
                                switch values.Field(i).Bool() </span>{
                                case true:<span class="cov0" title="0">
                                        boolPD = PlutusData.PlutusData{
                                                TagNr:          122,
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          PlutusData.PlutusDefArray{},
                                        }</span>
                                case false:<span class="cov0" title="0">
                                        boolPD = PlutusData.PlutusData{
                                                TagNr:          121,
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          PlutusData.PlutusDefArray{},
                                        }</span>
                                }
                                <span class="cov0" title="0">if isMap </span><span class="cov0" title="0">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = boolPD
                                }</span> else<span class="cov0" title="0"> {
                                        if isIndef </span><span class="cov0" title="0">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), boolPD)
                                        }</span> else<span class="cov0" title="0"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), boolPD)
                                        }</span>
                                }
                        case "Bytes":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.Slice </span><span class="cov8" title="1">{
                                        return nil, errors.New("error: Bytes field is not a slice")
                                }</span>
                                <span class="cov8" title="1">pdb := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusBytes,
                                        Value:          values.Field(i).Interface().([]byte),
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdb
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdb)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdb)
                                        }</span>
                                }
                        case "BigInt":<span class="cov8" title="1">
                                if values.Field(i).Type().String() != "*big.Int" </span><span class="cov0" title="0">{
                                        return nil, errors.New(
                                                "error: BigInt field is not *big.Int",
                                        )
                                }</span>
                                <span class="cov8" title="1">pdb := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusBigInt,
                                        Value:          values.Field(i).Interface().(*big.Int),
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov0" title="0">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdb
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdb)
                                        }</span> else<span class="cov0" title="0"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdb)
                                        }</span>
                                }

                        case "Int":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.Int64 </span><span class="cov8" title="1">{
                                        return nil, errors.New("error: Int field is not int64")
                                }</span>
                                <span class="cov8" title="1">pdi := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusInt,
                                        Value:          values.Field(i).Interface().(int64),
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)

                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdi
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdi)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdi)
                                        }</span>
                                }
                        case "StringBytes":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.String </span><span class="cov8" title="1">{
                                        return nil, errors.New(
                                                "error: StringBytes field is not string",
                                        )
                                }</span>
                                <span class="cov8" title="1">pdsb := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusBytes,
                                        Value: []byte(
                                                values.Field(i).Interface().(string),
                                        ),
                                        TagNr: constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdsb
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdsb)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdsb)
                                        }</span>
                                }
                        case "HexString":<span class="cov8" title="1">
                                if values.Field(i).Kind() != reflect.String </span><span class="cov8" title="1">{
                                        return nil, errors.New(
                                                "error: HexString field is not string",
                                        )
                                }</span>
                                <span class="cov8" title="1">hexString, err := hex.DecodeString(
                                        values.Field(i).Interface().(string),
                                )
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, errors.New(
                                                "error: HexString field is not string",
                                        )
                                }</span>
                                <span class="cov8" title="1">pdsb := PlutusData.PlutusData{
                                        PlutusDataType: PlutusData.PlutusBytes,
                                        Value:          hexString,
                                        TagNr:          constr,
                                }
                                if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pdsb
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pdsb)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pdsb)
                                        }</span>
                                }
                        case "Custom":<span class="cov8" title="1">
                                tmpval, ok := values.Field(i).Interface().(PlutusMarshaler)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, errors.New(
                                                "error: Custom field does not implement PlutusMarshaler",
                                        )
                                }</span>
                                <span class="cov8" title="1">pd, err := (tmpval).ToPlutusData()
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error marshalling: %w", err)
                                }</span>
                                <span class="cov8" title="1">if isMap </span><span class="cov0" title="0">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = pd
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov0" title="0">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), pd)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), pd)
                                        }</span>
                                }
                        case "Address":<span class="cov8" title="1">
                                addpd, err := GetAddressPlutusData(
                                        values.Field(i).Interface().(Address.Address),
                                )
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error marshalling: %w", err)
                                }</span>
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = *addpd
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), *addpd)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), *addpd)
                                        }</span>
                                }
                        case "Asset":<span class="cov8" title="1">
                                addpd := GetAssetPlutusData(values.Field(i).Interface().(Asset))
                                addpd.TagNr = constr
                                if isMap </span><span class="cov0" title="0">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = addpd
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov0" title="0">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), addpd)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), addpd)
                                        }</span>
                                }
                        case "IndefList":<span class="cov8" title="1">
                                container := PlutusData.PlutusIndefArray{}
                                for j := range values.Field(i).Len() </span><span class="cov8" title="1">{
                                        pd, err := MarshalPlutus(
                                                values.Field(i).Index(j).Interface(),
                                        )
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error marshalling: %w", err)
                                        }</span>
                                        <span class="cov8" title="1">container = append(container, *pd)</span>
                                }
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = PlutusData.PlutusData{
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          container,
                                                TagNr:          constr,
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })

                                        }</span>
                                }
                        case "DefList":<span class="cov8" title="1">
                                container := PlutusData.PlutusDefArray{}
                                for j := range values.Field(i).Len() </span><span class="cov8" title="1">{
                                        pd, err := MarshalPlutus(
                                                values.Field(i).Index(j).Interface(),
                                        )
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error marshalling: %w", err)
                                        }</span>
                                        <span class="cov8" title="1">container = append(container, *pd)</span>
                                }
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = PlutusData.PlutusData{
                                                PlutusDataType: PlutusData.PlutusArray,
                                                Value:          container,
                                                TagNr:          constr,
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusArray,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span>
                                }
                        case "Map":<span class="cov0" title="0">
                                container := map[serialization.CustomBytes]PlutusData.PlutusData{}
                                for j := range values.Field(i).Len() </span><span class="cov0" title="0">{
                                        pd, err := MarshalPlutus(
                                                values.Field(i).Index(j).Interface(),
                                        )
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("error marshalling: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">nameBytes := serialization.NewCustomBytes(
                                                values.Field(i).Index(j).Field(0).String(),
                                        )
                                        container[nameBytes] = *pd</span>
                                }
                                <span class="cov0" title="0">if isMap </span><span class="cov0" title="0">{
                                        nameBytes := serialization.NewCustomBytes(name)
                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = PlutusData.PlutusData{
                                                PlutusDataType: PlutusData.PlutusMap,
                                                Value:          container,
                                                TagNr:          constr,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        if isIndef </span><span class="cov0" title="0">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusMap,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span> else<span class="cov0" title="0"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), PlutusData.PlutusData{
                                                        PlutusDataType: PlutusData.PlutusMap,
                                                        Value:          container,
                                                        TagNr:          constr,
                                                })
                                        }</span>
                                }

                        default:<span class="cov8" title="1">
                                pd, err := MarshalPlutus(values.Field(i).Interface())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error marshalling: %w", err)
                                }</span>
                                <span class="cov8" title="1">if isMap </span><span class="cov8" title="1">{
                                        nameBytes := serialization.NewCustomBytes(name)

                                        overallContainer.(map[serialization.CustomBytes]PlutusData.PlutusData)[nameBytes] = *pd
                                }</span> else<span class="cov8" title="1"> {
                                        if isIndef </span><span class="cov8" title="1">{
                                                overallContainer = append(overallContainer.(PlutusData.PlutusIndefArray), *pd)
                                        }</span> else<span class="cov8" title="1"> {
                                                overallContainer = append(overallContainer.(PlutusData.PlutusDefArray), *pd)
                                        }</span>
                                }
                        }
                }

        }
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                switch types.Kind() </span>{
                case reflect.String:<span class="cov0" title="0">
                        return &amp;PlutusData.PlutusData{
                                PlutusDataType: PlutusData.PlutusBytes,
                                Value:          []byte(values.Interface().(string)),
                                TagNr:          containerConstr,
                        }, nil</span>
                case reflect.Int:<span class="cov0" title="0">
                        return &amp;PlutusData.PlutusData{
                                PlutusDataType: PlutusData.PlutusInt,
                                Value:          values.Interface().(int),
                                TagNr:          containerConstr,
                        }, nil</span>
                case reflect.Slice:<span class="cov0" title="0">
                        return &amp;PlutusData.PlutusData{
                                PlutusDataType: PlutusData.PlutusBytes,
                                Value:          values.Interface().([]byte),
                                TagNr:          containerConstr,
                        }, nil</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("error: unknown type")</span>
                }
        }
        <span class="cov8" title="1">ptype := PlutusData.PlutusArray
        if isMap </span><span class="cov8" title="1">{
                ptype = PlutusData.PlutusMap
        }</span>
        <span class="cov8" title="1">pd := PlutusData.PlutusData{
                PlutusDataType: ptype,
                Value:          overallContainer,
                TagNr:          containerConstr,
        }
        return &amp;pd, nil</span>
}

func CborUnmarshal(data string, v any, network byte) error <span class="cov8" title="1">{
        decoded, err := hex.DecodeString(data)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error decoding hex: %w", err)
        }</span>
        <span class="cov8" title="1">pd := PlutusData.PlutusData{}
        err = cbor.Unmarshal(decoded, &amp;pd)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unmarshalling: %w", err)
        }</span>
        <span class="cov8" title="1">err = UnmarshalPlutus(&amp;pd, v, network)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error unmarshalling: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func UnmarshalPlutus(
        data *PlutusData.PlutusData,
        v any,
        network byte,
) (ret error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        ret = errors.New("error unmarshalling")
                }</span>
        }()

        <span class="cov8" title="1">ret = unmarshalPlutus(data, v, network)
        return ret</span>
}

func unmarshalPlutus(
        data *PlutusData.PlutusData,
        v any,
        network byte,
) error <span class="cov8" title="1">{
        types := reflect.TypeOf(v)
        if types.Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                return fmt.Errorf("error: v is not a pointer %v", v)
        }</span>
        <span class="cov8" title="1">constr := data.TagNr
        //get Container type
        tps := types.Elem()
        //values := reflect.ValueOf(tps)
        //isStruct := tps.Kind() == reflect.Struct
        ok := tps.Kind() == reflect.Struct
        if ok </span><span class="cov8" title="1">{
                fields, _ := tps.FieldByName("_")
                switch data.PlutusDataType </span>{
                case PlutusData.PlutusArray:<span class="cov8" title="1">
                        if reflect.TypeOf(v).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return errors.New("error: v is not a pointer")
                        }</span>
                        <span class="cov8" title="1">if fields.Tag.Get("plutusType") != "IndefList" &amp;&amp;
                                fields.Tag.Get("plutusType") != "DefList" &amp;&amp;
                                fields.Tag.Get("plutusType") != "" </span><span class="cov0" title="0">{
                                return errors.New("error: v is not a PlutusList")
                        }</span>
                        <span class="cov8" title="1">plutusConstr := fields.Tag.Get("plutusConstr")
                        if plutusConstr != "" &amp;&amp;
                                (constr &gt; 1400 || (plutusConstr != strconv.FormatUint(constr-121, 10) &amp;&amp; plutusConstr != strconv.FormatUint(constr-1280, 10))) </span><span class="cov0" title="0">{
                                return fmt.Errorf(
                                        "error: constructorTag does not match, got %s, expected %d",
                                        plutusConstr,
                                        constr,
                                )
                        }</span>

                        <span class="cov8" title="1">arrayType := reflect.TypeOf(data.Value).String()
                        switch arrayType </span>{
                        case "PlutusData.PlutusDefArray":<span class="cov8" title="1">
                                plutusValues, ok := data.Value.(PlutusData.PlutusDefArray)
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.New("error: value is not a PlutusDefArray")
                                }</span>
                                <span class="cov8" title="1">for idx, pAEl := range plutusValues </span><span class="cov8" title="1">{
                                        if tps.Field(idx+1).Type.String() == "Address.Address" </span><span class="cov8" title="1">{
                                                addr, err := DecodePlutusAddress(pAEl, network)
                                                if err != nil </span><span class="cov8" title="1">{
                                                        return fmt.Errorf("error: %w", err)
                                                }</span>
                                                <span class="cov8" title="1">reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(addr))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tps.Field(idx+1).Type.String() == "plutusencoder.Asset" </span><span class="cov8" title="1">{
                                                asset := DecodePlutusAsset(pAEl)
                                                reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(asset))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tps.Field(idx+1).Type.String() == "bool" </span><span class="cov0" title="0">{
                                                if tps.Field(idx+1).Type.String() != "bool" </span><span class="cov0" title="0">{
                                                        return errors.New("error: Bool field is not bool")
                                                }</span>
                                                <span class="cov0" title="0">reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        SetBool(pAEl.TagNr == 122)
                                                continue</span>
                                        }
                                        // Create new object of the type of the field
                                        <span class="cov8" title="1">x, ok := reflect.ValueOf(v).Elem().Field(idx + 1).Addr().Interface().(PlutusMarshaler)
                                        if ok </span><span class="cov8" title="1">{
                                                err := x.FromPlutusData(pAEl, x)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error: %w", err)
                                                }</span>
                                                <span class="cov8" title="1">continue</span>
                                        }
                                        <span class="cov8" title="1">switch pAEl.PlutusDataType </span>{
                                        case PlutusData.PlutusBytes:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "[]uint8" </span><span class="cov8" title="1">{
                                                        if tps.Field(idx+1).Type.String() != "string" </span><span class="cov0" title="0">{
                                                                return errors.New(
                                                                        "error: Bytes field is not a slice",
                                                                )
                                                        }</span> else<span class="cov8" title="1"> {
                                                                if reflect.TypeOf(v).Elem().Field(idx+1).Tag.Get("plutusType") == "HexString" </span><span class="cov8" title="1">{
                                                                        reflect.ValueOf(v).Elem().Field(idx + 1).SetString(hex.EncodeToString(pAEl.Value.([]byte)))
                                                                        continue</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetString(string(pAEl.Value.([]byte)))
                                                                continue</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(pAEl.Value))</span>
                                        case PlutusData.PlutusInt:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "int64" </span><span class="cov0" title="0">{
                                                        return errors.New("error: Int field is not int64")
                                                }</span>
                                                <span class="cov8" title="1">x, ok := pAEl.Value.(int64)
                                                if !ok </span><span class="cov8" title="1">{
                                                        y, ok := pAEl.Value.(uint64)

                                                        if !ok </span><span class="cov0" title="0">{
                                                                return errors.New(
                                                                        "error: Int Data field is not int64",
                                                                )
                                                        }</span>
                                                        <span class="cov8" title="1">x = int64(y)</span>
                                                }

                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetInt(x)</span>
                                        case PlutusData.PlutusBigInt:<span class="cov0" title="0">
                                                if tps.Field(idx+1).Type.String() != "int64" &amp;&amp;
                                                        tps.Field(idx+1).Type.String() != "*big.Int" </span><span class="cov0" title="0">{
                                                        return errors.New("error: Int field is not bigInt")
                                                }</span>
                                                <span class="cov0" title="0">x, ok := pAEl.Value.(big.Int)
                                                if !ok </span><span class="cov0" title="0">{
                                                        return errors.New(
                                                                "error: Int Data field is not bigInt",
                                                        )
                                                }</span>
                                                <span class="cov0" title="0">if tps.Field(idx+1).Type.String() == "*big.Int" </span><span class="cov0" title="0">{
                                                        reflect.ValueOf(v).
                                                                Elem().
                                                                Field(idx + 1).
                                                                Set(reflect.ValueOf(&amp;x))
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">i64 := x.Int64()
                                                reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(i64))</span>
                                        case PlutusData.PlutusArray:<span class="cov8" title="1">
                                                if reflect.TypeOf(v).
                                                        Elem().
                                                        Field(idx+1).
                                                        Type.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusIndefArray)
                                                        if ok </span><span class="cov8" title="1">{
                                                                val := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val.Grow(len(pa))
                                                                val.SetLen(len(pa))
                                                                for secIdx, arrayElement := range pa </span><span class="cov0" title="0">{
                                                                        err := unmarshalPlutus(
                                                                                &amp;arrayElement,
                                                                                val.Index(secIdx).Addr().Interface(),
                                                                                network,
                                                                        )
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf(
                                                                                        "error at index %d.%d: %w",
                                                                                        idx,
                                                                                        secIdx,
                                                                                        err,
                                                                                )
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).
                                                                        Elem().
                                                                        Field(idx + 1).
                                                                        Set(val)</span>
                                                        } else<span class="cov8" title="1"> {
                                                                pa2, ok := pAEl.Value.(PlutusData.PlutusDefArray)
                                                                if !ok </span><span class="cov0" title="0">{
                                                                        return errors.New("error: value is not a PlutusArray")
                                                                }</span>
                                                                <span class="cov8" title="1">val2 := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val2.Grow(len(pa2))
                                                                val2.SetLen(len(pa2))
                                                                for secIdx, arrayElement := range pa2 </span><span class="cov8" title="1">{
                                                                        err := unmarshalPlutus(&amp;arrayElement, val2.Index(secIdx).Addr().Interface(), network)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf("error at index %d.%d: %w", idx, secIdx, err)
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(val2)</span>
                                                        }
                                                } else<span class="cov8" title="1"> {
                                                        err := unmarshalPlutus(&amp;pAEl, reflect.ValueOf(v).Elem().Field(idx+1).Addr().Interface(), network)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error at index %d: %w", idx, err)
                                                        }</span>
                                                }
                                        case PlutusData.PlutusMap:<span class="cov8" title="1">
                                                err := unmarshalPlutus(
                                                        &amp;pAEl,
                                                        reflect.ValueOf(v).
                                                                Elem().
                                                                Field(idx+1).
                                                                Addr().
                                                                Interface(),
                                                        network,
                                                )
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error at index %d: %w", idx, err)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                return errors.New("error: unknown type")</span>
                                        }
                                }
                        case "PlutusData.PlutusIndefArray":<span class="cov8" title="1">
                                plutusValues, ok := data.Value.(PlutusData.PlutusIndefArray)
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.New("error: value is not a PlutusIndefArray")
                                }</span>
                                <span class="cov8" title="1">for idx, pAEl := range plutusValues </span><span class="cov8" title="1">{
                                        x, ok := reflect.ValueOf(v).Elem().Field(idx + 1).Addr().Interface().(PlutusMarshaler)
                                        if ok </span><span class="cov0" title="0">{
                                                err := x.FromPlutusData(pAEl, x)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error: %w", err)
                                                }</span>
                                                <span class="cov0" title="0">continue</span>
                                        }
                                        <span class="cov8" title="1">if tps.Field(idx+1).Type.String() == "Address.Address" </span><span class="cov8" title="1">{
                                                addr, err := DecodePlutusAddress(pAEl, network)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error: %w", err)
                                                }</span>
                                                <span class="cov8" title="1">reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(addr))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tps.Field(idx+1).Type.String() == "plutusencoder.Asset" </span><span class="cov0" title="0">{
                                                asset := DecodePlutusAsset(pAEl)
                                                reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(asset))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if tps.Field(idx+1).Type.String() == "bool" </span><span class="cov0" title="0">{
                                                if tps.Field(idx+1).Type.String() != "bool" </span><span class="cov0" title="0">{
                                                        return errors.New("error: Bool field is not bool")
                                                }</span>
                                                <span class="cov0" title="0">reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        SetBool(pAEl.TagNr == 122)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">switch pAEl.PlutusDataType </span>{
                                        case PlutusData.PlutusBytes:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "[]uint8" </span><span class="cov8" title="1">{
                                                        if tps.Field(idx+1).Type.String() != "string" </span><span class="cov0" title="0">{
                                                                return errors.New(
                                                                        "error: Bytes field is not a slice",
                                                                )
                                                        }</span> else<span class="cov8" title="1"> {
                                                                if reflect.TypeOf(v).Elem().Field(idx+1).Tag.Get("plutusType") == "HexString" </span><span class="cov8" title="1">{
                                                                        reflect.ValueOf(v).Elem().Field(idx + 1).SetString(hex.EncodeToString(pAEl.Value.([]byte)))
                                                                        continue</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetString(string(pAEl.Value.([]byte)))
                                                                continue</span>
                                                        }
                                                }
                                                <span class="cov8" title="1">reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(pAEl.Value))</span>
                                        case PlutusData.PlutusInt:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "int64" </span><span class="cov0" title="0">{
                                                        return errors.New("error: Int field is not int64")
                                                }</span>
                                                <span class="cov8" title="1">x, ok := pAEl.Value.(int64)
                                                if !ok </span><span class="cov8" title="1">{
                                                        y, ok := pAEl.Value.(uint64)

                                                        if !ok </span><span class="cov0" title="0">{
                                                                return errors.New(
                                                                        "error: Int Data field is not int64",
                                                                )
                                                        }</span>
                                                        <span class="cov8" title="1">x = int64(y)</span>
                                                }

                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).SetInt(x)</span>
                                        case PlutusData.PlutusBigInt:<span class="cov8" title="1">
                                                if tps.Field(idx+1).Type.String() != "int64" &amp;&amp;
                                                        tps.Field(idx+1).Type.String() != "*big.Int" </span><span class="cov0" title="0">{
                                                        return errors.New("error: Int field is not bigInt")
                                                }</span>
                                                <span class="cov8" title="1">x, ok := pAEl.Value.(big.Int)
                                                if !ok </span><span class="cov0" title="0">{
                                                        return errors.New(
                                                                "error: Int Data field is not bigInt",
                                                        )
                                                }</span>
                                                <span class="cov8" title="1">if tps.Field(idx+1).Type.String() == "*big.Int" </span><span class="cov8" title="1">{
                                                        reflect.ValueOf(v).
                                                                Elem().
                                                                Field(idx + 1).
                                                                Set(reflect.ValueOf(&amp;x))
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">i64 := x.Int64()
                                                reflect.ValueOf(v).
                                                        Elem().
                                                        Field(idx + 1).
                                                        Set(reflect.ValueOf(i64))</span>

                                        case PlutusData.PlutusArray:<span class="cov8" title="1">
                                                if reflect.TypeOf(v).
                                                        Elem().
                                                        Field(idx+1).
                                                        Type.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusIndefArray)
                                                        if ok </span><span class="cov8" title="1">{
                                                                val := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val.Grow(len(pa))
                                                                val.SetLen(len(pa))
                                                                for secIdx, arrayElement := range pa </span><span class="cov8" title="1">{
                                                                        err := unmarshalPlutus(
                                                                                &amp;arrayElement,
                                                                                val.Index(secIdx).Addr().Interface(),
                                                                                network,
                                                                        )
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf(
                                                                                        "error at index %d.%d: %w",
                                                                                        idx,
                                                                                        secIdx,
                                                                                        err,
                                                                                )
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).
                                                                        Elem().
                                                                        Field(idx + 1).
                                                                        Set(val)</span>
                                                        } else<span class="cov8" title="1"> {
                                                                pa2, ok := pAEl.Value.(PlutusData.PlutusDefArray)
                                                                if !ok </span><span class="cov0" title="0">{
                                                                        return errors.New("error: value is not a PlutusArray")
                                                                }</span>
                                                                <span class="cov8" title="1">val2 := reflect.ValueOf(v).Elem().Field(idx + 1)
                                                                val2.Grow(len(pa2))
                                                                val2.SetLen(len(pa2))
                                                                for secIdx, arrayElement := range pa2 </span><span class="cov8" title="1">{
                                                                        err := unmarshalPlutus(&amp;arrayElement, val2.Index(secIdx).Addr().Interface(), network)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return fmt.Errorf("error at index %d.%d: %w", idx, secIdx, err)
                                                                        }</span>
                                                                }
                                                                <span class="cov8" title="1">reflect.ValueOf(v).Elem().Field(idx + 1).Set(val2)</span>
                                                        }
                                                } else<span class="cov8" title="1"> {
                                                        err := unmarshalPlutus(&amp;pAEl, reflect.ValueOf(v).Elem().Field(idx+1).Addr().Interface(), network)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("error at index %d: %w", idx, err)
                                                        }</span>
                                                }
                                        case PlutusData.PlutusMap:<span class="cov8" title="1">
                                                err := unmarshalPlutus(
                                                        &amp;pAEl,
                                                        reflect.ValueOf(v).
                                                                Elem().
                                                                Field(idx+1).
                                                                Addr().
                                                                Interface(),
                                                        network,
                                                )
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error at index %d: %w", idx, err)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                return errors.New("error: unknown type")</span>
                                        }
                                }
                        default:<span class="cov0" title="0">
                                return errors.New("error: unknown type")</span>
                        }
                case PlutusData.PlutusMap:<span class="cov8" title="1">
                        values, ok := data.Value.(map[serialization.CustomBytes]PlutusData.PlutusData)
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New("error: value is not a PlutusMap")
                        }</span>
                        <span class="cov8" title="1">for idxStringHex, pAEl := range values </span><span class="cov8" title="1">{
                                idxBytes, _ := hex.DecodeString(idxStringHex.HexString())
                                idx := string(idxBytes)
                                field, ok := tps.FieldByName(idx)
                                if !ok </span><span class="cov0" title="0">{
                                        found := false
                                        for i := range tps.NumField() </span><span class="cov0" title="0">{
                                                if tps.Field(i).Tag.Get("plutusKey") == idx </span><span class="cov0" title="0">{
                                                        idx = tps.Field(i).Name
                                                        field = tps.Field(i)
                                                        found = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error: field %s does not exist", idx)
                                        }</span>
                                }
                                <span class="cov8" title="1">x, ok := reflect.ValueOf(v).Elem().FieldByName(idx).Addr().Interface().(PlutusMarshaler)
                                if ok </span><span class="cov0" title="0">{
                                        err := x.FromPlutusData(pAEl, x)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error: %w", err)
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                                <span class="cov8" title="1">switch field.Type.String() </span>{
                                case "Asset":<span class="cov0" title="0">
                                        asset := DecodePlutusAsset(pAEl)
                                        reflect.ValueOf(v).
                                                Elem().
                                                FieldByName(idx).
                                                Set(reflect.ValueOf(asset))
                                        continue</span>
                                case "Address.Address":<span class="cov8" title="1">
                                        addr, err := DecodePlutusAddress(pAEl, network)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("error: %w", err)
                                        }</span>
                                        <span class="cov8" title="1">reflect.ValueOf(v).
                                                Elem().
                                                FieldByName(idx).
                                                Set(reflect.ValueOf(addr))
                                        continue</span>
                                case "bool":<span class="cov0" title="0">
                                        reflect.ValueOf(v).
                                                Elem().
                                                FieldByName(idx).
                                                SetBool(pAEl.TagNr == 122)
                                        continue</span>
                                case "[]uint8":<span class="cov8" title="1">
                                        if pAEl.PlutusDataType != PlutusData.PlutusBytes </span><span class="cov0" title="0">{
                                                return errors.New("error: Bytes field is not a slice")
                                        }</span>
                                        <span class="cov8" title="1">reflect.ValueOf(v).
                                                Elem().
                                                FieldByName(idx).
                                                Set(reflect.ValueOf(pAEl.Value))</span>
                                case "string":<span class="cov8" title="1">
                                        if pAEl.PlutusDataType != PlutusData.PlutusBytes </span><span class="cov0" title="0">{
                                                return errors.New("error: Bytes field is not a slice")
                                        }</span>
                                        <span class="cov8" title="1">tp, _ := reflect.TypeOf(v).Elem().FieldByName(idx)
                                        if tp.Tag.Get("plutusType") == "HexString" </span><span class="cov8" title="1">{
                                                reflect.ValueOf(v).
                                                        Elem().
                                                        FieldByName(string(idx)).
                                                        SetString(hex.EncodeToString(pAEl.Value.([]byte)))
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">reflect.ValueOf(v).
                                                Elem().
                                                FieldByName(idx).
                                                SetString(string(pAEl.Value.([]byte)))</span>
                                case "int64":<span class="cov8" title="1">
                                        if pAEl.PlutusDataType != PlutusData.PlutusInt </span><span class="cov0" title="0">{
                                                return errors.New("error: Int field is not int64")
                                        }</span>

                                        <span class="cov8" title="1">x, ok := pAEl.Value.(int64)
                                        if !ok </span><span class="cov8" title="1">{
                                                y, ok := pAEl.Value.(uint64)

                                                if !ok </span><span class="cov0" title="0">{
                                                        return errors.New(
                                                                "error: Int Data field is not int64",
                                                        )
                                                }</span>
                                                <span class="cov8" title="1">x = int64(y)</span>
                                        }
                                        <span class="cov8" title="1">reflect.ValueOf(v).Elem().FieldByName(idx).SetInt(x)</span>
                                default:<span class="cov8" title="1">
                                        switch pAEl.PlutusDataType </span>{
                                        case PlutusData.PlutusArray:<span class="cov8" title="1">
                                                tp, _ := reflect.TypeOf(v).Elem().FieldByName(idx)
                                                switch tp.Tag.Get("plutusType") </span>{
                                                case "IndefList":<span class="cov8" title="1">
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusIndefArray)
                                                        if !ok </span><span class="cov0" title="0">{
                                                                return errors.New(
                                                                        "error: value is not a PlutusArray",
                                                                )
                                                        }</span>
                                                        <span class="cov8" title="1">val := reflect.ValueOf(v).Elem().FieldByName(idx)
                                                        val.Grow(len(pa))
                                                        val.SetLen(len(pa))
                                                        for secIdx, arrayElement := range pa </span><span class="cov8" title="1">{
                                                                err := unmarshalPlutus(
                                                                        &amp;arrayElement,
                                                                        val.Index(secIdx).Addr().Interface(),
                                                                        network,
                                                                )
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf(
                                                                                "error at index %s.%d: %w",
                                                                                idx,
                                                                                secIdx,
                                                                                err,
                                                                        )
                                                                }</span>
                                                        }
                                                        <span class="cov8" title="1">reflect.ValueOf(v).Elem().FieldByName(idx).Set(val)</span>
                                                case "DefList":<span class="cov8" title="1">
                                                        pa, ok := pAEl.Value.(PlutusData.PlutusDefArray)
                                                        if !ok </span><span class="cov0" title="0">{
                                                                return errors.New(
                                                                        "error: value is not a PlutusArray",
                                                                )
                                                        }</span>
                                                        <span class="cov8" title="1">val := reflect.ValueOf(v).Elem().FieldByName(idx)
                                                        val.Grow(len(pa))
                                                        val.SetLen(len(pa))
                                                        for secIdx, arrayElement := range pa </span><span class="cov8" title="1">{
                                                                err := unmarshalPlutus(
                                                                        &amp;arrayElement,
                                                                        val.Index(secIdx).Addr().Interface(),
                                                                        network,
                                                                )
                                                                if err != nil </span><span class="cov0" title="0">{
                                                                        return fmt.Errorf(
                                                                                "error at index %s.%d: %w",
                                                                                idx,
                                                                                secIdx,
                                                                                err,
                                                                        )
                                                                }</span>
                                                        }
                                                        <span class="cov8" title="1">reflect.ValueOf(v).Elem().FieldByName(idx).Set(val)</span>
                                                default:<span class="cov0" title="0">
                                                        err := unmarshalPlutus(
                                                                &amp;pAEl,
                                                                reflect.ValueOf(v).
                                                                        Elem().
                                                                        FieldByName(idx).
                                                                        Addr().
                                                                        Interface(),
                                                                network,
                                                        )
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return fmt.Errorf(
                                                                        "error at index %s: %w",
                                                                        idx,
                                                                        err,
                                                                )
                                                        }</span>

                                                }
                                        case PlutusData.PlutusMap:<span class="cov8" title="1">
                                                err := unmarshalPlutus(
                                                        &amp;pAEl,
                                                        reflect.ValueOf(v).
                                                                Elem().
                                                                FieldByName(idx).
                                                                Addr().
                                                                Interface(),
                                                        network,
                                                )
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("error at index %s: %w", idx, err)
                                                }</span>
                                        default:<span class="cov0" title="0">
                                                return errors.New("error: unknown type")</span>
                                        }
                                }
                        }
                default:<span class="cov0" title="0">
                        return errors.New("error: unknown type")</span>
                }
        } else<span class="cov0" title="0"> {
                if types.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        types = types.Elem()
                }</span>
                <span class="cov0" title="0">switch types.Kind() </span>{
                case reflect.String:<span class="cov0" title="0">
                        if data.PlutusDataType != PlutusData.PlutusBytes </span><span class="cov0" title="0">{
                                return errors.New("error: Bytes field is not a slice")
                        }</span>
                        <span class="cov0" title="0">if reflect.TypeOf(v).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return errors.New("error: v is not a pointer")
                        }</span>
                        <span class="cov0" title="0">if reflect.TypeOf(v).Elem().Kind() != reflect.String </span><span class="cov0" title="0">{
                                return errors.New("error: v is not a string")
                        }</span>
                        <span class="cov0" title="0">reflect.ValueOf(v).Elem().SetString(string(data.Value.([]byte)))</span>
                case reflect.Int:<span class="cov0" title="0">
                        if data.PlutusDataType != PlutusData.PlutusInt </span><span class="cov0" title="0">{
                                return errors.New("error: Int field is not int64")
                        }</span>
                        <span class="cov0" title="0">if reflect.TypeOf(v).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return errors.New("error: v is not a pointer")
                        }</span>
                        <span class="cov0" title="0">if reflect.TypeOf(v).Elem().Kind() != reflect.Int </span><span class="cov0" title="0">{
                                return errors.New("error: v is not an int")
                        }</span>
                        <span class="cov0" title="0">reflect.ValueOf(v).Elem().SetInt(data.Value.(int64))</span>
                case reflect.Slice:<span class="cov0" title="0">
                        if data.PlutusDataType != PlutusData.PlutusBytes </span><span class="cov0" title="0">{
                                return errors.New("error: Bytes field is not a slice")
                        }</span>
                        <span class="cov0" title="0">if reflect.TypeOf(v).Kind() != reflect.Ptr </span><span class="cov0" title="0">{
                                return errors.New("error: v is not a pointer")
                        }</span>
                        <span class="cov0" title="0">if reflect.TypeOf(v).Elem().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                                return errors.New("error: v is not a slice")
                        }</span>
                        <span class="cov0" title="0">reflect.ValueOf(v).Elem().Set(reflect.ValueOf(data.Value))</span>
                default:<span class="cov0" title="0">
                        return errors.New("error: unknown type")</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package Address

import (
        "encoding/hex"
        "errors"
        "fmt"

        "github.com/Salvionied/apollo/constants"
        "github.com/Salvionied/apollo/crypto/bech32"
        "github.com/Salvionied/apollo/serialization"
        "github.com/fxamacker/cbor/v2"
)

const (
        BYRON          = 0b1000
        KEY_KEY        = 0b0000
        SCRIPT_KEY     = 0b0001
        KEY_SCRIPT     = 0b0010
        SCRIPT_SCRIPT  = 0b0011
        KEY_POINTER    = 0b0100
        SCRIPT_POINTER = 0b0101
        KEY_NONE       = 0b0110
        SCRIPT_NONE    = 0b0111
        NONE_KEY       = 0b1110
        NONE_SCRIPT    = 0b1111
)
const (
        MAINNET = 1
        TESTNET = 0
)

type Address struct {
        PaymentPart []byte
        StakingPart []byte
        Network     byte
        AddressType byte
        HeaderByte  byte
        Hrp         string
}

func WalletAddressFromBytes(
        payment []byte,
        staking []byte,
        network constants.Network,
) *Address <span class="cov8" title="1">{
        var addr Address
        addr.PaymentPart = payment
        addr.StakingPart = staking
        if network == constants.MAINNET </span><span class="cov8" title="1">{
                addr.Network = MAINNET
        }</span> else<span class="cov8" title="1"> {
                addr.Network = TESTNET
        }</span>
        <span class="cov8" title="1">if len(payment) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if len(staking) == 0 </span><span class="cov8" title="1">{
                addr.AddressType = KEY_NONE
        }</span> else<span class="cov8" title="1"> {
                addr.AddressType = KEY_KEY
        }</span>
        <span class="cov8" title="1">addr.HeaderByte = (addr.AddressType &lt;&lt; 4) | addr.Network
        addr.Hrp = ComputeHrp(addr.AddressType, addr.Network)
        return &amp;addr</span>
}

/**
This function check if the current address is equal to another address.

Params:
        addr (*Address): A pointer to the current address.
        other (*Address): A pointer to the other address for comparison.

Returns:
        bool: true if the addresses are equal, false otherwise.
*/

func (addr *Address) Equal(other *Address) bool <span class="cov8" title="1">{
        return addr.String() == other.String()
}</span>

/*
*

        Debug method returns a formatted string representation of the address for debugging

        Returns:
                string: A formatted debug string representing the address.
*/
func (addr *Address) Debug() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "{\nPaymentPart: %v\nStakingPart: %v\nNetwork: %v\nAddressType: %v\nHeaderByte: %v\nHrp: %s\n}",
                addr.PaymentPart,
                addr.StakingPart,
                addr.Network,
                addr.AddressType,
                addr.HeaderByte,
                addr.Hrp,
        )
}</span>

/*
*

        It converts an address to its CBOR (Concise Binary Object Representation) format and returns


        it as a hexadecimal string. This function marshals the address into its binary representation


        using the CBOR encoding. In case of success, it returns the binary data encoded as a
        hexadecimal string, otherwise a fatal error is logged.

        Returns:


        string: A hexadecimal string representation of the address in CBOR format.
        error: An error if the conversion fails.
*/
func (addr *Address) ToCbor() (string, error) <span class="cov8" title="1">{
        b, err := cbor.Marshal(addr.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error marshalling address to cbor, %w", err)
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(b), nil</span>
}

/*
*

                MarshalCBOR encodes an address to its CBOR (Concise Binary Object Representation) format.

                Returns:
                           []byte: A slice of bytes representing the address in CBOR format.
                          error: An error, if any, encountered during the encoding process.
*/
func (addr *Address) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal(addr.Bytes())
}</span>

/*
*

        UnmarshalCBOR decodes a CBOR (Concise Binary Object Representation) encoded address from a byte slice.

        Params:
                value ([]byte): A byte slice containing the CBOR-encoded address.

        Returns:
                error: An error, if any, encountered during the decoding process.
*/
func (addr *Address) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        res := make([]byte, 0)
        err := cbor.Unmarshal(value, &amp;res)
        header := res[0]
        payload := res[1:]
        addr.PaymentPart = payload[:serialization.VERIFICATION_KEY_HASH_SIZE]
        addr.StakingPart = payload[serialization.VERIFICATION_KEY_HASH_SIZE:]
        addr.Network = (header &amp; 0x0F)
        addr.AddressType = (header &amp; 0xF0) &gt;&gt; 4
        addr.HeaderByte = header
        addr.Hrp = ComputeHrp(addr.AddressType, addr.Network)
        return err
}</span>

/*
*

        This function returns the binary representation of the address. It
        constructs and returns the binary representation of the address containing
        the header byte, payment part, and staking part (if present).

        Returns:
                []byte: A byte slice representing the binary data of the address.
*/
func (addr Address) Bytes() []byte <span class="cov8" title="1">{
        var payment []byte
        var staking []byte
        payment = addr.PaymentPart
        if len(addr.StakingPart) == 28 </span><span class="cov8" title="1">{
                staking = addr.StakingPart
        }</span> else<span class="cov8" title="1"> {
                staking = make([]byte, 0)
        }</span>
        <span class="cov8" title="1">result := make([]byte, 0)
        result = append(result, addr.HeaderByte)
        result = append(result, payment...)
        return append(result, staking...)</span>

}

/*
*

        This function returns the string representation of the address.

        Returns:
                string: A string representing the address in Bech32 format.
*/
func (addr Address) String() string <span class="cov8" title="1">{
        byteaddress, err := bech32.ConvertBits(addr.Bytes(), 8, 5, true)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">result, _ := bech32.Encode(addr.Hrp, byteaddress)
        return result</span>
}

/*
*

        ComputeHrp computes the human-readable part (Hrp) for an address
        based on its address type and network.

        Params:
                 address_type (uint8): The type of the address.
                network (uint8): The network identifier (1 for mainnet, 0 for testnet).

        Returns:
                string: The computed Hrp for address encoding.
*/
func ComputeHrp(address_type uint8, network uint8) string <span class="cov8" title="1">{
        var prefix string
        if address_type == NONE_KEY || address_type == NONE_SCRIPT </span><span class="cov8" title="1">{
                prefix = "stake"
        }</span> else<span class="cov8" title="1"> {
                prefix = "addr"
        }</span>
        <span class="cov8" title="1">var suffix string
        if network == 1 </span><span class="cov8" title="1">{
                suffix = ""
        }</span> else<span class="cov8" title="1"> {
                suffix = "_test"
        }</span>
        <span class="cov8" title="1">return prefix + suffix</span>

}

/*
*

        This function decodes a string representation of an address into its corresponding Address structure.

        Parameters:
                value (string): The string representation of the address to decode.

        Returns:
                Address: The decoded Address structure.
                error: An error, if any, encountered during the decoding process.
*/
func DecodeAddress(value string) (Address, error) <span class="cov8" title="1">{
        _, data, err := bech32.Decode(value)
        if err != nil </span><span class="cov8" title="1">{
                return Address{}, err
        }</span>

        <span class="cov8" title="1">decoded_value, _ := bech32.ConvertBits(data, 5, 8, false)

        header := decoded_value[0]
        payload := decoded_value[1:]
        network := (header &amp; 0x0F)
        addr_type := (header &amp; 0xF0) &gt;&gt; 4
        if network != 0b0000 &amp;&amp; network != 0b0001 </span><span class="cov8" title="1">{
                return Address{}, errors.New("invalid network tag")
        }</span>
        <span class="cov8" title="1">switch addr_type </span>{
        case KEY_KEY:<span class="cov8" title="1">
                return Address{
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        payload[serialization.VERIFICATION_KEY_HASH_SIZE:],
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        case SCRIPT_KEY:<span class="cov8" title="1">
                return Address{
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        payload[serialization.VERIFICATION_KEY_HASH_SIZE:],
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        case KEY_SCRIPT:<span class="cov8" title="1">
                return Address{
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        payload[serialization.VERIFICATION_KEY_HASH_SIZE:],
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        case KEY_NONE:<span class="cov8" title="1">
                return Address{
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        make([]byte, 0),
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        case SCRIPT_SCRIPT:<span class="cov8" title="1">
                return Address{
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        payload[serialization.VERIFICATION_KEY_HASH_SIZE:],
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        case SCRIPT_NONE:<span class="cov8" title="1">
                return Address{
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        make([]byte, 0),
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        case NONE_KEY:<span class="cov8" title="1">
                return Address{
                        make([]byte, 0),
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        default:<span class="cov8" title="1">
                return Address{
                        make([]byte, 0),
                        payload[:serialization.VERIFICATION_KEY_HASH_SIZE],
                        network,
                        addr_type,
                        header,
                        ComputeHrp(addr_type, network),
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package Amount

import "github.com/Salvionied/apollo/serialization/MultiAsset"

type Amount struct {
        _     struct{} `cbor:",toarray"`
        Coin  int64
        Value MultiAsset.MultiAsset[int64]
}

/*
*

        ToAlonzo converts an Amount to its Alonzo representation creating
        a new AlonzoAmount object.

        Params:
                amt (Amount): The original Amount to be converted.

        Returns:
                AlonzoAmount: The Alonzo representation of the Amount.
*/
func (amt Amount) ToAlonzo() AlonzoAmount <span class="cov8" title="1">{
        return AlonzoAmount{
                Coin:  amt.Coin,
                Value: amt.Value.Clone(),
        }
}</span>

/*
*

        ToShelley converts an AlonzoAmount to its Shelley representation
        creating a new Amount object.

        Params:
                amtAl (AlonzoAmount): The original AlonzoAmount to be converted.

        Returns:
                Amount: The Amount representation of the AlonzoAmount.
*/
func (amtAl AlonzoAmount) ToShelley() Amount <span class="cov8" title="1">{
        return Amount{
                Coin:  amtAl.Coin,
                Value: amtAl.Value.Clone(),
        }
}</span>

type AlonzoAmount struct {
        _     struct{} `cbor:",toarray"`
        Coin  int64
        Value MultiAsset.MultiAsset[int64]
}

/*
*

        Clone function creates a deep copy of an AlonzoAmount object.

        Returns:
                AlonzoAmount: A deep copy of the AlonzoAmount.
*/
func (am AlonzoAmount) Clone() AlonzoAmount <span class="cov8" title="1">{
        return AlonzoAmount{
                Coin:  am.Coin,
                Value: am.Value.Clone(),
        }
}</span>

/*
*

        RemoveZeroAssets remove zero-value assets from an amount.

        Returns:
                Amount: A copy of the Amount without zero-value assets.
*/
func (am Amount) RemoveZeroAssets() Amount <span class="cov8" title="1">{
        res := am.Clone()
        res.Value = res.Value.RemoveZeroAssets()
        return res
}</span>

/*
*

        Clone function creates a deep copy of an Amount object.

        Returns:
                AlonzoAmount: A deep copy of the Amount.
*/
func (am Amount) Clone() Amount <span class="cov8" title="1">{
        return Amount{
                Coin:  am.Coin,
                Value: am.Value.Clone(),
        }
}</span>

/*
*

        This function checks if two Amount are equal.

        Params:
                other (Amount): The other Amount to compare.

        Returns:
                bool: true if the two Amount are equal, false otherwise.
*/
func (am Amount) Equal(other Amount) bool <span class="cov8" title="1">{
        return am.Coin == other.Coin &amp;&amp; am.Value.Equal(other.Value)
}</span>

/*
*

        Less function checks if an Amount is less than another Amount.

        Params:
                other (Amount): The other Amount to compare.

        Returns:
                bool: true if the current Amount is less than the other Amount, false otherwise.
*/
func (am Amount) Less(other Amount) bool <span class="cov8" title="1">{
        return am.Coin &lt; other.Coin &amp;&amp; am.Value.Less(other.Value)
}</span>

/*
*

        Greater function checks if an Amount is greater than another Amount.

        Params:
                other (Amount): The other Amount to compare.

        Returns:
                bool: true if the current Amount is greater than the other Amount, false otherwise.
*/
func (am Amount) Greater(other Amount) bool <span class="cov8" title="1">{
        return am.Coin &gt; other.Coin &amp;&amp; am.Value.Greater(other.Value)
}</span>

/*
*

        Add function adds an Amount to the current Amount.

        Params:
                other (Amount): The other Amount to add to the current Amount.

        Returns:
                Amount: The resulting Amount after addition.
*/
func (am Amount) Add(other Amount) Amount <span class="cov8" title="1">{
        am.Coin += other.Coin
        am.Value = am.Value.Add(other.Value)
        return am
}</span>

/*
*

        Sub function subtracts an Amount from the current Amount.

        Params:
                other (Amount): The other Amount to subtract from the current Amount.

        Returns:
                Amount: The resulting Amount after subtraction.
*/
func (am Amount) Sub(other Amount) Amount <span class="cov8" title="1">{
        am.Coin -= other.Coin
        am.Value = am.Value.Sub(other.Value)
        return am
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package Asset

import (
        "maps"
        "reflect"

        "github.com/Salvionied/apollo/serialization/AssetName"
)

type Asset[V int64 | uint64] map[AssetName.AssetName]V

/*
*

        Clone creates a deep copy of an Asset map.

        Returns:
                Asset[V]: A deep copy of the original Asset map.
*/
func (ma Asset[V]) Clone() Asset[V] <span class="cov8" title="1">{
        result := make(Asset[V])
        maps.Copy(result, ma)
        return result
}</span>

/*
*

        Equal checks if two Asset maps are equal using
        the function DeepEuqal from the package "reflect".

        Parameters:
                other (Asset[V]): The other Asset map to compare to.

        Returns:
                  bool: true if the two Asset maps are equal, false otherwise.
*/
func (ma Asset[V]) Equal(other Asset[V]) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(ma, other)
}</span>

/*
*

        Less function checks if the current Asset map is less than
        another Asset map.

        Parameters:
                other (Asset[V]): The other Asset map to compare to.

        Returns:


        bool: true if the current Asset map is less than the other, false otherwise.
*/
func (ma Asset[V]) Less(other Asset[V]) bool <span class="cov8" title="1">{
        for asset, amount := range ma </span><span class="cov8" title="1">{
                otherAmount, ok := other[asset]
                if !ok || amount &gt; otherAmount </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

/*
*

        Greater function checks if the current Asset map is greater than
        another Asset map.

        Parameters:
                other (Asset[V]): The other Asset map to compare to.

        Returns:


        bool: true if the current Asset map is greater than the other, false otherwise.
*/
func (ma Asset[V]) Greater(other Asset[V]) bool <span class="cov8" title="1">{
        for asset, amount := range ma </span><span class="cov8" title="1">{
                otherAmount, ok := other[asset]
                if ok &amp;&amp; amount &lt; otherAmount </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

/*
*

        Sub subtracts another Asset map from the current Asset map.

        Params:
                other (Asset[V]): The Asset map to subtract from the current Asset map.

        Returns:
                Asset[V]: The resulting Asset map after subtraction.
*/
func (ma Asset[V]) Sub(other Asset[V]) Asset[V] <span class="cov8" title="1">{
        for asset, amount := range other </span><span class="cov8" title="1">{
                _, ok := ma[asset]
                if ok </span><span class="cov8" title="1">{
                        ma[asset] -= amount
                }</span> else<span class="cov8" title="1"> {
                        ma[asset] = -amount
                }</span>
        }
        <span class="cov8" title="1">return ma</span>
}

/*
*

        Add adds another Asset map to the current Asset map.

        Params:
                other (Asset[V]): The Asset map to add to the current Asset map.

        Returns:
                Asset[V]: The resulting Asset map after addition.
*/
func (ma Asset[V]) Add(other Asset[V]) Asset[V] <span class="cov8" title="1">{
        for asset, amount := range other </span><span class="cov8" title="1">{
                _, ok := ma[asset]
                if ok </span><span class="cov8" title="1">{
                        ma[asset] += amount
                }</span> else<span class="cov8" title="1"> {
                        ma[asset] = amount
                }</span>
        }
        <span class="cov8" title="1">return ma</span>
}

/*
*

        Inverted creates a copy of an Asset map containing opposite amounts
        of the original one.

        Returns:
                Asset[V]: An inverted copy of the original Asset map.
*/
func (ma Asset[V]) Inverted() Asset[V] <span class="cov8" title="1">{
        for asset, amount := range ma </span><span class="cov8" title="1">{
                ma[asset] = -amount
        }</span>
        <span class="cov8" title="1">return ma</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package AssetName

import (
        "encoding/hex"
        "errors"

        "github.com/fxamacker/cbor/v2"
)

type AssetName struct {
        value string
}

/*
internal use only
*/
func NewAssetNameFromHexString(value string) *AssetName <span class="cov8" title="1">{
        _, err := hex.DecodeString(value)

        if err != nil || len(value) &gt; 64 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;AssetName{value: value}</span>
}

func NewAssetNameFromString(value string) AssetName <span class="cov8" title="1">{
        v := hex.EncodeToString([]byte(value))
        return AssetName{value: v}
}</span>

func (an AssetName) String() string <span class="cov8" title="1">{
        decoded, _ := hex.DecodeString(an.value)
        return string(decoded)
}</span>

func (an AssetName) HexString() string <span class="cov8" title="1">{
        return an.value
}</span>

func (an *AssetName) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if an.value == "[]" || an.value == "" </span><span class="cov8" title="1">{
                return cbor.Marshal(make([]byte, 0))
        }</span>

        <span class="cov8" title="1">if len(an.value) &gt; 64 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid asset name length")
        }</span>

        <span class="cov8" title="1">byteSlice, _ := hex.DecodeString(an.value)

        return cbor.Marshal(byteSlice)</span>
}

func (an *AssetName) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var res []byte
        err := cbor.Unmarshal(value, &amp;res)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if len(res) &gt; 32 </span><span class="cov8" title="1">{
                return errors.New("invalid asset name length")
        }</span>

        <span class="cov8" title="1">an.value = hex.EncodeToString(res)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package Certificate

import (
        "errors"

        "github.com/Salvionied/apollo/serialization"
        RelayPkg "github.com/Salvionied/apollo/serialization/Relay"
        "github.com/fxamacker/cbor/v2"
)

type Credential struct {
        _    struct{} `cbor:",toarray"`
        Code int
        Hash serialization.ConstrainedBytes
}

func (sc *Credential) Kind() int <span class="cov0" title="0">{
        return sc.Code
}</span>

func (sc *Credential) KeyHash() serialization.PubKeyHash <span class="cov0" title="0">{
        res := serialization.PubKeyHash(sc.Hash.Payload)
        return res
}</span>

// Union interface for all certificates
type CertificateInterface interface {
        Kind() int
        MarshalCBOR() ([]byte, error)
        StakeCredential() *Credential
        DrepCredential() *Credential
        AuthCommitteeHotCredential() *Credential
        AuthCommitteeColdCredential() *Credential
}

// UnitInterval is a fraction between 0 and 1
type UnitInterval struct {
        _   struct{} `cbor:",toarray"`
        Num int64
        Den int64
}

type Relay interface {
        Kind() int
}

type PoolParams struct {
        _             struct{} `cbor:",toarray"`
        Operator      serialization.PubKeyHash
        VrfKeyHash    []byte
        Pledge        int64
        Cost          int64
        Margin        UnitInterval
        RewardAccount []byte
        PoolOwners    []serialization.PubKeyHash
        Relays        RelayPkg.Relays
        PoolMetadata  *struct {
                _    struct{} `cbor:",toarray"`
                Url  string
                Hash []byte
        }
}

// drep = [0, addr_keyhash // 1, script_hash // 2 // 3]
type Drep struct {
        _          struct{} `cbor:",toarray"`
        Code       int
        Credential *serialization.ConstrainedBytes
}

func (d Drep) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if d.Credential == nil </span><span class="cov8" title="1">{
                return cbor.Marshal(d.Code)
        }</span>
        <span class="cov8" title="1">return cbor.Marshal([]any{d.Code, d.Credential})</span>
}

func (d *Drep) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        // First, try to unmarshal as a simple int (for always_abstain or always_no_confidence)
        var code int
        if err := cbor.Unmarshal(data, &amp;code); err == nil </span><span class="cov8" title="1">{
                d.Code = code
                d.Credential = nil
                return nil
        }</span>
        // Otherwise, unmarshal as array [code, credential]
        <span class="cov8" title="1">var arr []any
        if err := cbor.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(arr) != 2 </span><span class="cov0" title="0">{
                return errors.New("invalid drep format")
        }</span>
        <span class="cov8" title="1">var drepCode int
        switch c := arr[0].(type) </span>{
        case int:<span class="cov0" title="0">
                drepCode = c</span>
        case uint64:<span class="cov8" title="1">
                if c &gt; 1&lt;&lt;31-1 </span><span class="cov0" title="0">{
                        return errors.New("drep code too large")
                }</span>
                <span class="cov8" title="1">drepCode = int(c)</span>
        case int64:<span class="cov0" title="0">
                if c &lt; 0 || c &gt; 1&lt;&lt;31-1 </span><span class="cov0" title="0">{
                        return errors.New("invalid drep code")
                }</span>
                <span class="cov0" title="0">drepCode = int(c)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid drep code type")</span>
        }
        <span class="cov8" title="1">d.Code = drepCode
        if arr[1] == nil </span><span class="cov0" title="0">{
                d.Credential = nil
        }</span> else<span class="cov8" title="1"> if b, ok := arr[1].([]byte); ok </span><span class="cov8" title="1">{
                d.Credential = &amp;serialization.ConstrainedBytes{Payload: b}
        }</span> else<span class="cov0" title="0"> {
                return errors.New("invalid drep credential type")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type Anchor struct {
        _        struct{} `cbor:",toarray"`
        Url      string
        DataHash []byte
}

// Variant types
type StakeRegistration struct{ Stake Credential }

func (v StakeRegistration) Kind() int <span class="cov8" title="1">{ return 0 }</span>

func (v StakeRegistration) StakeCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Stake }</span>

func (v StakeRegistration) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeRegistration) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeRegistration) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v StakeRegistration) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake})
}</span>

type StakeDeregistration struct{ Stake Credential }

func (v StakeDeregistration) Kind() int <span class="cov8" title="1">{ return 1 }</span>

func (v StakeDeregistration) StakeCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Stake }</span>

func (v StakeDeregistration) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeDeregistration) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeDeregistration) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v StakeDeregistration) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake})
}</span>

type StakeDelegation struct {
        Stake       Credential
        PoolKeyHash serialization.PubKeyHash
}

func (v StakeDelegation) Kind() int <span class="cov8" title="1">{ return 2 }</span>

func (v StakeDelegation) StakeCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Stake }</span>

func (v StakeDelegation) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeDelegation) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeDelegation) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v StakeDelegation) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.PoolKeyHash})
}</span>

type PoolRegistration struct{ Params PoolParams }

func (v PoolRegistration) Kind() int <span class="cov8" title="1">{ return 3 }</span>

func (v PoolRegistration) StakeCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v PoolRegistration) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v PoolRegistration) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v PoolRegistration) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v PoolRegistration) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Params})
}</span>

type PoolRetirement struct {
        PoolKeyHash serialization.PubKeyHash
        EpochNo     uint64
}

func (v PoolRetirement) Kind() int                                <span class="cov8" title="1">{ return 4 }</span>
func (v PoolRetirement) StakeCredential() *Credential             <span class="cov0" title="0">{ return nil }</span>
func (v PoolRetirement) DrepCredential() *Credential              <span class="cov0" title="0">{ return nil }</span>
func (v PoolRetirement) AuthCommitteeHotCredential() *Credential  <span class="cov0" title="0">{ return nil }</span>
func (v PoolRetirement) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v PoolRetirement) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.PoolKeyHash, v.EpochNo})
}</span>

type RegCert struct {
        Stake Credential
        Coin  int64
}

func (v RegCert) Kind() int                                <span class="cov8" title="1">{ return 7 }</span>
func (v RegCert) StakeCredential() *Credential             <span class="cov0" title="0">{ return &amp;v.Stake }</span>
func (v RegCert) DrepCredential() *Credential              <span class="cov0" title="0">{ return nil }</span>
func (v RegCert) AuthCommitteeHotCredential() *Credential  <span class="cov0" title="0">{ return nil }</span>
func (v RegCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v RegCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.Coin})
}</span>

type UnregCert struct {
        Stake Credential
        Coin  int64
}

func (v UnregCert) Kind() int                                <span class="cov8" title="1">{ return 8 }</span>
func (v UnregCert) StakeCredential() *Credential             <span class="cov0" title="0">{ return &amp;v.Stake }</span>
func (v UnregCert) DrepCredential() *Credential              <span class="cov0" title="0">{ return nil }</span>
func (v UnregCert) AuthCommitteeHotCredential() *Credential  <span class="cov0" title="0">{ return nil }</span>
func (v UnregCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v UnregCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.Coin})
}</span>

type VoteDelegCert struct {
        Stake Credential
        Drep  Drep
}

func (v VoteDelegCert) Kind() int <span class="cov8" title="1">{ return 9 }</span>

func (v VoteDelegCert) StakeCredential() *Credential             <span class="cov0" title="0">{ return &amp;v.Stake }</span>
func (v VoteDelegCert) DrepCredential() *Credential              <span class="cov0" title="0">{ return nil }</span>
func (v VoteDelegCert) AuthCommitteeHotCredential() *Credential  <span class="cov0" title="0">{ return nil }</span>
func (v VoteDelegCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v VoteDelegCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.Drep})
}</span>

type StakeVoteDelegCert struct {
        Stake       Credential
        PoolKeyHash serialization.PubKeyHash
        Drep        Drep
}

func (v StakeVoteDelegCert) Kind() int <span class="cov8" title="1">{ return 10 }</span>

func (v StakeVoteDelegCert) StakeCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Stake }</span>

func (v StakeVoteDelegCert) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeVoteDelegCert) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeVoteDelegCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v StakeVoteDelegCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.PoolKeyHash, v.Drep})
}</span>

type StakeRegDelegCert struct {
        Stake       Credential
        PoolKeyHash serialization.PubKeyHash
        Coin        int64
}

func (v StakeRegDelegCert) Kind() int <span class="cov8" title="1">{ return 11 }</span>

func (v StakeRegDelegCert) StakeCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Stake }</span>

func (v StakeRegDelegCert) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeRegDelegCert) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeRegDelegCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v StakeRegDelegCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.PoolKeyHash, v.Coin})
}</span>

type VoteRegDelegCert struct {
        Stake Credential
        Drep  Drep
        Coin  int64
}

func (v VoteRegDelegCert) Kind() int <span class="cov8" title="1">{ return 12 }</span>

func (v VoteRegDelegCert) StakeCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Stake }</span>

func (v VoteRegDelegCert) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v VoteRegDelegCert) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v VoteRegDelegCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v VoteRegDelegCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.Drep, v.Coin})
}</span>

type StakeVoteRegDelegCert struct {
        Stake       Credential
        PoolKeyHash serialization.PubKeyHash
        Drep        Drep
        Coin        int64
}

func (v StakeVoteRegDelegCert) Kind() int <span class="cov8" title="1">{ return 13 }</span>

func (v StakeVoteRegDelegCert) StakeCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Stake }</span>

func (v StakeVoteRegDelegCert) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeVoteRegDelegCert) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v StakeVoteRegDelegCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v StakeVoteRegDelegCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Stake, v.PoolKeyHash, v.Drep, v.Coin})
}</span>

type AuthCommitteeHotCert struct {
        Cold Credential
        Hot  Credential
}

func (v AuthCommitteeHotCert) Kind() int <span class="cov8" title="1">{ return 14 }</span>

func (v AuthCommitteeHotCert) StakeCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v AuthCommitteeHotCert) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v AuthCommitteeHotCert) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Hot }</span>

func (v AuthCommitteeHotCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Cold }</span>
func (v AuthCommitteeHotCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Cold, v.Hot})
}</span>

type ResignCommitteeColdCert struct {
        Cold   Credential
        Anchor *Anchor
}

func (v ResignCommitteeColdCert) Kind() int <span class="cov8" title="1">{ return 15 }</span>

func (v ResignCommitteeColdCert) StakeCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v ResignCommitteeColdCert) DrepCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v ResignCommitteeColdCert) AuthCommitteeHotCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v ResignCommitteeColdCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return &amp;v.Cold }</span>
func (v ResignCommitteeColdCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Cold, v.Anchor})
}</span>

type RegDRepCert struct {
        Cred   Credential // DrepCredential field renamed to avoid conflict with method
        Coin   int64
        Anchor *Anchor
}

func (v RegDRepCert) Kind() int                    <span class="cov8" title="1">{ return 16 }</span>
func (v RegDRepCert) StakeCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v RegDRepCert) DrepCredential() *Credential              <span class="cov0" title="0">{ return &amp;v.Cred }</span>
func (v RegDRepCert) AuthCommitteeHotCredential() *Credential  <span class="cov0" title="0">{ return nil }</span>
func (v RegDRepCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v RegDRepCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Cred, v.Coin, v.Anchor})
}</span>

type UnregDRepCert struct {
        Cred Credential // DrepCredential field renamed to avoid conflict with method
        Coin int64
}

func (v UnregDRepCert) Kind() int                    <span class="cov8" title="1">{ return 17 }</span>
func (v UnregDRepCert) StakeCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v UnregDRepCert) DrepCredential() *Credential              <span class="cov0" title="0">{ return &amp;v.Cred }</span>
func (v UnregDRepCert) AuthCommitteeHotCredential() *Credential  <span class="cov0" title="0">{ return nil }</span>
func (v UnregDRepCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v UnregDRepCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Cred, v.Coin})
}</span>

type UpdateDRepCert struct {
        Cred   Credential // DrepCredential field renamed to avoid conflict with method
        Anchor *Anchor
}

func (v UpdateDRepCert) Kind() int                    <span class="cov8" title="1">{ return 18 }</span>
func (v UpdateDRepCert) StakeCredential() *Credential <span class="cov0" title="0">{ return nil }</span>

func (v UpdateDRepCert) DrepCredential() *Credential              <span class="cov0" title="0">{ return &amp;v.Cred }</span>
func (v UpdateDRepCert) AuthCommitteeHotCredential() *Credential  <span class="cov0" title="0">{ return nil }</span>
func (v UpdateDRepCert) AuthCommitteeColdCredential() *Credential <span class="cov0" title="0">{ return nil }</span>
func (v UpdateDRepCert) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal([]any{v.Kind(), v.Cred, v.Anchor})
}</span>

// Collection type with CBOR codec

type Certificates []CertificateInterface

func NewCertificates(
        certs ...CertificateInterface,
) Certificates <span class="cov0" title="0">{
        return certs
}</span>

func UnmarshalCert(data []byte) (CertificateInterface, error) <span class="cov8" title="1">{
        var rec []any
        err := cbor.Unmarshal(data, &amp;rec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(rec) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("empty or invalid certificate")
        }</span>

        <span class="cov8" title="1">kind, err := RelayPkg.ReadKind(rec[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">re := func(v any, out any) error </span><span class="cov8" title="1">{
                bz, err := cbor.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return cbor.Unmarshal(bz, out)</span>
        }

        <span class="cov8" title="1">switch kind </span>{
        case 0:<span class="cov8" title="1"> // stake_registration = (0, stake_credential)
                if len(rec) != 2 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid stake registration certificate")
                }</span>
                <span class="cov8" title="1">var stake Credential
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return StakeRegistration{Stake: stake}, nil</span>
        case 1:<span class="cov8" title="1"> // stake_deregistration = (1, stake_credential)
                if len(rec) != 2 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid stake deregistration certificate")
                }</span>
                <span class="cov8" title="1">var stake Credential
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return StakeDeregistration{Stake: stake}, nil</span>
        case 2:<span class="cov8" title="1"> // stake_delegation = (2, stake_credential, pool_keyhash)
                if len(rec) != 3 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid stake delegation certificate")
                }</span>
                <span class="cov8" title="1">var stake Credential
                var poolKeyHash serialization.PubKeyHash
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;poolKeyHash); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return StakeDelegation{Stake: stake, PoolKeyHash: poolKeyHash}, nil</span>
        case 3:<span class="cov8" title="1"> // pool_registration = (3, pool_params)
                if len(rec) != 2 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid pool registration certificate")
                }</span>
                <span class="cov8" title="1">var params PoolParams
                if err := re(rec[1], &amp;params); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return PoolRegistration{Params: params}, nil</span>
        case 4:<span class="cov8" title="1"> // pool_retirement = (4, pool_keyhash, epoch_no)
                if len(rec) != 3 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid pool retirement certificate")
                }</span>
                <span class="cov8" title="1">var poolKeyHash serialization.PubKeyHash
                var epochNo uint64
                if err := re(rec[1], &amp;poolKeyHash); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;epochNo); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return PoolRetirement{PoolKeyHash: poolKeyHash, EpochNo: epochNo}, nil</span>
        case 7:<span class="cov8" title="1"> // reg_cert = (7, stake_credential, coin)
                if len(rec) != 3 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid registration certificate")
                }</span>
                <span class="cov8" title="1">var stake Credential
                var coin int64
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;coin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return RegCert{Stake: stake, Coin: coin}, nil</span>
        case 8:<span class="cov8" title="1"> // unreg_cert = (8, stake_credential, coin)
                if len(rec) != 3 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid unregistration certificate")
                }</span>
                <span class="cov8" title="1">var stake Credential
                var coin int64
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;coin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return UnregCert{Stake: stake, Coin: coin}, nil</span>
        case 9:<span class="cov8" title="1"> // vote_deleg_cert = (9, stake_credential, drep)
                if len(rec) != 3 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid vote delegation certificate")
                }</span>
                <span class="cov8" title="1">var stake Credential
                var drep Drep
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;drep); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return VoteDelegCert{Stake: stake, Drep: drep}, nil</span>
        case 10:<span class="cov8" title="1"> // stake_vote_deleg_cert = (10, stake_credential, pool_keyhash, drep)
                if len(rec) != 4 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid stake vote delegation certificate")
                }</span>
                <span class="cov8" title="1">var stake Credential
                var poolKeyHash serialization.PubKeyHash
                var drep Drep
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;poolKeyHash); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[3], &amp;drep); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return StakeVoteDelegCert{
                        Stake:       stake,
                        PoolKeyHash: poolKeyHash,
                        Drep:        drep,
                }, nil</span>
        case 11:<span class="cov8" title="1"> // stake_reg_deleg_cert = (11, stake_credential, pool_keyhash, coin)
                if len(rec) != 4 </span><span class="cov8" title="1">{
                        return nil, errors.New(
                                "invalid stake registration delegation certificate",
                        )
                }</span>
                <span class="cov8" title="1">var stake Credential
                var poolKeyHash serialization.PubKeyHash
                var coin int64
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;poolKeyHash); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[3], &amp;coin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return StakeRegDelegCert{
                        Stake:       stake,
                        PoolKeyHash: poolKeyHash,
                        Coin:        coin,
                }, nil</span>
        case 12:<span class="cov8" title="1"> // vote_reg_deleg_cert = (12, stake_credential, drep, coin)
                if len(rec) != 4 </span><span class="cov8" title="1">{
                        return nil, errors.New(
                                "invalid vote registration delegation certificate",
                        )
                }</span>
                <span class="cov8" title="1">var stake Credential
                var drep Drep
                var coin int64
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;drep); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[3], &amp;coin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return VoteRegDelegCert{Stake: stake, Drep: drep, Coin: coin}, nil</span>
        case 13:<span class="cov8" title="1"> // stake_vote_reg_deleg_cert = (13, stake_credential, pool_keyhash, drep, coin)
                if len(rec) != 5 </span><span class="cov8" title="1">{
                        return nil, errors.New(
                                "invalid stake vote registration delegation certificate",
                        )
                }</span>
                <span class="cov8" title="1">var stake Credential
                var poolKeyHash serialization.PubKeyHash
                var drep Drep
                var coin int64
                if err := re(rec[1], &amp;stake); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;poolKeyHash); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[3], &amp;drep); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[4], &amp;coin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return StakeVoteRegDelegCert{
                        Stake:       stake,
                        PoolKeyHash: poolKeyHash,
                        Drep:        drep,
                        Coin:        coin,
                }, nil</span>
        case 14:<span class="cov8" title="1"> // auth_committee_hot_cert = (14, cold_credential, hot_credential)
                if len(rec) != 3 </span><span class="cov8" title="1">{
                        return nil, errors.New(
                                "invalid authentication committee hot certificate",
                        )
                }</span>
                <span class="cov8" title="1">var cold Credential
                var hot Credential
                if err := re(rec[1], &amp;cold); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;hot); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return AuthCommitteeHotCert{Cold: cold, Hot: hot}, nil</span>
        case 15:<span class="cov8" title="1"> // resign_committee_cold_cert = (15, cold_credential, anchor/ nil)
                if len(rec) &lt; 2 </span><span class="cov8" title="1">{
                        return nil, errors.New(
                                "invalid resignation committee cold certificate",
                        )
                }</span>
                <span class="cov8" title="1">var cold Credential
                var anchor *Anchor
                var validAnchor Anchor
                if err := re(rec[1], &amp;cold); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(rec) &gt; 2 &amp;&amp; rec[2] != nil </span><span class="cov8" title="1">{
                        if err := re(rec[2], &amp;validAnchor); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">anchor = &amp;validAnchor</span>
                } else<span class="cov8" title="1"> {
                        anchor = nil
                }</span>
                <span class="cov8" title="1">return ResignCommitteeColdCert{Cold: cold, Anchor: anchor}, nil</span>
        case 16:<span class="cov8" title="1"> // reg_drep_cert = (16, drep_credential, coin, anchor/ nil)
                if len(rec) &lt; 3 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid registration D-rep certificate")
                }</span>
                <span class="cov8" title="1">var drep Credential
                var coin int64
                var anchor *Anchor
                var validAnchor Anchor
                if err := re(rec[1], &amp;drep); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;coin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(rec) &gt; 3 &amp;&amp; rec[3] != nil </span><span class="cov8" title="1">{ // anchor is optional
                        if err := re(rec[3], &amp;validAnchor); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">anchor = &amp;validAnchor</span>
                } else<span class="cov8" title="1"> {
                        anchor = nil
                }</span>
                <span class="cov8" title="1">return RegDRepCert{Cred: drep, Coin: coin, Anchor: anchor}, nil</span>
        case 17:<span class="cov8" title="1"> // unreg_drep_cert = (17, drep_credential, coin)
                if len(rec) != 3 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid unregistration D-rep certificate")
                }</span>
                <span class="cov8" title="1">var drep Credential
                var coin int64
                if err := re(rec[1], &amp;drep); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := re(rec[2], &amp;coin); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return UnregDRepCert{Cred: drep, Coin: coin}, nil</span>
        case 18:<span class="cov8" title="1"> // update_drep_cert = (18, drep_credential, anchor/ nil)
                if len(rec) &lt; 2 </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid update D-rep certificate")
                }</span>
                <span class="cov8" title="1">var drep Credential
                var anchor *Anchor
                var validAnchor Anchor
                if err := re(rec[1], &amp;drep); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(rec) &gt; 2 &amp;&amp; rec[2] != nil </span><span class="cov8" title="1">{
                        if err := re(rec[2], &amp;validAnchor); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">anchor = &amp;validAnchor</span>
                } else<span class="cov8" title="1"> {
                        anchor = nil
                }</span>
                <span class="cov8" title="1">return UpdateDRepCert{Cred: drep, Anchor: anchor}, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("invalid certificate kind")</span>
        }
}

func (cs Certificates) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        arr := make([][]byte, 0, len(cs))
        for _, cert := range cs </span><span class="cov8" title="1">{
                bz, err := cert.MarshalCBOR()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">arr = append(arr, bz)</span>
        }
        <span class="cov8" title="1">out := make([]any, 0, len(arr))
        for _, e := range arr </span><span class="cov8" title="1">{
                var v any
                if err := cbor.Unmarshal(e, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out = append(out, v)</span>
        }
        <span class="cov8" title="1">return cbor.Marshal(out)</span>
}

func (cs *Certificates) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        var raw []any
        err := cbor.Unmarshal(data, &amp;raw)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">res := make(Certificates, 0, len(raw))
        for _, item := range raw </span><span class="cov8" title="1">{
                marshaledCert, err := cbor.Marshal(item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">cert, err := UnmarshalCert(marshaledCert)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">res = append(res, cert)</span>
        }
        <span class="cov8" title="1">*cs = res
        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package Fingerprint

import (
        "encoding/hex"

        "github.com/Salvionied/apollo/crypto/bech32"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Policy"
        "golang.org/x/crypto/blake2b"
)

type Fingerprint struct {
        policyId  *Policy.PolicyId
        assetName *AssetName.AssetName
}

func New(
        policyId *Policy.PolicyId,
        assetName *AssetName.AssetName,
) *Fingerprint <span class="cov8" title="1">{
        return &amp;Fingerprint{
                policyId:  policyId,
                assetName: assetName,
        }
}</span>

func (f *Fingerprint) PolicyId() *Policy.PolicyId <span class="cov0" title="0">{
        return f.policyId
}</span>

func (f *Fingerprint) AssetName() *AssetName.AssetName <span class="cov0" title="0">{
        return f.assetName
}</span>

func (f *Fingerprint) String() string <span class="cov8" title="1">{
        bs, _ := hex.DecodeString(f.policyId.Value + f.assetName.HexString())
        hasher, _ := blake2b.New(20, nil)
        hasher.Write(bs)
        hashBytes := hasher.Sum(nil)

        words, _ := bech32.ConvertBits(hashBytes, 8, 5, false)
        result, _ := bech32.Encode("asset", words)
        return result
}</span>

func (f *Fingerprint) ToPlutusData() PlutusData.PlutusData <span class="cov0" title="0">{
        policyIdValue, _ := hex.DecodeString(f.policyId.Value)
        assetNameValue, _ := hex.DecodeString(f.assetName.HexString())

        return PlutusData.PlutusData{
                TagNr:          121,
                PlutusDataType: PlutusData.PlutusArray,
                Value: PlutusData.PlutusIndefArray{
                        PlutusData.PlutusData{
                                TagNr:          0,
                                PlutusDataType: PlutusData.PlutusBytes,
                                Value:          policyIdValue,
                        },
                        PlutusData.PlutusData{
                                TagNr:          0,
                                PlutusDataType: PlutusData.PlutusBytes,
                                Value:          assetNameValue,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package HDWallet

import (
        "crypto/sha512"
        "encoding/hex"
        "errors"
        "strconv"
        "strings"

        "github.com/Salvionied/apollo/crypto/bip32"

        "github.com/tyler-smith/go-bip39"
        "golang.org/x/crypto/pbkdf2"
        "golang.org/x/text/unicode/norm"
)

type HDWallet struct {
        RootXprivKey bip32.XPrv
        XPrivKey     bip32.XPrv
        Path         string
        Seed         []byte
        Mnemonic     string
        Passphrase   string
        Entropy      string
}

func tweak_bits(seed []byte) []byte <span class="cov8" title="1">{
        seed[0] &amp;= 0b11111000
        seed[31] &amp;= 0b00011111
        seed[31] |= 0b01000000
        return seed
}</span>

/*
*

        NewHDWalletFromSeed creates a new HDWallet instance from a seed string.

        Params:
                seed (string): The input seed string.

        Returns:
                *HDWallet: A new HDWallet instance.
                error: An error if the new wallet fails.
*/
func NewHDWalletFromSeed(seed string) (*HDWallet, error) <span class="cov8" title="1">{
        seed_converted, err := hex.DecodeString(seed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">seed_modified := tweak_bits(seed_converted)
        privKey, err := bip32.NewXPrv(seed_modified)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;HDWallet{
                RootXprivKey: privKey,
                XPrivKey:     privKey,
                Path:         "m",
                Seed:         seed_converted,
                Mnemonic:     "",
                Passphrase:   "",
                Entropy:      "",
        }, nil</span>

}

/*
*

        GenerateSeed generates a seed string from a mnemonic and passphrase.

        Params:
                mnemonic (string): The mnemonic for seed generation.
                passphrase (string): The passphrase for seed generation.

        Returns:
                string: The seed string in hexadecimal format.
                error: An error if the generation seed fails.
*/
func GenerateSeed(mnemonic string, passphrase string) (string, error) <span class="cov0" title="0">{
        seed, err := bip39.NewSeedWithErrorChecking(mnemonic, passphrase)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(seed), nil</span>
}

func generateSeedFromEntropy(passphrase string, entropy []byte) string <span class="cov8" title="1">{
        res := pbkdf2.Key([]byte(passphrase), entropy, 4096, 96, sha512.New)
        return hex.EncodeToString(res)
}</span>

/**
NewHDWalletFromMnemonic creates a new HDWallet instance from a
mnemonic and passphrase.

Params:
        mnemonic (string): The mnemonic for wallet generation.
        passphrase (string): The passphrase for wallet generation.

Returns:
        *HDWallet: A new HDWallet instance.
        error: An error if the new wallet fails.
*/

func NewHDWalletFromMnemonic(
        mnemonic string,
        passphrase string,
) (*HDWallet, error) <span class="cov8" title="1">{
        mnemo := norm.NFKD.String(mnemonic)
        entropy, error := bip39.EntropyFromMnemonic(mnemonic)
        if error != nil </span><span class="cov0" title="0">{
                return nil, error
        }</span>
        <span class="cov8" title="1">if !bip39.IsMnemonicValid(mnemo) </span><span class="cov0" title="0">{
                return nil, error
        }</span>
        <span class="cov8" title="1">seed := generateSeedFromEntropy(passphrase, entropy)
        wallet, err := NewHDWalletFromSeed(seed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">wallet.Seed = []byte(seed)
        wallet.Mnemonic = mnemonic
        wallet.Passphrase = passphrase

        wallet.Entropy = hex.EncodeToString(entropy)
        return wallet, nil</span>
}

func (hd *HDWallet) copy() *HDWallet <span class="cov8" title="1">{
        return &amp;HDWallet{
                RootXprivKey: hd.RootXprivKey,
                XPrivKey:     hd.XPrivKey,
                Path:         hd.Path,
                Seed:         hd.Seed,
                Mnemonic:     hd.Mnemonic,
                Passphrase:   hd.Passphrase,
                Entropy:      hd.Entropy,
        }
}</span>

/*
*

        DerivePath derives a new HDWallet from the current wallet based on
        the path.

        Params:
                path (string): The derivation path in the format "m/".

        Returns:
                *HDWallet: A new HDWallet derived based on the path.
                error: An error if the derived path fails.
*/
func (hd *HDWallet) DerivePath(path string) (*HDWallet, error) <span class="cov8" title="1">{
        if path[:2] != "m/" </span><span class="cov8" title="1">{
                return nil, errors.New("invalid path")
        }</span>
        <span class="cov8" title="1">derived_wallet := hd.copy()
        for index := range strings.SplitSeq(strings.TrimLeft(path, "m/"), "/") </span><span class="cov8" title="1">{
                if strings.HasSuffix(index, "'") </span><span class="cov8" title="1">{
                        ind_val, err := strconv.ParseUint(
                                string(index[:len(index)-1]),
                                10,
                                32,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">derived_wallet = derived_wallet.Derive(
                                uint32(ind_val), true,
                        )</span>
                } else<span class="cov8" title="1"> {
                        ind_val, err := strconv.ParseUint(index, 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">derived_wallet = derived_wallet.Derive(
                                uint32(ind_val), false,
                        )</span>
                }
        }
        <span class="cov8" title="1">return derived_wallet, nil</span>
}

/*
*

        Derive function derives a new HDWallet from the current wallet
        based on an index and a flag.

        Params:
                index (uint32): The index for derivation.


                hardened (bool): A flag indicating whether to perform a hardened derivation.

        Returns:
                *HDWallet: A new HDWallet derived based on the index and hardening flag.
*/
func (hd *HDWallet) Derive(index uint32, hardened bool) *HDWallet <span class="cov8" title="1">{
        if hardened </span><span class="cov8" title="1">{
                index += 1 &lt;&lt; 31
        }</span>
        <span class="cov8" title="1">derived_xprivkey := hd.XPrivKey.Derive(index)
        return &amp;HDWallet{
                RootXprivKey: hd.RootXprivKey,
                XPrivKey:     derived_xprivkey,
                Path:         hd.Path + "/" + strconv.FormatUint(uint64(index), 10),
                Seed:         hd.Seed,
                Mnemonic:     hd.Mnemonic,
                Passphrase:   hd.Passphrase,
                Entropy:      hd.Entropy,
        }</span>

}

/*
*

        GenerateMnemonic function generate a random mnemonic.

        Returns:
                string: A random mnemonic phrase.
                error: An error if the generation of mnemonic fails.
*/
func GenerateMnemonic() (string, error) <span class="cov8" title="1">{
        entropy, err := bip39.NewEntropy(256)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">mnemo, err := bip39.NewMnemonic(entropy)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return mnemo, nil</span>

}

/*
*

        IsMnemonic checks if a given mnemonic pgrase is valid.

        Params:
                mnemonic (string): The mnemonic phrase to validate.

        Returns:
                bool: true if the mnemonic is valid, false otherwise.
*/
func IsMnemonic(mnemonic string) bool <span class="cov8" title="1">{
        return bip39.IsMnemonicValid(mnemonic)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package Key

import (
        "crypto/ed25519"
        "encoding/hex"
        "fmt"

        "github.com/Salvionied/apollo/crypto/bip32"
        "github.com/Salvionied/apollo/serialization"

        "github.com/fxamacker/cbor/v2"
        "golang.org/x/crypto/blake2b"
)

type SigningKey struct {
        Payload []byte
}

/*
*

        Sign function signs a message using the provided key and returns
        the signature.

        Params:
                message ([]byte): The message to sign.


                sk ([]byte): The signing key, which can be either an extended or an ed25519 private key.

        Returns:
                []byte: The signature of the message.
                error: An error if the signing fails.
*/
func Sign(message []byte, sk []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(sk) != ed25519.PrivateKeySize </span><span class="cov0" title="0">{
                sk, err := bip32.NewXPrv(sk)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(
                                "error creating signing key from bytes, %w",
                                err,
                        )
                }</span>
                <span class="cov0" title="0">signature := sk.Sign(message)
                return signature, nil</span>

        }
        <span class="cov8" title="1">res := ed25519.Sign(sk, message)
        return res, nil</span>
}

/*
*

        Sign function signs a data byte slice using
        the signing key and the returns the signature.

        Params:
                data ([]byte): The data to sign.

        Returns:
                []byte: The signature of the data.
                error: An error if the signing fails.
*/
func (sk SigningKey) Sign(data []byte) ([]byte, error) <span class="cov8" title="1">{
        pk := sk.Payload
        signature, err := Sign(data, pk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return signature, nil</span>
}

type VerificationKey struct {
        Payload []byte
}

/*
*

        UnmarshalCBOR function unmarshals data into a VerificationKey instance.

        Params:
                data ([]byte): The CBOR data to unmarshal.

        Returns:
                error: An error if unmarshaling fails, nil otherwise.
*/
func (vk *VerificationKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        final_data := make([]byte, 0)
        err := cbor.Unmarshal(data, &amp;final_data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">vk.Payload = final_data
        return nil</span>
}

/*
*

        MarshalCBOR marshals the VerificationKey instance into CBOR data.

        Returns:


        ([]byte, error): The CBOR-encoded data and error if marshaling fails, nil otherwise.
*/
func (vk *VerificationKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal(vk.Payload)
}</span>

/*
*

        VerificationKeyFromCbor creates a VerificationKey
        instance from a CBOR-encoded string.

        Params:
                cbor_string (string): The CBOR-encoded string.

        Returns:
                (*VerificationKey, error): A VerificationKey instance and an error


        if decoding or unmarshaling fails, nil otherwise.
*/
func VerificationKeyFromCbor(cbor_string string) (*VerificationKey, error) <span class="cov8" title="1">{
        vkey := new(VerificationKey)
        value, err := hex.DecodeString(cbor_string)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = cbor.Unmarshal(value, vkey)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return vkey, nil</span>
}

/*
*

        Hash computes the has of the VerificationKey and returns it as
        public key.

        Returns:
                (serialization.PubKeyHash, error): The computed hash and an error
                                                                                        if computation fails, nil otherwise.
*/
func (vk VerificationKey) Hash() (serialization.PubKeyHash, error) <span class="cov8" title="1">{
        KeyHash, err := Blake224Hash(vk.Payload, 28)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.PubKeyHash{}, err
        }</span>
        <span class="cov8" title="1">r := serialization.PubKeyHash{}
        copy(r[:], KeyHash)
        return r, nil</span>
}

type PaymentKeyPair struct {
        VerificationKey VerificationKey
        SigningKey      SigningKey
}

/*
*

        PaymentKeyPairGenerate generates a PaymentKey pair with a randomly
        generated key pair.

        Returns:
                PaymentKeyPair: A newly generated PaymentKeyPair.
                error: An error if the payment fails.
*/
func PaymentKeyPairGenerate() (*PaymentKeyPair, error) <span class="cov8" title="1">{
        publicKey, privateKey, err := ed25519.GenerateKey(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;PaymentKeyPair{
                VerificationKey{publicKey},
                SigningKey{privateKey},
        }, nil</span>
}

type PaymentSigningKey SigningKey
type PaymentVerificationKey VerificationKey

/*
*

        Blake224Hash computes the Blake2b-224 hash of the provided byte slice.

        Params:
                b ([]byte): The input byte slice to hash.
                len (int): The length of the hash.

        Returns:
                ([]byte, error): The computed hash and an error if computation fails,
                                                 nil otherwise.
*/
func Blake224Hash(b []byte, len int) ([]byte, error) <span class="cov8" title="1">{
        hash, err := blake2b.New(len, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = hash.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return hash.Sum(nil), err</span>
}

func SigningKeyFromHexString(hexString string) (*SigningKey, error) <span class="cov8" title="1">{
        skey := new(SigningKey)
        value, err := hex.DecodeString(hexString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">skey.Payload = value
        return skey, nil</span>
}

func VerificationKeyFromHexString(hexString string) (*VerificationKey, error) <span class="cov8" title="1">{
        vkey := new(VerificationKey)
        value, err := hex.DecodeString(hexString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">vkey.Payload = value
        return vkey, nil</span>
}

func (sk SigningKey) ToHexString() string <span class="cov8" title="1">{
        return hex.EncodeToString(sk.Payload)
}</span>

func (vk VerificationKey) ToHexString() string <span class="cov8" title="1">{
        return hex.EncodeToString(vk.Payload)
}</span>

func (sk *SigningKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        return cbor.Marshal(sk.Payload)
}</span>

func (sk *SigningKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        final_data := make([]byte, 0)
        err := cbor.Unmarshal(data, &amp;final_data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">sk.Payload = final_data
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package Metadata

import (
        "maps"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/NativeScript"

        "github.com/fxamacker/cbor/v2"
)

type MinimalMetadata map[string]any

type PoliciesMetadata map[string]MinimalMetadata

type TagMetadata map[string]any

type Metadata map[int]any

type ShelleyMaryMetadata struct {
        _             struct{}                    `cbor:",toarray,omitempty"`
        Metadata      Metadata                    `cbor:",omitempty"`
        NativeScripts []NativeScript.NativeScript `cbor:",omitempty"`
}

/*
*

        MarshalCBOR marshals a ShelleyMaryMetadata instance into CBOR-encoded data.

        Returns:
                ([]byte, error): The CBOR-encoded data and an error if marshaling fails,
                                                 nil otherwise.
*/
func (smm *ShelleyMaryMetadata) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        enc, _ := cbor.EncOptions{Sort: cbor.SortLengthFirst}.EncMode()
        if len(smm.NativeScripts) &gt; 0 </span><span class="cov0" title="0">{
                return enc.Marshal(smm)
        }</span> else<span class="cov8" title="1"> {
                return enc.Marshal(smm.Metadata)
        }</span>
}

type AlonzoMetadata struct {
        Metadata      Metadata                    `cbor:"0,keyasint,omitempty"`
        NativeScripts []NativeScript.NativeScript `cbor:"1,keyasint,omitempty"`
        PlutusScripts []uint8                     `cbor:"2,keyasint,omitempty"`
}

type AuxiliaryData struct {
        _basicMeta   Metadata
        _ShelleyMeta ShelleyMaryMetadata
        _AlonzoMeta  AlonzoMetadata
}

/*
*

        SetBasicMetadata sets the basic metadata for the AuxiliaryData.
*/
func (ad *AuxiliaryData) SetBasicMetadata(value Metadata) <span class="cov8" title="1">{
        ad._basicMeta = value
}</span>

/*
*

        SetAlonzoMetadata sets the Alonzo metadata for the AuxiliaryData.
*/
func (ad *AuxiliaryData) SetAlonzoMetadata(value AlonzoMetadata) <span class="cov8" title="1">{
        ad._AlonzoMeta = value
}</span>

/*
*

        SetShelleyMetadata sets the Shelley metadata for the AuxiliaryData.
*/
func (ad *AuxiliaryData) SetShelleyMetadata(value ShelleyMaryMetadata) <span class="cov8" title="1">{
        if ad._ShelleyMeta.Metadata == nil </span><span class="cov8" title="1">{
                ad._ShelleyMeta = value
        }</span> else<span class="cov0" title="0"> {
                currentMetadata := ad._ShelleyMeta.Metadata
                maps.Copy(currentMetadata, value.Metadata)

        }</span>

}

/*
*

        Hash computes computes the has of the AuxiliaryData.

        Returns:
                []byte: The computed hash or nil if all metadata fileds are empty.
*/
func (ad *AuxiliaryData) Hash() []byte <span class="cov8" title="1">{
        if len(ad._basicMeta) != 0 || len(ad._ShelleyMeta.Metadata) != 0 ||
                len(ad._AlonzoMeta.Metadata) != 0 </span><span class="cov8" title="1">{
                marshaled, _ := cbor.Marshal(ad)
                hash, err := serialization.Blake2bHash(marshaled)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return hash</span>
        } else<span class="cov0" title="0"> {
                return nil
        }</span>
}

/*
*

        UnmarshalCBOR deserializes the AuxiliaryData from a CBOR-encoded byte slice.

        Params:
                value []byte: The CBOR-encoded data to deserialize.

        Returns:
                error: An error if deserialization fails.
*/
func (ad *AuxiliaryData) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        err_shelley := cbor.Unmarshal(value, &amp;ad._ShelleyMeta)
        if err_shelley != nil </span><span class="cov8" title="1">{
                err_basic_meta := cbor.Unmarshal(value, &amp;ad._basicMeta)
                if err_basic_meta != nil </span><span class="cov8" title="1">{
                        return err_basic_meta
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

        MarshalCBOR serializes the AUxiliaryData to a CBOR byte slice.

        Returns:
                []byte: The CBOR-serialized AuxiliaryData.
                error: An error if serialization fails.
*/
func (ad *AuxiliaryData) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        enc, _ := cbor.EncOptions{Sort: cbor.SortLengthFirst}.EncMode()
        if len(ad._basicMeta) != 0 </span><span class="cov8" title="1">{
                return enc.Marshal(ad._basicMeta)
        }</span>
        <span class="cov8" title="1">if len(ad._AlonzoMeta.Metadata) != 0 ||
                len(ad._AlonzoMeta.NativeScripts) != 0 ||
                len(ad._AlonzoMeta.PlutusScripts) != 0 </span><span class="cov8" title="1">{
                return enc.Marshal(ad._AlonzoMeta)
        }</span>
        <span class="cov8" title="1">if len(ad._ShelleyMeta.Metadata) == 0 &amp;&amp;
                len(ad._ShelleyMeta.NativeScripts) == 0 </span><span class="cov8" title="1">{
                return enc.Marshal(nil)
        }</span>
        <span class="cov8" title="1">return enc.Marshal(ad._ShelleyMeta)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package MultiAsset

import (
        "reflect"

        "github.com/Salvionied/apollo/serialization/Asset"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/Policy"
)

type MultiAsset[V int64 | uint64] map[Policy.PolicyId]Asset.Asset[V]

/*
*

        GetByPolicyAndId returns the asset amount given a policy and asset name.

        Params:
                pol Policy.PolicyId: The policy ID.
                asset_name AssetName.AssetName: The asset name.

        Returns:
                V: The asset amount.
*/
func (ma MultiAsset[V]) GetByPolicyAndId(
        pol Policy.PolicyId,
        asset_name AssetName.AssetName,
) V <span class="cov8" title="1">{
        for policy, asset := range ma </span><span class="cov8" title="1">{

                if policy.String() == pol.String() </span><span class="cov8" title="1">{
                        for assetName, amount := range asset </span><span class="cov8" title="1">{
                                if assetName.String() == asset_name.String() </span><span class="cov8" title="1">{
                                        return amount
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return 0</span>
}

/*
*

        RemoveZeroAssets removes assets with a zero amount from the MultiAsset.

        Returns:
                MultiAsset[V]: A MultiAsset with zero-amount assets removed.
*/
func (ma MultiAsset[V]) RemoveZeroAssets() MultiAsset[V] <span class="cov8" title="1">{
        result := make(MultiAsset[V])
        for policy, asset := range ma </span><span class="cov8" title="1">{
                for assetName, amount := range asset </span><span class="cov8" title="1">{
                        if amount &gt; 0 </span><span class="cov8" title="1">{
                                _, ok := result[policy]
                                if ok </span><span class="cov0" title="0">{
                                        result[policy][assetName] = amount
                                }</span> else<span class="cov8" title="1"> {
                                        result[policy] = Asset.Asset[V]{assetName: amount}
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return result</span>
}

/*
*

        Clone creates a deep copy of the MultiAsset.

        Returns:
                MultiAsset[V]: A copy of the MultiAsset.
*/
func (ma MultiAsset[V]) Clone() MultiAsset[V] <span class="cov8" title="1">{
        result := make(MultiAsset[V])
        for policy, asset := range ma </span><span class="cov8" title="1">{
                result[policy] = asset.Clone()
        }</span>
        <span class="cov8" title="1">return result</span>
}

/*
*

        Equal checks if two MultiAsset instances are equal.

        Params:
                other MultiAsset[V]: The other MultiAsset to compare.

        Returns:
                bool: True if the two MultiAsset instances are equal, false otherwise.
*/
func (ma MultiAsset[V]) Equal(other MultiAsset[V]) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(ma, other)
}</span>

/*
*

        Less checks if the current MultiAsset is less
        than another MultiAsset.

        Params:
                other MultiAsset[V]: The other MultiAsset to compare.

        Returns:


        bool: True if the current MultiAsset is less than the other, false otherwise.
*/
func (ma MultiAsset[V]) Less(other MultiAsset[V]) bool <span class="cov8" title="1">{
        for policy, asset := range ma </span><span class="cov8" title="1">{
                otherAsset, ok := other[policy]
                if !ok || !asset.Less(otherAsset) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>

}

/*
*

        Greater checks if the current MultiAsset is greater
        than another MultiAsset.

        Params:
                other MultiAsset[V]: The other MultiAsset to compare.

        Returns:


        bool: True if the current MultiAsset is greater than the other, false otherwise.
*/
func (ma MultiAsset[V]) Greater(other MultiAsset[V]) bool <span class="cov8" title="1">{
        for policy, asset := range ma </span><span class="cov8" title="1">{
                otherAsset, ok := other[policy]
                if ok &amp;&amp; !asset.Greater(otherAsset) &amp;&amp; !asset.Equal(otherAsset) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

/*
*

        Sub subtracts another MultiAsset from the current MultiAsset.

        Params:
                other MultiAsset[V]: The MultiAsset to subtract.

        Returns:
                MultiAsset[V]: The result of the subtraction.
*/
func (ma MultiAsset[V]) Sub(other MultiAsset[V]) MultiAsset[V] <span class="cov8" title="1">{
        result := ma.Clone()
        for policy, asset := range other </span><span class="cov8" title="1">{
                _, ok := result[policy]
                if ok </span><span class="cov8" title="1">{
                        result[policy] = result[policy].Sub(asset)
                }</span> else<span class="cov0" title="0"> {
                        result[policy] = asset.Inverted()
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

/*
*

        Add adds another MultiAsset to the current MultiAsset.

        Params:
                other MultiAsset[V]: The MultiAsset to add.

        Returns:
                MultiAsset[V]: The result of the addition.
*/
func (ma MultiAsset[V]) Add(other MultiAsset[V]) MultiAsset[V] <span class="cov8" title="1">{
        res := ma.Clone()
        for policy, asset := range other </span><span class="cov8" title="1">{
                _, ok := res[policy]
                if ok </span><span class="cov8" title="1">{
                        res[policy] = res[policy].Add(asset)
                }</span> else<span class="cov8" title="1"> {
                        res[policy] = asset
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
*

        Filter returns a MultiAsset containing only the assets that
        satisfy the filter function.

        Params:


                f func(policy Policy.PolicyId, asset Asset.Asset[V]) bool: The filter function.

        Returns:
                MultiAsset[V]: The filtered MultiAsset.
*/
func (ma MultiAsset[V]) Filter(
        f func(policy Policy.PolicyId, asset AssetName.AssetName, quantity V) bool,
) MultiAsset[V] <span class="cov8" title="1">{
        result := make(MultiAsset[V])
        for policy, asset := range ma </span><span class="cov8" title="1">{
                for assetName, amount := range asset </span><span class="cov8" title="1">{
                        if f(policy, assetName, amount) </span><span class="cov8" title="1">{
                                _, ok := result[policy]
                                if ok </span><span class="cov0" title="0">{
                                        result[policy][assetName] = amount
                                }</span> else<span class="cov8" title="1"> {
                                        result[policy] = Asset.Asset[V]{assetName: amount}
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package NativeScript

import (
        "github.com/Salvionied/apollo/serialization"

        "github.com/fxamacker/cbor/v2"
        "golang.org/x/crypto/blake2b"
)

type ScriptTag int

const (
        ScriptPubKey ScriptTag = iota
        ScriptAll
        ScriptAny
        ScriptNofK
        InvalidBefore
        InvalidHereafter
)

func NewScriptPubKey(keyHash []byte) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptPubKey, KeyHash: keyHash}
}</span>

func NewScriptAll(nativeScripts []NativeScript) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptAll, NativeScripts: nativeScripts}
}</span>

func NewScriptAny(nativeScripts []NativeScript) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptAny, NativeScripts: nativeScripts}
}</span>

func NewScriptNofK(nativeScripts []NativeScript, noK int) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: ScriptNofK, NativeScripts: nativeScripts, NoK: noK}
}</span>

func NewInvalidBefore(before int64) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: InvalidBefore, Before: before}
}</span>

func NewInvalidHereafter(after int64) NativeScript <span class="cov8" title="1">{
        return NativeScript{Tag: InvalidHereafter, After: after}
}</span>

type NativeScript struct {
        Tag           ScriptTag
        KeyHash       []byte
        NativeScripts []NativeScript
        NoK           int
        Before        int64
        After         int64
}

type SerialScripts struct {
        _             struct{} `cbor:",toarray"`
        Tag           ScriptTag
        NativeScripts []NativeScript
}

type SerialNok struct {
        _             struct{} `cbor:",toarray"`
        Tag           ScriptTag
        NoK           int
        NativeScripts []NativeScript
}

type SerialInt struct {
        _     struct{} `cbor:",toarray"`
        Tag   ScriptTag
        Value int64
}
type SerialHash struct {
        _     struct{} `cbor:",toarray"`
        Tag   ScriptTag
        Value []byte
}

/*
*

        Hash computes the script hash for the NativeScript.

        Returns:
                serialization.ScriptHash: The computed script hash.
                error: An error if the hashing fails.
*/
func (ns NativeScript) Hash() (serialization.ScriptHash, error) <span class="cov8" title="1">{
        finalbytes := []byte{0}
        bytes, err := cbor.Marshal(ns)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov8" title="1">finalbytes = append(finalbytes, bytes...)
        hash, err := blake2b.New(28, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov8" title="1">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov8" title="1">ret := serialization.ScriptHash{}
        copy(ret[:], hash.Sum(nil))
        return ret, nil</span>
}

/*
*

        UnmarshalCBOR decodes the CBOR-encoded data and populates
        the NativeScript fields.

        Params:
                value []byte: The CBOR-encoded data to encode.

        Returns:
                error: An error if decoding fails, nil otherwise.
*/
func (ns *NativeScript) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var tmp = make([]any, 0)
        err := cbor.Unmarshal(value, &amp;tmp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ok, _ := tmp[0].(uint64)
        switch int(ok) </span>{
        case 0:<span class="cov8" title="1">
                tmp := new(SerialHash)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.KeyHash = tmp.Value
                ns.Tag = tmp.Tag
                return err</span>
        case 1:<span class="cov8" title="1">
                tmp := new(SerialScripts)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.Tag = tmp.Tag
                ns.NativeScripts = tmp.NativeScripts
                return err</span>
        case 2:<span class="cov8" title="1">
                tmp := new(SerialScripts)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.Tag = tmp.Tag
                ns.NativeScripts = tmp.NativeScripts
                return err</span>
        case 3:<span class="cov8" title="1">
                tmp := new(SerialNok)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.NativeScripts = tmp.NativeScripts
                ns.Tag = tmp.Tag
                ns.NoK = tmp.NoK
                return err</span>
        case 4:<span class="cov8" title="1">
                tmp := new(SerialInt)
                err := cbor.Unmarshal(value, &amp;tmp)

                ns.Tag = tmp.Tag
                ns.Before = tmp.Value
                return err</span>
        case 5:<span class="cov8" title="1">
                tmp := new(SerialInt)
                err := cbor.Unmarshal(value, &amp;tmp)
                ns.Tag = tmp.Tag
                ns.After = tmp.Value
                return err</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

/*
*

        MarshalCBOR encodes the NativeScript into CBOR format.

        Returns:
                []uint8: The CBOR-encoded data.
                error: An error if encoding fails, nil otherwise.
*/
func (ns *NativeScript) MarshalCBOR() ([]uint8, error) <span class="cov8" title="1">{
        switch ns.Tag </span>{
        case 0:<span class="cov8" title="1">
                return cbor.Marshal(SerialHash{Tag: ns.Tag, Value: ns.KeyHash})</span>
        case 1:<span class="cov8" title="1">
                return cbor.Marshal(
                        SerialScripts{Tag: ns.Tag, NativeScripts: ns.NativeScripts},
                )</span>
        case 2:<span class="cov8" title="1">
                return cbor.Marshal(
                        SerialScripts{Tag: ns.Tag, NativeScripts: ns.NativeScripts},
                )</span>
        case 3:<span class="cov8" title="1">
                return cbor.Marshal(
                        SerialNok{
                                Tag:           ns.Tag,
                                NoK:           ns.NoK,
                                NativeScripts: ns.NativeScripts,
                        },
                )</span>
        case 4:<span class="cov8" title="1">
                return cbor.Marshal(SerialInt{Tag: ns.Tag, Value: ns.Before})</span>
        case 5:<span class="cov8" title="1">
                return cbor.Marshal(SerialInt{Tag: ns.Tag, Value: ns.After})</span>

        default:<span class="cov0" title="0">
                return make([]uint8, 0), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package PlutusData

import (
        "bytes"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "math/big"
        "reflect"
        "sort"
        "strconv"
        "strings"

        "github.com/Salvionied/apollo/constants"
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"

        "github.com/fxamacker/cbor/v2"

        "golang.org/x/crypto/blake2b"
)

// TODO: remove me
// type _Script struct {
//         _      struct{} `cbor:",toarray"`
//         Script []byte
// }

type DatumType byte

const (
        DatumTypeHash   DatumType = 0
        DatumTypeInline DatumType = 1
)

type DatumOption struct {
        _         struct{} `cbor:",toarray"`
        DatumType DatumType
        Hash      []byte
        Inline    *PlutusData
}

func (d *DatumOption) UnmarshalCBOR(b []byte) error <span class="cov0" title="0">{
        var cborDatumOption struct {
                _         struct{} `cbor:",toarray"`
                DatumType DatumType
                Content   cbor.RawMessage
        }
        err := cbor.Unmarshal(b, &amp;cborDatumOption)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("DatumOption: UnmarshalCBOR: %v", err)

        }</span>
        <span class="cov0" title="0">switch cborDatumOption.DatumType </span>{
        case DatumTypeInline:<span class="cov0" title="0">
                var cborDatumInline PlutusData
                errInline := cbor.Unmarshal(cborDatumOption.Content, &amp;cborDatumInline)
                if errInline != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("DatumOption: UnmarshalCBOR: %v", errInline)
                }</span>
                <span class="cov0" title="0">if cborDatumInline.TagNr != 24 </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "found DatumTypeInline but Tag was not 24: %v",
                                cborDatumInline.TagNr,
                        )
                }</span>
                <span class="cov0" title="0">taggedBytes, valid := cborDatumInline.Value.([]byte)
                if !valid </span><span class="cov0" title="0">{
                        return errors.New(
                                "DatumOption: UnmarshalCBOR: found tag 24 but there wasn't a byte array",
                        )
                }</span>
                <span class="cov0" title="0">var inline PlutusData
                err = cbor.Unmarshal(taggedBytes, &amp;inline)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">d.DatumType = DatumTypeInline
                d.Inline = &amp;inline
                return nil</span>
        case DatumTypeHash:<span class="cov0" title="0">
                var cborDatumHash []byte
                errHash := cbor.Unmarshal(cborDatumOption.Content, &amp;cborDatumHash)
                if errHash != nil </span><span class="cov0" title="0">{
                        return errHash
                }</span>
                <span class="cov0" title="0">d.DatumType = DatumTypeHash
                d.Hash = cborDatumHash
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown tag: %v", cborDatumOption.DatumType)</span>
        }

}

func DatumOptionHash(hash []byte) DatumOption <span class="cov0" title="0">{
        return DatumOption{
                DatumType: DatumTypeHash,
                Hash:      hash,
        }
}</span>

func DatumOptionInline(pd *PlutusData) DatumOption <span class="cov0" title="0">{
        return DatumOption{
                DatumType: DatumTypeInline,
                Inline:    pd,
        }
}</span>

func (d DatumOption) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        var format struct {
                _       struct{} `cbor:",toarray"`
                Tag     DatumType
                Content *PlutusData
        }
        switch d.DatumType </span>{
        case DatumTypeHash:<span class="cov0" title="0">
                format.Tag = DatumTypeHash
                format.Content = &amp;PlutusData{
                        PlutusDataType: PlutusBytes,
                        TagNr:          0,
                        Value:          d.Hash,
                }</span>
        case DatumTypeInline:<span class="cov0" title="0">
                format.Tag = DatumTypeInline
                bytes, err := cbor.Marshal(d.Inline)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal inline datum: %w", err)
                }</span>
                <span class="cov0" title="0">format.Content = &amp;PlutusData{
                        PlutusDataType: PlutusBytes,
                        TagNr:          24,
                        Value:          bytes,
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid DatumOption: %v", d)</span>
        }
        <span class="cov0" title="0">return cbor.Marshal(format)</span>
}

type ScriptRef []byte

func (sr ScriptRef) Len() int <span class="cov0" title="0">{
        return len(sr)
}</span>

type CostModels map[serialization.CustomBytes]CM

type CM map[string]int

/*
*

        MarshalCBOR encodes the CM into a CBOR-encoded byte slice, in which
        it serializes the map key alphabetically and encodes the respective values.

        Returns:
                []byte: The CBOR-encoded byte slice.
                error: An error if marshaling fails.
*/
func (cm CM) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        res := make([]int, 0)
        mk := make([]string, 0)
        for k := range cm </span><span class="cov0" title="0">{
                mk = append(mk, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(mk)
        for _, v := range mk </span><span class="cov0" title="0">{
                res = append(res, cm[v])
        }</span>
        <span class="cov0" title="0">partial, _ := cbor.Marshal(res)
        partial[1] = 0x9f
        partial = append(partial, 0xff)
        return cbor.Marshal(partial[1:])</span>
}

var PLUTUSV1COSTMODEL = CM{
        "addInteger-cpu-arguments-intercept":                       100788,
        "addInteger-cpu-arguments-slope":                           420,
        "addInteger-memory-arguments-intercept":                    1,
        "addInteger-memory-arguments-slope":                        1,
        "appendByteString-cpu-arguments-intercept":                 1000,
        "appendByteString-cpu-arguments-slope":                     173,
        "appendByteString-memory-arguments-intercept":              0,
        "appendByteString-memory-arguments-slope":                  1,
        "appendString-cpu-arguments-intercept":                     1000,
        "appendString-cpu-arguments-slope":                         59957,
        "appendString-memory-arguments-intercept":                  4,
        "appendString-memory-arguments-slope":                      1,
        "bData-cpu-arguments":                                      11183,
        "bData-memory-arguments":                                   32,
        "blake2b_256-cpu-arguments-intercept":                      201305,
        "blake2b_256-cpu-arguments-slope":                          8356,
        "blake2b_256-memory-arguments":                             4,
        "cekApplyCost-exBudgetCPU":                                 16000,
        "cekApplyCost-exBudgetMemory":                              100,
        "cekBuiltinCost-exBudgetCPU":                               16000,
        "cekBuiltinCost-exBudgetMemory":                            100,
        "cekConstCost-exBudgetCPU":                                 16000,
        "cekConstCost-exBudgetMemory":                              100,
        "cekDelayCost-exBudgetCPU":                                 16000,
        "cekDelayCost-exBudgetMemory":                              100,
        "cekForceCost-exBudgetCPU":                                 16000,
        "cekForceCost-exBudgetMemory":                              100,
        "cekLamCost-exBudgetCPU":                                   16000,
        "cekLamCost-exBudgetMemory":                                100,
        "cekStartupCost-exBudgetCPU":                               100,
        "cekStartupCost-exBudgetMemory":                            100,
        "cekVarCost-exBudgetCPU":                                   16000,
        "cekVarCost-exBudgetMemory":                                100,
        "chooseData-cpu-arguments":                                 94375,
        "chooseData-memory-arguments":                              32,
        "chooseList-cpu-arguments":                                 132994,
        "chooseList-memory-arguments":                              32,
        "chooseUnit-cpu-arguments":                                 61462,
        "chooseUnit-memory-arguments":                              4,
        "consByteString-cpu-arguments-intercept":                   72010,
        "consByteString-cpu-arguments-slope":                       178,
        "consByteString-memory-arguments-intercept":                0,
        "consByteString-memory-arguments-slope":                    1,
        "constrData-cpu-arguments":                                 22151,
        "constrData-memory-arguments":                              32,
        "decodeUtf8-cpu-arguments-intercept":                       91189,
        "decodeUtf8-cpu-arguments-slope":                           769,
        "decodeUtf8-memory-arguments-intercept":                    4,
        "decodeUtf8-memory-arguments-slope":                        2,
        "divideInteger-cpu-arguments-constant":                     85848,
        "divideInteger-cpu-arguments-model-arguments-intercept":    228465,
        "divideInteger-cpu-arguments-model-arguments-slope":        122,
        "divideInteger-memory-arguments-intercept":                 0,
        "divideInteger-memory-arguments-minimum":                   1,
        "divideInteger-memory-arguments-slope":                     1,
        "encodeUtf8-cpu-arguments-intercept":                       1000,
        "encodeUtf8-cpu-arguments-slope":                           42921,
        "encodeUtf8-memory-arguments-intercept":                    4,
        "encodeUtf8-memory-arguments-slope":                        2,
        "equalsByteString-cpu-arguments-constant":                  24548,
        "equalsByteString-cpu-arguments-intercept":                 29498,
        "equalsByteString-cpu-arguments-slope":                     38,
        "equalsByteString-memory-arguments":                        1,
        "equalsData-cpu-arguments-intercept":                       898148,
        "equalsData-cpu-arguments-slope":                           27279,
        "equalsData-memory-arguments":                              1,
        "equalsInteger-cpu-arguments-intercept":                    51775,
        "equalsInteger-cpu-arguments-slope":                        558,
        "equalsInteger-memory-arguments":                           1,
        "equalsString-cpu-arguments-constant":                      39184,
        "equalsString-cpu-arguments-intercept":                     1000,
        "equalsString-cpu-arguments-slope":                         60594,
        "equalsString-memory-arguments":                            1,
        "fstPair-cpu-arguments":                                    141895,
        "fstPair-memory-arguments":                                 32,
        "headList-cpu-arguments":                                   83150,
        "headList-memory-arguments":                                32,
        "iData-cpu-arguments":                                      15299,
        "iData-memory-arguments":                                   32,
        "ifThenElse-cpu-arguments":                                 76049,
        "ifThenElse-memory-arguments":                              1,
        "indexByteString-cpu-arguments":                            13169,
        "indexByteString-memory-arguments":                         4,
        "lengthOfByteString-cpu-arguments":                         22100,
        "lengthOfByteString-memory-arguments":                      10,
        "lessThanByteString-cpu-arguments-intercept":               28999,
        "lessThanByteString-cpu-arguments-slope":                   74,
        "lessThanByteString-memory-arguments":                      1,
        "lessThanEqualsByteString-cpu-arguments-intercept":         28999,
        "lessThanEqualsByteString-cpu-arguments-slope":             74,
        "lessThanEqualsByteString-memory-arguments":                1,
        "lessThanEqualsInteger-cpu-arguments-intercept":            43285,
        "lessThanEqualsInteger-cpu-arguments-slope":                552,
        "lessThanEqualsInteger-memory-arguments":                   1,
        "lessThanInteger-cpu-arguments-intercept":                  44749,
        "lessThanInteger-cpu-arguments-slope":                      541,
        "lessThanInteger-memory-arguments":                         1,
        "listData-cpu-arguments":                                   33852,
        "listData-memory-arguments":                                32,
        "mapData-cpu-arguments":                                    68246,
        "mapData-memory-arguments":                                 32,
        "mkCons-cpu-arguments":                                     72362,
        "mkCons-memory-arguments":                                  32,
        "mkNilData-cpu-arguments":                                  7243,
        "mkNilData-memory-arguments":                               32,
        "mkNilPairData-cpu-arguments":                              7391,
        "mkNilPairData-memory-arguments":                           32,
        "mkPairData-cpu-arguments":                                 11546,
        "mkPairData-memory-arguments":                              32,
        "modInteger-cpu-arguments-constant":                        85848,
        "modInteger-cpu-arguments-model-arguments-intercept":       228465,
        "modInteger-cpu-arguments-model-arguments-slope":           122,
        "modInteger-memory-arguments-intercept":                    0,
        "modInteger-memory-arguments-minimum":                      1,
        "modInteger-memory-arguments-slope":                        1,
        "multiplyInteger-cpu-arguments-intercept":                  90434,
        "multiplyInteger-cpu-arguments-slope":                      519,
        "multiplyInteger-memory-arguments-intercept":               0,
        "multiplyInteger-memory-arguments-slope":                   1,
        "nullList-cpu-arguments":                                   74433,
        "nullList-memory-arguments":                                32,
        "quotientInteger-cpu-arguments-constant":                   85848,
        "quotientInteger-cpu-arguments-model-arguments-intercept":  228465,
        "quotientInteger-cpu-arguments-model-arguments-slope":      122,
        "quotientInteger-memory-arguments-intercept":               0,
        "quotientInteger-memory-arguments-minimum":                 1,
        "quotientInteger-memory-arguments-slope":                   1,
        "remainderInteger-cpu-arguments-constant":                  85848,
        "remainderInteger-cpu-arguments-model-arguments-intercept": 228465,
        "remainderInteger-cpu-arguments-model-arguments-slope":     122,
        "remainderInteger-memory-arguments-intercept":              0,
        "remainderInteger-memory-arguments-minimum":                1,
        "remainderInteger-memory-arguments-slope":                  1,
        "sha2_256-cpu-arguments-intercept":                         270652,
        "sha2_256-cpu-arguments-slope":                             22588,
        "sha2_256-memory-arguments":                                4,
        "sha3_256-cpu-arguments-intercept":                         1457325,
        "sha3_256-cpu-arguments-slope":                             64566,
        "sha3_256-memory-arguments":                                4,
        "sliceByteString-cpu-arguments-intercept":                  20467,
        "sliceByteString-cpu-arguments-slope":                      1,
        "sliceByteString-memory-arguments-intercept":               4,
        "sliceByteString-memory-arguments-slope":                   0,
        "sndPair-cpu-arguments":                                    141992,
        "sndPair-memory-arguments":                                 32,
        "subtractInteger-cpu-arguments-intercept":                  100788,
        "subtractInteger-cpu-arguments-slope":                      420,
        "subtractInteger-memory-arguments-intercept":               1,
        "subtractInteger-memory-arguments-slope":                   1,
        "tailList-cpu-arguments":                                   81663,
        "tailList-memory-arguments":                                32,
        "trace-cpu-arguments":                                      59498,
        "trace-memory-arguments":                                   32,
        "unBData-cpu-arguments":                                    20142,
        "unBData-memory-arguments":                                 32,
        "unConstrData-cpu-arguments":                               24588,
        "unConstrData-memory-arguments":                            32,
        "unIData-cpu-arguments":                                    20744,
        "unIData-memory-arguments":                                 32,
        "unListData-cpu-arguments":                                 25933,
        "unListData-memory-arguments":                              32,
        "unMapData-cpu-arguments":                                  24623,
        "unMapData-memory-arguments":                               32,
        "verifyEd25519Signature-cpu-arguments-intercept":           53384111,
        "verifyEd25519Signature-cpu-arguments-slope":               14333,
        "verifyEd25519Signature-memory-arguments":                  10,
}

type CostView map[string]int

type CostModelArray []int32

func (cma CostModelArray) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        res := []int32(cma)
        return cbor.Marshal(res)
}</span>

var PLUTUSV3COSTMODEL = CostModelArray(
        []int32{
                100788,
                420,
                1,
                1,
                1000,
                173,
                0,
                1,
                1000,
                59957,
                4,
                1,
                11183,
                32,
                201305,
                8356,
                4,
                16000,
                100,
                16000,
                100,
                16000,
                100,
                16000,
                100,
                16000,
                100,
                16000,
                100,
                100,
                100,
                16000,
                100,
                94375,
                32,
                132994,
                32,
                61462,
                4,
                72010,
                178,
                0,
                1,
                22151,
                32,
                91189,
                769,
                4,
                2,
                85848,
                123203,
                7305,
                -900,
                1716,
                549,
                57,
                85848,
                0,
                1,
                1,
                1000,
                42921,
                4,
                2,
                24548,
                29498,
                38,
                1,
                898148,
                27279,
                1,
                51775,
                558,
                1,
                39184,
                1000,
                60594,
                1,
                141895,
                32,
                83150,
                32,
                15299,
                32,
                76049,
                1,
                13169,
                4,
                22100,
                10,
                28999,
                74,
                1,
                28999,
                74,
                1,
                43285,
                552,
                1,
                44749,
                541,
                1,
                33852,
                32,
                68246,
                32,
                72362,
                32,
                7243,
                32,
                7391,
                32,
                11546,
                32,
                85848,
                123203,
                7305,
                -900,
                1716,
                549,
                57,
                85848,
                0,
                1,
                90434,
                519,
                0,
                1,
                74433,
                32,
                85848,
                123203,
                7305,
                -900,
                1716,
                549,
                57,
                85848,
                0,
                1,
                1,
                85848,
                123203,
                7305,
                -900,
                1716,
                549,
                57,
                85848,
                0,
                1,
                955506,
                213312,
                0,
                2,
                270652,
                22588,
                4,
                1457325,
                64566,
                4,
                20467,
                1,
                4,
                0,
                141992,
                32,
                100788,
                420,
                1,
                1,
                81663,
                32,
                59498,
                32,
                20142,
                32,
                24588,
                32,
                20744,
                32,
                25933,
                32,
                24623,
                32,
                43053543,
                10,
                53384111,
                14333,
                10,
                43574283,
                26308,
                10,
                16000,
                100,
                16000,
                100,
                962335,
                18,
                2780678,
                6,
                442008,
                1,
                52538055,
                3756,
                18,
                267929,
                18,
                76433006,
                8868,
                18,
                52948122,
                18,
                1995836,
                36,
                3227919,
                12,
                901022,
                1,
                166917843,
                4307,
                36,
                284546,
                36,
                158221314,
                26549,
                36,
                74698472,
                36,
                333849714,
                1,
                254006273,
                72,
                2174038,
                72,
                2261318,
                64571,
                4,
                207616,
                8310,
                4,
                1293828,
                28716,
                63,
                0,
                1,
                1006041,
                43623,
                251,
                0,
                1,
                100181,
                726,
                719,
                0,
                1,
                100181,
                726,
                719,
                0,
                1,
                100181,
                726,
                719,
                0,
                1,
                107878,
                680,
                0,
                1,
                95336,
                1,
                281145,
                18848,
                0,
                1,
                180194,
                159,
                1,
                1,
                158519,
                8942,
                0,
                1,
                159378,
                8813,
                0,
                1,
                107490,
                3298,
                1,
                106057,
                655,
                1,
                1964219,
                24520,
                3,
        },
)

/*
*

        MarshalCBOR encodes the CostView into a CBOR-encoded byte slice, in which
        it serializes the map key alphabetically and encodes the respective values.

        Returns:
                []byte: The CBOR-encoded byte slice.
                error: An error if marshaling fails.
*/
func (cv CostView) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        res := make([]int, 0)
        mk := make([]string, 0)
        for k := range cv </span><span class="cov0" title="0">{
                mk = append(mk, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(mk)
        for _, v := range mk </span><span class="cov0" title="0">{
                res = append(res, cv[v])
        }</span>
        <span class="cov0" title="0">return cbor.Marshal(res)</span>

}

var PLUTUSV2COSTMODEL = CostView{
        "addInteger-cpu-arguments-intercept":                       100788,
        "addInteger-cpu-arguments-slope":                           420,
        "addInteger-memory-arguments-intercept":                    1,
        "addInteger-memory-arguments-slope":                        1,
        "appendByteString-cpu-arguments-intercept":                 1000,
        "appendByteString-cpu-arguments-slope":                     173,
        "appendByteString-memory-arguments-intercept":              0,
        "appendByteString-memory-arguments-slope":                  1,
        "appendString-cpu-arguments-intercept":                     1000,
        "appendString-cpu-arguments-slope":                         59957,
        "appendString-memory-arguments-intercept":                  4,
        "appendString-memory-arguments-slope":                      1,
        "bData-cpu-arguments":                                      11183,
        "bData-memory-arguments":                                   32,
        "blake2b_256-cpu-arguments-intercept":                      201305,
        "blake2b_256-cpu-arguments-slope":                          8356,
        "blake2b_256-memory-arguments":                             4,
        "cekApplyCost-exBudgetCPU":                                 16000,
        "cekApplyCost-exBudgetMemory":                              100,
        "cekBuiltinCost-exBudgetCPU":                               16000,
        "cekBuiltinCost-exBudgetMemory":                            100,
        "cekConstCost-exBudgetCPU":                                 16000,
        "cekConstCost-exBudgetMemory":                              100,
        "cekDelayCost-exBudgetCPU":                                 16000,
        "cekDelayCost-exBudgetMemory":                              100,
        "cekForceCost-exBudgetCPU":                                 16000,
        "cekForceCost-exBudgetMemory":                              100,
        "cekLamCost-exBudgetCPU":                                   16000,
        "cekLamCost-exBudgetMemory":                                100,
        "cekStartupCost-exBudgetCPU":                               100,
        "cekStartupCost-exBudgetMemory":                            100,
        "cekVarCost-exBudgetCPU":                                   16000,
        "cekVarCost-exBudgetMemory":                                100,
        "chooseData-cpu-arguments":                                 94375,
        "chooseData-memory-arguments":                              32,
        "chooseList-cpu-arguments":                                 132994,
        "chooseList-memory-arguments":                              32,
        "chooseUnit-cpu-arguments":                                 61462,
        "chooseUnit-memory-arguments":                              4,
        "consByteString-cpu-arguments-intercept":                   72010,
        "consByteString-cpu-arguments-slope":                       178,
        "consByteString-memory-arguments-intercept":                0,
        "consByteString-memory-arguments-slope":                    1,
        "constrData-cpu-arguments":                                 22151,
        "constrData-memory-arguments":                              32,
        "decodeUtf8-cpu-arguments-intercept":                       91189,
        "decodeUtf8-cpu-arguments-slope":                           769,
        "decodeUtf8-memory-arguments-intercept":                    4,
        "decodeUtf8-memory-arguments-slope":                        2,
        "divideInteger-cpu-arguments-constant":                     85848,
        "divideInteger-cpu-arguments-model-arguments-intercept":    228465,
        "divideInteger-cpu-arguments-model-arguments-slope":        122,
        "divideInteger-memory-arguments-intercept":                 0,
        "divideInteger-memory-arguments-minimum":                   1,
        "divideInteger-memory-arguments-slope":                     1,
        "encodeUtf8-cpu-arguments-intercept":                       1000,
        "encodeUtf8-cpu-arguments-slope":                           42921,
        "encodeUtf8-memory-arguments-intercept":                    4,
        "encodeUtf8-memory-arguments-slope":                        2,
        "equalsByteString-cpu-arguments-constant":                  24548,
        "equalsByteString-cpu-arguments-intercept":                 29498,
        "equalsByteString-cpu-arguments-slope":                     38,
        "equalsByteString-memory-arguments":                        1,
        "equalsData-cpu-arguments-intercept":                       898148,
        "equalsData-cpu-arguments-slope":                           27279,
        "equalsData-memory-arguments":                              1,
        "equalsInteger-cpu-arguments-intercept":                    51775,
        "equalsInteger-cpu-arguments-slope":                        558,
        "equalsInteger-memory-arguments":                           1,
        "equalsString-cpu-arguments-constant":                      39184,
        "equalsString-cpu-arguments-intercept":                     1000,
        "equalsString-cpu-arguments-slope":                         60594,
        "equalsString-memory-arguments":                            1,
        "fstPair-cpu-arguments":                                    141895,
        "fstPair-memory-arguments":                                 32,
        "headList-cpu-arguments":                                   83150,
        "headList-memory-arguments":                                32,
        "iData-cpu-arguments":                                      15299,
        "iData-memory-arguments":                                   32,
        "ifThenElse-cpu-arguments":                                 76049,
        "ifThenElse-memory-arguments":                              1,
        "indexByteString-cpu-arguments":                            13169,
        "indexByteString-memory-arguments":                         4,
        "lengthOfByteString-cpu-arguments":                         22100,
        "lengthOfByteString-memory-arguments":                      10,
        "lessThanByteString-cpu-arguments-intercept":               28999,
        "lessThanByteString-cpu-arguments-slope":                   74,
        "lessThanByteString-memory-arguments":                      1,
        "lessThanEqualsByteString-cpu-arguments-intercept":         28999,
        "lessThanEqualsByteString-cpu-arguments-slope":             74,
        "lessThanEqualsByteString-memory-arguments":                1,
        "lessThanEqualsInteger-cpu-arguments-intercept":            43285,
        "lessThanEqualsInteger-cpu-arguments-slope":                552,
        "lessThanEqualsInteger-memory-arguments":                   1,
        "lessThanInteger-cpu-arguments-intercept":                  44749,
        "lessThanInteger-cpu-arguments-slope":                      541,
        "lessThanInteger-memory-arguments":                         1,
        "listData-cpu-arguments":                                   33852,
        "listData-memory-arguments":                                32,
        "mapData-cpu-arguments":                                    68246,
        "mapData-memory-arguments":                                 32,
        "mkCons-cpu-arguments":                                     72362,
        "mkCons-memory-arguments":                                  32,
        "mkNilData-cpu-arguments":                                  7243,
        "mkNilData-memory-arguments":                               32,
        "mkNilPairData-cpu-arguments":                              7391,
        "mkNilPairData-memory-arguments":                           32,
        "mkPairData-cpu-arguments":                                 11546,
        "mkPairData-memory-arguments":                              32,
        "modInteger-cpu-arguments-constant":                        85848,
        "modInteger-cpu-arguments-model-arguments-intercept":       228465,
        "modInteger-cpu-arguments-model-arguments-slope":           122,
        "modInteger-memory-arguments-intercept":                    0,
        "modInteger-memory-arguments-minimum":                      1,
        "modInteger-memory-arguments-slope":                        1,
        "multiplyInteger-cpu-arguments-intercept":                  90434,
        "multiplyInteger-cpu-arguments-slope":                      519,
        "multiplyInteger-memory-arguments-intercept":               0,
        "multiplyInteger-memory-arguments-slope":                   1,
        "nullList-cpu-arguments":                                   74433,
        "nullList-memory-arguments":                                32,
        "quotientInteger-cpu-arguments-constant":                   85848,
        "quotientInteger-cpu-arguments-model-arguments-intercept":  228465,
        "quotientInteger-cpu-arguments-model-arguments-slope":      122,
        "quotientInteger-memory-arguments-intercept":               0,
        "quotientInteger-memory-arguments-minimum":                 1,
        "quotientInteger-memory-arguments-slope":                   1,
        "remainderInteger-cpu-arguments-constant":                  85848,
        "remainderInteger-cpu-arguments-model-arguments-intercept": 228465,
        "remainderInteger-cpu-arguments-model-arguments-slope":     122,
        "remainderInteger-memory-arguments-intercept":              0,
        "remainderInteger-memory-arguments-minimum":                1,
        "remainderInteger-memory-arguments-slope":                  1,
        "serialiseData-cpu-arguments-intercept":                    955506,
        "serialiseData-cpu-arguments-slope":                        213312,
        "serialiseData-memory-arguments-intercept":                 0,
        "serialiseData-memory-arguments-slope":                     2,
        "sha2_256-cpu-arguments-intercept":                         270652,
        "sha2_256-cpu-arguments-slope":                             22588,
        "sha2_256-memory-arguments":                                4,
        "sha3_256-cpu-arguments-intercept":                         1457325,
        "sha3_256-cpu-arguments-slope":                             64566,
        "sha3_256-memory-arguments":                                4,
        "sliceByteString-cpu-arguments-intercept":                  20467,
        "sliceByteString-cpu-arguments-slope":                      1,
        "sliceByteString-memory-arguments-intercept":               4,
        "sliceByteString-memory-arguments-slope":                   0,
        "sndPair-cpu-arguments":                                    141992,
        "sndPair-memory-arguments":                                 32,
        "subtractInteger-cpu-arguments-intercept":                  100788,
        "subtractInteger-cpu-arguments-slope":                      420,
        "subtractInteger-memory-arguments-intercept":               1,
        "subtractInteger-memory-arguments-slope":                   1,
        "tailList-cpu-arguments":                                   81663,
        "tailList-memory-arguments":                                32,
        "trace-cpu-arguments":                                      59498,
        "trace-memory-arguments":                                   32,
        "unBData-cpu-arguments":                                    20142,
        "unBData-memory-arguments":                                 32,
        "unConstrData-cpu-arguments":                               24588,
        "unConstrData-memory-arguments":                            32,
        "unIData-cpu-arguments":                                    20744,
        "unIData-memory-arguments":                                 32,
        "unListData-cpu-arguments":                                 25933,
        "unListData-memory-arguments":                              32,
        "unMapData-cpu-arguments":                                  24623,
        "unMapData-memory-arguments":                               32,
        "verifyEcdsaSecp256k1Signature-cpu-arguments":              43053543,
        "verifyEcdsaSecp256k1Signature-memory-arguments":           10,
        "verifyEd25519Signature-cpu-arguments-intercept":           53384111,
        "verifyEd25519Signature-cpu-arguments-slope":               14333,
        "verifyEd25519Signature-memory-arguments":                  10,
        "verifySchnorrSecp256k1Signature-cpu-arguments-intercept":  43574283,
        "verifySchnorrSecp256k1Signature-cpu-arguments-slope":      26308,
        "verifySchnorrSecp256k1Signature-memory-arguments":         10,
}

var COST_MODELSV2 = map[int]cbor.Marshaler{1: PLUTUSV2COSTMODEL}

var COST_MODELSV1 = map[serialization.CustomBytes]cbor.Marshaler{
        {Value: "00"}: PLUTUSV1COSTMODEL,
}

type PlutusType int

const (
        PlutusArray PlutusType = iota
        PlutusMap
        PlutusIntMap
        PlutusInt
        PlutusBigInt
        PlutusBytes
        PlutusShortArray
)

type PlutusList interface {
        Len() int
}

type PlutusIndefArray []PlutusData
type PlutusDefArray []PlutusData

/*
*

        Len returns the length of the PlutusIndefArray.

        Returns:
                int: The length of the PlutusIndefArray.
*/
func (pia PlutusIndefArray) Len() int <span class="cov0" title="0">{
        return len(pia)
}</span>

/*
*

        Len returns the length of the PlutusDefArray.

        Returns:
                int: The length of the PlutusDefArray.
*/
func (pia PlutusDefArray) Len() int <span class="cov0" title="0">{
        return len(pia)
}</span>

/*
*

        Clone creates a deep copy of the PlutusIndefArray.

        Returns:
                PlutusIndefArray: A deep copy of the PlutusIndefArray.
*/
func (pia *PlutusIndefArray) Clone() PlutusIndefArray <span class="cov0" title="0">{
        ret := PlutusIndefArray{}
        for _, v := range *pia </span><span class="cov0" title="0">{
                ret = append(ret, v.Clone())
        }</span>
        <span class="cov0" title="0">return ret</span>
}

/*
*

        MarshalCBOR encodes the PlutusIndefArray into a CBOR-encoded byte


                slice, in which it serializes the elements in indefinite-length array format.

                Returns:
                           []uint8: The CBOR-encoded byte slice.
                           error: An error if marshaling fails.
*/
func (pia PlutusIndefArray) MarshalCBOR() ([]uint8, error) <span class="cov8" title="1">{
        res := make([]byte, 0)
        res = append(res, 0x9f)
        for _, el := range pia </span><span class="cov8" title="1">{
                bytes, err := cbor.Marshal(el)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">res = append(res, bytes...)</span>
        }
        <span class="cov8" title="1">res = append(res, 0xff)
        return res, nil</span>
}

type Datum struct {
        PlutusDataType PlutusType
        TagNr          uint64
        Value          any
}

/*
*

        ToPlutusData converts a datum to PlutusData, encoding
        the Datum into CBOR format and then decodes it into a
        PlutusData.

        Returns:
                PlutusData: The converted PlutusData.
*/
func (pd *Datum) ToPlutusData() PlutusData <span class="cov0" title="0">{
        var res PlutusData
        enc, _ := cbor.Marshal(pd)
        err := cbor.Unmarshal(enc, &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: return errors
                return res
        }</span>
        <span class="cov0" title="0">return res</span>
}

/*
*

        Clone creates a deep copy of the Datum&gt;

        Returns:
                Datum: A deep copy of the Datum
*/
func (pd *Datum) Clone() Datum <span class="cov0" title="0">{
        return Datum{
                PlutusDataType: pd.PlutusDataType,
                TagNr:          pd.TagNr,
                Value:          pd.Value,
        }
}</span>

/*
*

        MarshalCBOR encodes the Datum into a CBOR-encoded byte slice,


                it applies a CBOR tag, if TagNr is not 0, otherwise it marshals the Value

                Returns:
                           []uint8: The CBOR-encoded byte slice.
                           error: An error if marshaling fails.
*/
func (pd Datum) MarshalCBOR() ([]uint8, error) <span class="cov0" title="0">{
        if pd.TagNr == 0 </span><span class="cov0" title="0">{
                return cbor.Marshal(pd.Value)
        }</span> else<span class="cov0" title="0"> {
                return cbor.Marshal(cbor.Tag{Number: pd.TagNr, Content: pd.Value})
        }</span>
}

/*
*

        UnmarshalCBOR decodes a CBOR-encoded byte slice into a Datum.


                It handles different Plutus data types and applies appropriate decoding logic.

                Returns:
                           error: An error if unmarshaling fails.
*/
func (pd *Datum) UnmarshalCBOR(value []uint8) error <span class="cov0" title="0">{
        var x any
        err := cbor.Unmarshal(value, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ok, valid := x.(cbor.Tag)
        if valid </span><span class="cov0" title="0">{
                switch ok.Content.(type) </span>{
                case []any:<span class="cov0" title="0">
                        pd.TagNr = ok.Number
                        pd.PlutusDataType = PlutusArray
                        res, err := cbor.Marshal(ok.Content)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">y := new([]Datum)
                        err = cbor.Unmarshal(res, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.Value = y</span>

                default:<span class="cov0" title="0">
                        //TODO SKIP
                        return nil</span>
                }
        } else<span class="cov0" title="0"> {
                switch x.(type) </span>{
                case []any:<span class="cov0" title="0">
                        y := new([]Datum)
                        err = cbor.Unmarshal(value, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusArray
                        pd.Value = y
                        pd.TagNr = 0</span>
                case uint64:<span class="cov0" title="0">
                        pd.PlutusDataType = PlutusInt
                        pd.Value = x
                        pd.TagNr = 0</span>

                case []uint8:<span class="cov0" title="0">
                        pd.PlutusDataType = PlutusBytes
                        pd.Value = x
                        pd.TagNr = 0</span>

                case map[any]any:<span class="cov0" title="0">
                        y := map[serialization.CustomBytes]Datum{}
                        err = cbor.Unmarshal(value, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusMap
                        pd.Value = y
                        pd.TagNr = 0</span>
                case map[uint64]any:<span class="cov0" title="0">
                        y := map[serialization.CustomBytes]Datum{}
                        err = cbor.Unmarshal(value, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusIntMap
                        pd.Value = &amp;y
                        pd.TagNr = 0</span>
                default:<span class="cov0" title="0"></span>
                }

        }

        <span class="cov0" title="0">return nil</span>
}

type PlutusData struct {
        PlutusDataType PlutusType
        TagNr          uint64
        Value          any
}

func (pd *PlutusData) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        if pd.TagNr != 0 </span><span class="cov0" title="0">{
                sb.WriteString("Constr: ")
                sb.WriteString(strconv.FormatUint(pd.TagNr, 10))
                sb.WriteByte('\n')
        }</span>
        <span class="cov0" title="0">switch pd.PlutusDataType </span>{
        case PlutusArray:<span class="cov0" title="0">
                sb.WriteString("Array[\n")
                value, ok := pd.Value.(PlutusIndefArray)
                if ok </span><span class="cov0" title="0">{
                        for _, v := range value </span><span class="cov0" title="0">{
                                contentString := v.String()
                                for idx, line := range strings.Split(contentString, "\n") </span><span class="cov0" title="0">{
                                        if idx == len(strings.Split(contentString, "\n"))-1 </span><span class="cov0" title="0">{
                                                sb.WriteString("    " + line)
                                        }</span> else<span class="cov0" title="0"> {
                                                sb.WriteString("    " + line + "\n")
                                        }</span>
                                }
                                <span class="cov0" title="0">sb.WriteString(",\n")</span>
                        }
                        <span class="cov0" title="0">sb.WriteByte(']')</span>
                }
                <span class="cov0" title="0">value2, ok := pd.Value.(PlutusDefArray)
                if ok </span><span class="cov0" title="0">{
                        for _, v := range value2 </span><span class="cov0" title="0">{
                                contentString := v.String()
                                for line := range strings.SplitSeq(contentString, "\n") </span><span class="cov0" title="0">{
                                        sb.WriteString("    " + line + "\n")
                                }</span>
                                <span class="cov0" title="0">sb.WriteString(",\n")</span>
                        }
                        <span class="cov0" title="0">sb.WriteByte(']')</span>
                }
        case PlutusMap:<span class="cov0" title="0">
                value, ok := pd.Value.(map[serialization.CustomBytes]PlutusData)
                if ok </span><span class="cov0" title="0">{
                        sb.WriteString("Map{\n")
                        for k, v := range value </span><span class="cov0" title="0">{
                                contentString := v.String()
                                sb.WriteString(k.String() + ": ")
                                for idx, line := range strings.Split(contentString, "\n") </span><span class="cov0" title="0">{
                                        if idx == 0 </span><span class="cov0" title="0">{
                                                sb.WriteString(line + "\n")
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">sb.WriteString("    " + line + "\n")</span>
                                }
                                <span class="cov0" title="0">sb.WriteString(",\n")</span>
                        }
                        <span class="cov0" title="0">sb.WriteByte('}')</span>
                }

        case PlutusIntMap:<span class="cov0" title="0">
                value, ok := pd.Value.(map[serialization.CustomBytes]PlutusData)
                if ok </span><span class="cov0" title="0">{
                        sb.WriteString("IntMap{\n")
                        for k, v := range value </span><span class="cov0" title="0">{
                                contentString := v.String()
                                sb.WriteString(k.String() + ": ")
                                for idx, line := range strings.Split(contentString, "\n") </span><span class="cov0" title="0">{
                                        if idx == 0 </span><span class="cov0" title="0">{
                                                sb.WriteString(line + "\n")
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">sb.WriteString("    " + line + "\n")</span>
                                }
                                <span class="cov0" title="0">sb.WriteString(",\n")</span>
                        }
                        <span class="cov0" title="0">sb.WriteByte('}')</span>
                }
        case PlutusInt:<span class="cov0" title="0">
                sb.WriteString("Int(")
                sb.WriteString(strconv.FormatUint(pd.Value.(uint64), 10))
                sb.WriteByte(')')</span>
        case PlutusBytes:<span class="cov0" title="0">
                sb.WriteString("Bytes(")
                sb.WriteString(hex.EncodeToString(pd.Value.([]uint8)))
                sb.WriteByte(')')</span>
        default:<span class="cov0" title="0">
                sb.WriteString(fmt.Sprintf("%v", pd.Value))</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

/*
*

        Equal check if two PlutusData values are equal
        using their CBOR representations.

        Params:
                other (PlutusData): The other PlutusData to compare to.

        Returns:
                bool: True if the PlutusData are equal, false otherwise.
*/
func (pd *PlutusData) Equal(other PlutusData) bool <span class="cov0" title="0">{
        marshaledThis, _ := cbor.Marshal(pd)
        marshaledOther, _ := cbor.Marshal(other)
        return bytes.Equal(marshaledThis, marshaledOther)
}</span>

/*
*

        ToDatum converts a PlutusData to a Datum, in which
        it encodes the PlutusData into CBOR format and later
        into a Datum.

        Returns:
                Datum: The converted Datum.
*/
func (pd *PlutusData) ToDatum() Datum <span class="cov0" title="0">{

        var res Datum
        enc, _ := cbor.Marshal(pd)
        err := cbor.Unmarshal(enc, &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: return errors
                return res
        }</span>
        <span class="cov0" title="0">return res</span>
}

/*
*

        Clone creates a deep copy of a PlutusData object.

        Returns:
                PlutusData: A cloned PlutusData object.
*/
func (pd *PlutusData) Clone() PlutusData <span class="cov0" title="0">{
        return PlutusData{
                PlutusDataType: pd.PlutusDataType,
                TagNr:          pd.TagNr,
                Value:          pd.Value,
        }
}</span>

/*
*

        MarshalCBOR encodes the PlutusData into a CBOR byte slice.

        Returns:
                []uint8: The CBOR-encoded byte slice.
                error: An error, if any, during ecoding.
*/
func (pd *PlutusData) MarshalCBOR() ([]uint8, error) <span class="cov8" title="1">{
        //enc, _ := cbor.CanonicalEncOptions().EncMode()
        switch pd.PlutusDataType </span>{
        case PlutusMap:<span class="cov8" title="1">
                customEnc, _ := cbor.EncOptions{
                        Sort: cbor.SortBytewiseLexical,
                }.EncMode()
                if pd.TagNr != 0 </span><span class="cov8" title="1">{
                        return customEnc.Marshal(
                                cbor.Tag{Number: pd.TagNr, Content: pd.Value},
                        )
                }</span> else<span class="cov8" title="1"> {
                        return customEnc.Marshal(pd.Value)
                }</span>
        case PlutusIntMap:<span class="cov0" title="0">
                canonicalenc, _ := cbor.CanonicalEncOptions().EncMode()
                if pd.TagNr != 0 </span><span class="cov0" title="0">{
                        return canonicalenc.Marshal(
                                cbor.Tag{Number: pd.TagNr, Content: pd.Value},
                        )
                }</span> else<span class="cov0" title="0"> {
                        return canonicalenc.Marshal(pd.Value)
                }</span>
        case PlutusBigInt:<span class="cov0" title="0">
                return cbor.Marshal(pd.Value)</span>
        default:<span class="cov8" title="1">
                //enc, _ := cbor.EncOptions{Sort: cbor.SortCTAP2}.EncMode()
                if pd.TagNr == 0 </span><span class="cov8" title="1">{
                        return cbor.Marshal(pd.Value)
                }</span> else<span class="cov8" title="1"> {
                        return cbor.Marshal(cbor.Tag{Number: pd.TagNr, Content: pd.Value})
                }</span>
        }

}

/*
*

                UnmarshalJSON unmarshals JSON-encoded PlutusData into a PlutusData object.

                Params:
                           value ([]byte): The JSON-encoded data to unmarshal.

                 Returns:
                           error: An error, if any, during unmarshaling.
*/
func (pd *PlutusData) UnmarshalJSON(value []byte) error <span class="cov8" title="1">{
        var x any
        err := json.Unmarshal(value, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch x.(type) </span>{
        case []any:<span class="cov8" title="1">
                y := new([]PlutusData)
                err = json.Unmarshal(value, y)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pd.PlutusDataType = PlutusArray
                pd.Value = PlutusIndefArray(*y)
                pd.TagNr = 0</span>
        case map[string]any:<span class="cov8" title="1">
                val := x.(map[string]any)
                _, ok := val["fields"]
                if ok </span><span class="cov8" title="1">{
                        contents, _ := json.Marshal(val["fields"])
                        var tag int
                        constructor, ok := val["constructor"]
                        if ok </span><span class="cov8" title="1">{
                                constrfloat := constructor.(float64)
                                if constrfloat &lt; 7 </span><span class="cov8" title="1">{
                                        tag = int(121 + constrfloat)
                                }</span> else<span class="cov0" title="0"> if 7 &lt;= constrfloat &amp;&amp; constrfloat &lt; 1400 </span><span class="cov0" title="0">{
                                        tag = int(1280 + constrfloat - 7)
                                }</span> else<span class="cov0" title="0"> {
                                        return errors.New("constructor out of range ")
                                }</span>
                        } else<span class="cov8" title="1"> {
                                tag = 0
                        }</span>
                        <span class="cov8" title="1">y := new(PlutusData)
                        err = json.Unmarshal(contents, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">pd.PlutusDataType = PlutusMap
                        pd.Value = y
                        pd.TagNr = uint64(tag)</span>
                } else<span class="cov8" title="1"> if _, ok := val["biguint"]; ok </span><span class="cov0" title="0">{
                        vl := big.NewInt(0)
                        vl.SetBytes([]byte(val["biguint"].(string)))
                        pd.PlutusDataType = PlutusInt
                        pd.Value = vl.Uint64()
                }</span> else<span class="cov8" title="1"> if _, ok := val["bignint"]; ok </span><span class="cov0" title="0">{
                        vl := big.NewInt(0)
                        vl.SetBytes([]byte(val["bignint"].(string)))
                        pd.PlutusDataType = PlutusInt
                        pd.Value = vl.Uint64()
                }</span> else<span class="cov8" title="1"> if _, ok := val["bytes"]; ok </span><span class="cov8" title="1">{
                        pd.PlutusDataType = PlutusBytes
                        pd.Value, _ = hex.DecodeString(val["bytes"].(string))
                }</span> else<span class="cov8" title="1"> if _, ok := val["int"]; ok </span><span class="cov8" title="1">{
                        pd.PlutusDataType = PlutusInt
                        pd.Value = uint64(val["int"].(float64))
                }</span> else<span class="cov0" title="0"> if valu, ok := val["map"]; ok </span><span class="cov0" title="0">{
                        var tag int
                        constructor, ok := val["constructor"]
                        if ok </span><span class="cov0" title="0">{
                                constrfloat := constructor.(float64)
                                if constrfloat &lt; 7 </span><span class="cov0" title="0">{
                                        tag = int(121 + constrfloat)
                                }</span> else<span class="cov0" title="0"> if 7 &lt;= constrfloat &amp;&amp; constrfloat &lt; 1400 </span><span class="cov0" title="0">{
                                        tag = int(1280 + constrfloat - 7)
                                }</span> else<span class="cov0" title="0"> {
                                        return errors.New("constructor out of range ")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tag = 0
                        }</span>
                        <span class="cov0" title="0">isInt := false
                        normalMap := make(map[serialization.CustomBytes]PlutusData)
                        IntMap := make(map[uint64]PlutusData)
                        for _, element := range valu.([]any) </span><span class="cov0" title="0">{
                                dictionary, ok := element.(map[string]any)
                                if ok </span><span class="cov0" title="0">{
                                        kval, okk := dictionary["k"].(map[string]any)
                                        vval, okv := dictionary["v"].(map[string]any)
                                        if okk &amp;&amp; okv </span><span class="cov0" title="0">{
                                                if kvalue, okk := kval["int"]; okk </span><span class="cov0" title="0">{
                                                        isInt = true
                                                        pd := PlutusData{}
                                                        var marshaled []byte
                                                        marshaled, err = json.Marshal(vval)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>

                                                        <span class="cov0" title="0">err = json.Unmarshal(marshaled, &amp;pd)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">parsedInt := kvalue.(float64)
                                                        IntMap[uint64(parsedInt)] = pd</span>
                                                } else<span class="cov0" title="0"> {
                                                        pd := PlutusData{}
                                                        var marshaled []byte
                                                        marshaled, err = json.Marshal(vval)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>

                                                        <span class="cov0" title="0">err = json.Unmarshal(marshaled, &amp;pd)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">bytes, _ := hex.DecodeString(kval["bytes"].(string))
                                                        cb := serialization.NewCustomBytes(string(bytes))
                                                        normalMap[cb] = pd</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">if isInt </span><span class="cov0" title="0">{
                                pd.PlutusDataType = PlutusIntMap
                                pd.Value = IntMap
                                pd.TagNr = uint64(tag)
                        }</span> else<span class="cov0" title="0"> {
                                pd.PlutusDataType = PlutusMap
                                pd.Value = normalMap
                                pd.TagNr = uint64(tag)
                        }</span>
                        <span class="cov0" title="0">return nil</span>

                } else<span class="cov0" title="0"> if valu, ok := val["list"]; ok </span><span class="cov0" title="0">{
                        y := new([]PlutusData)
                        var tag int
                        constructor, ok := val["constructor"]
                        if ok </span><span class="cov0" title="0">{
                                constrfloat := constructor.(float64)
                                if constrfloat &lt; 7 </span><span class="cov0" title="0">{
                                        tag = int(121 + constrfloat)
                                }</span> else<span class="cov0" title="0"> if 7 &lt;= constrfloat &amp;&amp; constrfloat &lt; 1400 </span><span class="cov0" title="0">{
                                        tag = int(1280 + constrfloat - 7)
                                }</span> else<span class="cov0" title="0"> {
                                        return errors.New("constructor out of range ")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tag = 0
                        }</span>

                        <span class="cov0" title="0">marshaled, _ := json.Marshal(valu)
                        err = json.Unmarshal(marshaled, y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pd.PlutusDataType = PlutusArray
                        pd.Value = PlutusIndefArray(*y)
                        pd.TagNr = uint64(tag)</span>

                }
        default:<span class="cov0" title="0">
                fmt.Println("DEFAULT", x)</span>

        }
        <span class="cov8" title="1">return nil</span>
}

type PlutusDataKey struct {
        CborHexValue string
}

func (pdk *PlutusDataKey) String() string <span class="cov0" title="0">{
        return pdk.CborHexValue

}</span>

func (pdk *PlutusDataKey) UnmarshalCBOR(value []uint8) error <span class="cov0" title="0">{
        pdk.CborHexValue = hex.EncodeToString(value)
        return nil
}</span>

func (pdk *PlutusDataKey) MarshalCBOR() ([]uint8, error) <span class="cov0" title="0">{
        decodedHex, _ := hex.DecodeString(pdk.CborHexValue)
        return decodedHex, nil
}</span>

/*
*

                UnmarshalCBOR unmarshals CBOR-encoded data into a PlutusData object.

                Params:
                           value ([]uint8): The CBOR-encoded data to unmarshal.

                 Returns:
                           error: An error, if any, during unmarshaling.
*/
func (pd *PlutusData) UnmarshalCBOR(value []uint8) error <span class="cov8" title="1">{
        var x any
        err := cbor.Unmarshal(value, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //fmt.Println(hex.EncodeToString(value))
        <span class="cov8" title="1">ok, valid := x.(cbor.Tag)
        if valid </span><span class="cov8" title="1">{
                switch ok.Content.(type) </span>{
                case big.Int:<span class="cov0" title="0">
                        pd.PlutusDataType = PlutusBigInt
                        tmpBigInt := x.(big.Int)
                        pd.Value = tmpBigInt
                        pd.TagNr = 0</span>
                case []any:<span class="cov8" title="1">
                        pd.TagNr = ok.Number
                        pd.PlutusDataType = PlutusArray
                        lenTag := len([]byte(strconv.FormatUint(ok.Number, 10)))
                        if value[lenTag-1] == 0x9f </span><span class="cov8" title="1">{
                                y := PlutusIndefArray{}
                                err = cbor.Unmarshal(value[lenTag-1:], &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">pd.Value = y</span>
                        } else<span class="cov8" title="1"> {
                                y := PlutusDefArray{}
                                err = cbor.Unmarshal(value[lenTag-1:], &amp;y)
                                if err != nil </span><span class="cov0" title="0">{

                                        return err
                                }</span>
                                <span class="cov8" title="1">pd.Value = y</span>
                        }
                case []uint8:<span class="cov0" title="0">
                        pd.TagNr = ok.Number
                        pd.PlutusDataType = PlutusBytes
                        pd.Value = ok.Content</span>
                case map[any]any:<span class="cov0" title="0">
                        y := map[serialization.CustomBytes]PlutusData{}
                        err = cbor.Unmarshal(value, &amp;y)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">isInt := false
                        for k := range y </span><span class="cov0" title="0">{
                                if k.IsInt() </span><span class="cov0" title="0">{
                                        isInt = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInt </span><span class="cov0" title="0">{
                                pd.PlutusDataType = PlutusIntMap
                        }</span> else<span class="cov0" title="0"> {
                                pd.PlutusDataType = PlutusMap
                        }</span>
                        <span class="cov0" title="0">pd.Value = y
                        pd.TagNr = 0</span>

                default:<span class="cov0" title="0">
                        //TODO SKIP
                        return nil</span>
                }
        } else<span class="cov8" title="1"> {
                switch x := x.(type) </span>{
                case big.Int:<span class="cov0" title="0">
                        pd.PlutusDataType = PlutusBigInt
                        tmpBigInt := x
                        pd.Value = tmpBigInt
                        pd.TagNr = 0</span>
                case []any:<span class="cov0" title="0">
                        if value[0] == 0x9f </span><span class="cov0" title="0">{
                                y := PlutusIndefArray{}
                                err = cbor.Unmarshal(value, &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">pd.PlutusDataType = PlutusArray
                                pd.Value = y
                                pd.TagNr = 0</span>
                        } else<span class="cov0" title="0"> {
                                y := PlutusDefArray{}
                                err = cbor.Unmarshal(value, &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">pd.PlutusDataType = PlutusArray
                                pd.Value = y
                                pd.TagNr = 0</span>
                        }
                case uint64:<span class="cov8" title="1">
                        pd.PlutusDataType = PlutusInt
                        pd.Value = x
                        pd.TagNr = 0</span>

                case []uint8:<span class="cov8" title="1">
                        pd.PlutusDataType = PlutusBytes
                        pd.Value = x
                        pd.TagNr = 0</span>

                case map[any]any:<span class="cov0" title="0">
                        y := map[serialization.CustomBytes]PlutusData{}
                        err = cbor.Unmarshal(value, &amp;y)
                        if err != nil </span><span class="cov0" title="0">{
                                y := map[PlutusDataKey]PlutusData{}
                                err := cbor.Unmarshal(value, &amp;y)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">pd.PlutusDataType = PlutusMap
                                pd.Value = &amp;y
                                pd.TagNr = 0
                                return err</span>
                        }
                        <span class="cov0" title="0">isInt := false
                        for k := range y </span><span class="cov0" title="0">{
                                if k.IsInt() </span><span class="cov0" title="0">{
                                        isInt = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInt </span><span class="cov0" title="0">{
                                pd.PlutusDataType = PlutusIntMap
                        }</span> else<span class="cov0" title="0"> {
                                pd.PlutusDataType = PlutusMap
                        }</span>
                        <span class="cov0" title="0">pd.Value = y
                        pd.TagNr = 0</span>
                default:<span class="cov0" title="0">
                        _ = fmt.Errorf("invalid nested struct in plutus data %s", reflect.TypeOf(x))</span>
                }

        }

        <span class="cov8" title="1">return nil</span>
}

type RawPlutusData struct {
        //TODO
}

/*
*

        ToCbor converts the given interface to a hexadecimal-encoded CBOR string.

        Params:
                x (interface{}): The input value to be encoded to CBOR to converted
                                                 to a hexadecimal string.

        Returns:
                string: The hexadecimal-encoded CBOR representation of the input value.
                error: An error if the conversion fails.
*/
func ToCbor(x any) (string, error) <span class="cov0" title="0">{
        bytes, err := cbor.Marshal(x)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

/*
*

                PlutusDataHash computes the hash of a PlutusData structure using the Blake2b algorithm.

                 Params:


                           pd (*PlutusData): A pointer to the PlutusData structure to be hashed.

                Returns:
                          serialization.DatumHash: The hash of the PlutusData.
                        error: An error if the PlutusDataHash fails.
*/
func PlutusDataHash(pd *PlutusData) (serialization.DatumHash, error) <span class="cov0" title="0">{
        finalbytes := []byte{}
        bytes, err := cbor.Marshal(pd)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, bytes...)
        hash, err := blake2b.New(32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.DatumHash{Payload: hash.Sum(nil)}
        return r, nil</span>
}

/*
*

        HashDatum computes the hash of a CBOR marshaler using the Blake2b algorithm.

        Params:
                d (cbor.Marshaler): The CBOR marshaler to be hashed

        Returns:
                serialization.DatumHash: The hash of the CBOR marshaler.
                error: An error if the hash Datum fails.
*/
func HashDatum(d cbor.Marshaler) (serialization.DatumHash, error) <span class="cov0" title="0">{
        finalbytes := []byte{}
        bytes, err := cbor.Marshal(d)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, bytes...)
        hash, err := blake2b.New(32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.DatumHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.DatumHash{Payload: hash.Sum(nil)}
        return r, nil</span>
}

type ScriptHashable interface {
        Hash() (serialization.ScriptHash, error)
}

/*
*

        PlutusScriptHash computes the script hash of a ScriptHashable object.

        Params:
                script (ScriptHashable): The ScriptHashable object to be hashed.

        Returns:
                serialization.ScriptHash: The script hash of the ScriptHashable object.
*/
func PlutusScriptHash(script ScriptHashable) serialization.ScriptHash <span class="cov0" title="0">{
        hash, _ := script.Hash()
        return hash
}</span>

type PlutusV1Script []byte

/*
*

                ToAddress converts a PlutusV1Script to an Address with an optional staking credential.

                 Params:


                          stakingCredential ([]byte): The staking credential to include in the address.

                Returns:
                          Address.Address: The generated address.
*/
func (ps *PlutusV1Script) ToAddress(stakingCredential []byte) Address.Address <span class="cov0" title="0">{
        hash := PlutusScriptHash(ps)
        if stakingCredential == nil </span><span class="cov0" title="0">{
                return Address.Address{
                        PaymentPart: hash.Bytes(),
                        StakingPart: nil,
                        Network:     Address.MAINNET,
                        AddressType: Address.SCRIPT_NONE,
                        HeaderByte:  0b01110001,
                        Hrp:         "addr",
                }
        }</span> else<span class="cov0" title="0"> {
                return Address.Address{
                        PaymentPart: hash.Bytes(),
                        StakingPart: stakingCredential,
                        Network:     Address.MAINNET,
                        AddressType: Address.SCRIPT_KEY,
                        HeaderByte:  0b00010001,
                        Hrp:         "addr",
                }
        }</span>
}

type PlutusV2Script []byte

type PlutusV3Script []byte

func (ps3 PlutusV3Script) Hash() (serialization.ScriptHash, error) <span class="cov0" title="0">{
        finalbytes, err := hex.DecodeString("03")
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, ps3...)
        hash, err := blake2b.New(28, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.ScriptHash{}
        copy(r[:], hash.Sum(nil))
        return r, nil</span>
}

func (ps3 *PlutusV3Script) ToAddress(
        stakingCredential []byte,
        network constants.Network,
) Address.Address <span class="cov0" title="0">{
        hash := PlutusScriptHash(ps3)
        if stakingCredential == nil </span><span class="cov0" title="0">{
                if network == constants.MAINNET </span><span class="cov0" title="0">{
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: nil,
                                Network:     Address.MAINNET,
                                AddressType: Address.SCRIPT_NONE,
                                HeaderByte:  0b01110001,
                                Hrp:         "addr",
                        }
                }</span> else<span class="cov0" title="0"> {
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: nil,
                                Network:     Address.TESTNET,
                                AddressType: Address.SCRIPT_KEY,
                                HeaderByte:  0b01110001,
                                Hrp:         "addr_test",
                        }
                }</span>
        } else<span class="cov0" title="0"> {
                if network == constants.MAINNET </span><span class="cov0" title="0">{
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: stakingCredential,
                                Network:     Address.MAINNET,
                                AddressType: Address.SCRIPT_KEY,
                                HeaderByte:  0b00010001,
                                Hrp:         "addr",
                        }
                }</span> else<span class="cov0" title="0"> {
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: stakingCredential,
                                Network:     Address.TESTNET,
                                AddressType: Address.SCRIPT_KEY,
                                HeaderByte:  0b00010000,
                                Hrp:         "addr_test",
                        }
                }</span>
        }
}

/*
*

                ToAddress converts a PlutusV2Script to an Address with an optional staking credential.

                 Params:


                          stakingCredential ([]byte): The staking credential to include in the address.

                Returns:
                          Address.Address: The generated address.
*/
func (ps *PlutusV2Script) ToAddress(
        stakingCredential []byte,
        network constants.Network,
) Address.Address <span class="cov0" title="0">{
        hash := PlutusScriptHash(ps)
        if stakingCredential == nil </span><span class="cov0" title="0">{
                if network == constants.MAINNET </span><span class="cov0" title="0">{
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: nil,
                                Network:     Address.MAINNET,
                                AddressType: Address.SCRIPT_NONE,
                                HeaderByte:  0b01110001,
                                Hrp:         "addr",
                        }
                }</span> else<span class="cov0" title="0"> {
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: nil,
                                Network:     Address.TESTNET,
                                AddressType: Address.SCRIPT_KEY,
                                HeaderByte:  0b01110001,
                                Hrp:         "addr_test",
                        }
                }</span>
        } else<span class="cov0" title="0"> {
                if network == constants.MAINNET </span><span class="cov0" title="0">{
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: stakingCredential,
                                Network:     Address.MAINNET,
                                AddressType: Address.SCRIPT_KEY,
                                HeaderByte:  0b00010001,
                                Hrp:         "addr",
                        }
                }</span> else<span class="cov0" title="0"> {
                        return Address.Address{
                                PaymentPart: hash.Bytes(),
                                StakingPart: stakingCredential,
                                Network:     Address.TESTNET,
                                AddressType: Address.SCRIPT_KEY,
                                HeaderByte:  0b00010000,
                                Hrp:         "addr_test",
                        }
                }</span>
        }
}

/*
*

                 Hash computes the script hash for a PlutusV1Script.

                 Returns:
                           serialization.ScriptHash: The script hash of the PlutusV1Script.
                        error: An error if the hashing fails.
*/
func (ps PlutusV1Script) Hash() (serialization.ScriptHash, error) <span class="cov0" title="0">{
        finalbytes, err := hex.DecodeString("01")
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, ps...)
        hash, err := blake2b.New(28, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.ScriptHash{}
        copy(r[:], hash.Sum(nil))
        return r, nil</span>
}

/*
*

                 Hash computes the script hash for a PlutusV2Script.

                 Returns:
                           serialization.ScriptHash: The script hash of the PlutusV2Script.
                        error: An error if the Hashing fails.
*/
func (ps PlutusV2Script) Hash() (serialization.ScriptHash, error) <span class="cov0" title="0">{
        finalbytes, err := hex.DecodeString("02")
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">finalbytes = append(finalbytes, ps...)
        hash, err := blake2b.New(28, nil)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(finalbytes)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.ScriptHash{}, err
        }</span>
        <span class="cov0" title="0">r := serialization.ScriptHash{}
        copy(r[:], hash.Sum(nil))
        return r, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package Policy

import (
        "encoding/hex"
        "errors"

        "github.com/fxamacker/cbor/v2"
)

type PolicyId struct {
        Value string
}

/*
*

        New creates a new PolicyId from a hexadecimal string

        Params:
                value string: The hexadecimal string representing the policy ID.

        Returns:
                *PolicyId: A pointer to the PolicyId.
                error: An error if the input string is not of the expected length.
*/
func New(value string) (*PolicyId, error) <span class="cov8" title="1">{
        if len(value) != 56 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid length of a policy id")
        }</span>
        <span class="cov0" title="0">return &amp;PolicyId{
                Value: value,
        }, nil</span>
}

/*
*

        FromBytes creates a new PolicyId from a byte slice.

        Params:
                value []byte: The byte slice representing the policy ID.

        Returns:
                *PolicyId: A pointer to the PolicyId.
                error: An error if the input byte slice is not of the expected length.
*/
func FromBytes(value []byte) (*PolicyId, error) <span class="cov8" title="1">{
        if len(value) != 28 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid length of a policy id")
        }</span>
        <span class="cov0" title="0">return &amp;PolicyId{
                Value: hex.EncodeToString(value),
        }, nil</span>
}

/*
*

        String returns the hexadecimal string representation
        of the PolicyId.
*/
func (policyId PolicyId) String() string <span class="cov8" title="1">{
        return policyId.Value
}</span>

/*
*

        MarshalCBOR serializes the PolicyId to CBOR format.

        Returns:
                []byte: The CBOR serialized data.
                error: An error if the serialization fails.
*/
func (policyId *PolicyId) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        res, err := hex.DecodeString(policyId.Value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(res) != 28 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid length of a policy id")
        }</span>

        <span class="cov8" title="1">if len(res) == 0 </span><span class="cov0" title="0">{
                return cbor.Marshal(make([]byte, 0))
        }</span>
        <span class="cov8" title="1">return cbor.Marshal(res)</span>

}

/*
*

        UnmarshalCBOR deserializes the PolicyId from CBOR format.

        Params:
                value []byte: The CBOR serialized data.

        Returns:
                error: An error if the deserialization fails.
*/
func (policyId *PolicyId) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var res any
        err := cbor.Unmarshal(value, &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch res := res.(type) </span>{
        case []byte:<span class="cov8" title="1">
                hexString := hex.EncodeToString(res)
                if len(hexString) != 56 </span><span class="cov0" title="0">{
                        return errors.New("invalid length of a policy id")
                }</span>
                <span class="cov8" title="1">policyId.Value = hexString</span>
        case string:<span class="cov0" title="0">
                hexString := res
                if len(hexString) != 56 </span><span class="cov0" title="0">{
                        return errors.New("invalid length of a policy id")
                }</span>
                <span class="cov0" title="0">policyId.Value = hexString</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid type of a policy id")</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package Redeemer

import "github.com/Salvionied/apollo/serialization/PlutusData"

type RedeemerTag int

const (
        SPEND RedeemerTag = iota
        MINT
        CERT
        REWARD
)

// See https://ogmios.dev/mini-protocols/local-tx-submission/#evaluatetx
var RedeemerTagNames = map[RedeemerTag]string{
        0: "spend",
        1: "mint",
        2: "certificate",
        3: "withdrawal",
}

type ExecutionUnits struct {
        _     struct{} `cbor:",toarray"`
        Mem   int64
        Steps int64
}

/*
*

        Clone creates a deep copy of the ExecutionUnits.

        Returns:
                ExecutionUnits: A new ExecutionUnits instance with the same values.
*/
func (ex *ExecutionUnits) Clone() ExecutionUnits <span class="cov8" title="1">{
        return ExecutionUnits{
                Mem:   ex.Mem,
                Steps: ex.Steps,
        }
}</span>

/*
*

        Sum adds the memory and step of another ExecutionUnits to
        the current instance.

        Params:
                other ExecutionUnits: The ExecutionUnits to add.
*/
func (eu *ExecutionUnits) Sum(other ExecutionUnits) <span class="cov8" title="1">{
        eu.Mem += other.Mem
        eu.Steps += other.Steps
}</span>

// TODO
type Redeemer struct {
        _       struct{} `cbor:",toarray"`
        Tag     RedeemerTag
        Index   int
        Data    PlutusData.PlutusData
        ExUnits ExecutionUnits
}

/*
*

        Clone creates a deep copy of the Redeemer.

        Returns:
                Redeemer: A new Redeemer instance with the same values.
*/
func (r Redeemer) Clone() Redeemer <span class="cov8" title="1">{
        return Redeemer{
                Tag:     r.Tag,
                Index:   r.Index,
                Data:    r.Data.Clone(),
                ExUnits: r.ExUnits.Clone(),
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package Relay

import (
        "errors"
        "fmt"

        "github.com/fxamacker/cbor/v2"
)

// ReadKind extracts the kind discriminator from a CBOR-decoded value.
// fxamacker/cbor decodes positive integers as uint64 by default, so we
// must accept both uint64 and int64 here.
func ReadKind(v any) (int, error) <span class="cov8" title="1">{
        switch n := v.(type) </span>{
        case uint64:<span class="cov8" title="1">
                if n &gt; uint64(^uint(0)&gt;&gt;1) </span><span class="cov0" title="0">{ // guard: larger than max int
                        return 0, errors.New("kind out of range")
                }</span>
                <span class="cov8" title="1">return int(n), nil</span>
        case int64:<span class="cov0" title="0">
                if n &lt; 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("kind must be non-negative")
                }</span>
                <span class="cov0" title="0">if n &gt; int64(^uint(0)&gt;&gt;1) </span><span class="cov0" title="0">{
                        return 0, errors.New("kind out of range")
                }</span>
                <span class="cov0" title="0">return int(n), nil</span>
        default:<span class="cov8" title="1">
                return 0, errors.New("invalid type for kind; expected integer")</span>
        }
}

type RelayInterface interface {
        Kind() int
        MarshalCBOR() ([]byte, error)
}

type SingleHostAddr struct {
        Port *uint16
        Ipv4 []byte
        Ipv6 []byte
}

func (v SingleHostAddr) Kind() int <span class="cov8" title="1">{ return 0 }</span>
func (v SingleHostAddr) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if v.Ipv4 != nil &amp;&amp; len(v.Ipv4) != 4 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(
                        "ipv4 must be 4 bytes when set, got %d",
                        len(v.Ipv4),
                )
        }</span>
        <span class="cov8" title="1">if v.Ipv6 != nil &amp;&amp; len(v.Ipv6) != 16 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(
                        "ipv6 must be 16 bytes when set, got %d",
                        len(v.Ipv6),
                )
        }</span>
        <span class="cov8" title="1">return cbor.Marshal([]any{v.Kind(), v.Port, v.Ipv4, v.Ipv6})</span>
}
func (v *SingleHostAddr) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        var arr []any
        if err := cbor.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(arr) != 4 </span><span class="cov8" title="1">{
                return fmt.Errorf("expected array of length 4, got %d", len(arr))
        }</span>
        // kind discriminator
        <span class="cov8" title="1">k, err := ReadKind(arr[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if k != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("unexpected kind %d for SingleHostAddr", k)
        }</span>

        <span class="cov8" title="1">if arr[1] == nil </span><span class="cov8" title="1">{
                v.Port = nil
        }</span> else<span class="cov8" title="1"> {
                switch p := arr[1].(type) </span>{
                case uint64:<span class="cov8" title="1">
                        if p &gt; 65535 </span><span class="cov8" title="1">{
                                return fmt.Errorf("port out of range: %d", p)
                        }</span>
                        <span class="cov8" title="1">pv := uint16(p)
                        v.Port = &amp;pv</span>
                default:<span class="cov8" title="1">
                        return errors.New("invalid type for port; expected unsigned integer or null")</span>
                }
        }

        // ipv4
        <span class="cov8" title="1">if arr[2] == nil </span><span class="cov8" title="1">{
                v.Ipv4 = nil
        }</span> else<span class="cov8" title="1"> {
                b, ok := arr[2].([]byte)
                if !ok </span><span class="cov8" title="1">{
                        return errors.New("invalid type for ipv4; expected byte string or null")
                }</span>
                <span class="cov8" title="1">if len(b) != 4 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ipv4 must be 4 bytes, got %d", len(b))
                }</span>
                <span class="cov8" title="1">v.Ipv4 = append([]byte(nil), b...)</span>
        }

        // ipv6
        <span class="cov8" title="1">if arr[3] == nil </span><span class="cov8" title="1">{
                v.Ipv6 = nil
        }</span> else<span class="cov8" title="1"> {
                b, ok := arr[3].([]byte)
                if !ok </span><span class="cov8" title="1">{
                        return errors.New("invalid type for ipv6; expected byte string or null")
                }</span>
                <span class="cov8" title="1">if len(b) != 16 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ipv6 must be 16 bytes, got %d", len(b))
                }</span>
                <span class="cov8" title="1">v.Ipv6 = append([]byte(nil), b...)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type SingleHostName struct {
        Port    *uint16
        DnsName string
}

func (v SingleHostName) Kind() int <span class="cov8" title="1">{ return 1 }</span>
func (v SingleHostName) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if len(v.DnsName) &gt; 128 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("dns name too long: %d", len(v.DnsName))
        }</span>
        <span class="cov8" title="1">return cbor.Marshal([]any{v.Kind(), v.Port, v.DnsName})</span>
}
func (v *SingleHostName) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        var arr []any
        if err := cbor.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(arr) != 3 </span><span class="cov8" title="1">{
                return fmt.Errorf("expected array of length 3, got %d", len(arr))
        }</span>
        // kind discriminator
        <span class="cov8" title="1">k, err := ReadKind(arr[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if k != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("unexpected kind %d for SingleHostName", k)
        }</span>
        // port
        <span class="cov8" title="1">if arr[1] == nil </span><span class="cov8" title="1">{
                v.Port = nil
        }</span> else<span class="cov8" title="1"> {
                switch p := arr[1].(type) </span>{
                case uint64:<span class="cov8" title="1">
                        if p &gt; 65535 </span><span class="cov8" title="1">{
                                return fmt.Errorf("port out of range: %d", p)
                        }</span>
                        <span class="cov8" title="1">pv := uint16(p)
                        v.Port = &amp;pv</span>
                default:<span class="cov8" title="1">
                        return errors.New("invalid type for port; expected unsigned integer or null")</span>
                }
        }

        // dns name
        <span class="cov8" title="1">switch d := arr[2].(type) </span>{
        case string:<span class="cov8" title="1">
                if len(d) &gt; 128 </span><span class="cov8" title="1">{
                        return fmt.Errorf("dns name too long: %d", len(d))
                }</span>
                <span class="cov8" title="1">v.DnsName = d</span>
        default:<span class="cov8" title="1">
                return errors.New("invalid type for dns name; expected string")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type MultiHostName struct {
        DnsName string
}

func (v MultiHostName) Kind() int <span class="cov8" title="1">{ return 2 }</span>
func (v MultiHostName) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if len(v.DnsName) &gt; 128 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("dns name too long: %d", len(v.DnsName))
        }</span>
        <span class="cov8" title="1">return cbor.Marshal([]any{v.Kind(), v.DnsName})</span>
}
func (v *MultiHostName) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        var arr []any
        if err := cbor.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(arr) != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("expected array of length 2, got %d", len(arr))
        }</span>
        // kind discriminator
        <span class="cov8" title="1">k, err := ReadKind(arr[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if k != 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("unexpected kind %d for MultiHostName", k)
        }</span>

        // dns name
        <span class="cov8" title="1">switch d := arr[1].(type) </span>{
        case string:<span class="cov8" title="1">
                if len(d) &gt; 128 </span><span class="cov0" title="0">{
                        return fmt.Errorf("dns name too long: %d", len(d))
                }</span>
                <span class="cov8" title="1">v.DnsName = d</span>
        default:<span class="cov8" title="1">
                return errors.New("invalid type for dns name; expected string")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// UnmarshalRelay unmarshals CBOR data into the appropriate Relay type based on the kind discriminator.
// It returns a RelayInterface and an error.
func UnmarshalRelay(data []byte) (RelayInterface, error) <span class="cov8" title="1">{
        // First, unmarshal to get the kind discriminator
        var arr []any
        if err := cbor.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(arr) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("empty array, cannot determine kind")
        }</span>

        // Extract kind
        <span class="cov8" title="1">kind, err := ReadKind(arr[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Dispatch based on kind
        <span class="cov8" title="1">switch kind </span>{
        case 0:<span class="cov8" title="1"> // single_host_addr = (0, port/ nil, ipv4/ nil, ipv6/ nil)
                var result SingleHostAddr
                if err := result.UnmarshalCBOR(data); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        case 1:<span class="cov8" title="1"> // single_host_name = (1, port/ nil, dns_name)
                var result SingleHostName
                if err := result.UnmarshalCBOR(data); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        case 2:<span class="cov8" title="1"> // multi_host_name = (2, dns_name)
                var result MultiHostName
                if err := result.UnmarshalCBOR(data); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unknown relay kind: %d", kind)</span>
        }
}

type Relays []RelayInterface

func (v Relays) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        arr := make([][]byte, 0, len(v))
        for _, relay := range v </span><span class="cov8" title="1">{
                bz, err := relay.MarshalCBOR()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">arr = append(arr, bz)</span>
        }
        <span class="cov8" title="1">out := make([]any, 0, len(arr))
        for _, e := range arr </span><span class="cov8" title="1">{
                var v any
                if err := cbor.Unmarshal(e, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">out = append(out, v)</span>
        }
        <span class="cov8" title="1">return cbor.Marshal(out)</span>
}

func (v *Relays) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        var arr []any
        if err := cbor.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">res := make(Relays, 0, len(arr))
        for _, item := range arr </span><span class="cov8" title="1">{
                marshaledRelay, err := cbor.Marshal(item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">relay, err := UnmarshalRelay(marshaledRelay)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">res = append(res, relay)</span>
        }
        <span class="cov8" title="1">*v = res
        return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package Transaction

import (
        "fmt"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Metadata"
        "github.com/Salvionied/apollo/serialization/TransactionBody"
        "github.com/Salvionied/apollo/serialization/TransactionWitnessSet"
        "github.com/fxamacker/cbor/v2"
)

type Transaction struct {
        _                     struct{} `cbor:",toarray"`
        TransactionBody       TransactionBody.TransactionBody
        TransactionWitnessSet TransactionWitnessSet.TransactionWitnessSet
        Valid                 bool
        AuxiliaryData         *Metadata.AuxiliaryData
}

/*
*

        Bytes returns the CBOR-encoded byte representation
        of the Transaction.

        Returns:
                []byte: The CBOR-encoded transaction bytes.
                error: An error if the Bytes fails.
*/
func (tx *Transaction) Bytes() ([]byte, error) <span class="cov8" title="1">{
        cborred, err := cbor.Marshal(tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshaling transaction, %w", err)
        }</span>
        <span class="cov8" title="1">return cborred, nil</span>
}

/*
*

        Id returns the unique identifier for the transaction.

        Returns:
                serialization.TransactionId: The transaction ID.
*/
func (tx *Transaction) Id() serialization.TransactionId <span class="cov8" title="1">{
        txId, _ := tx.TransactionBody.Id()
        return txId
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package TransactionBody

import (
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Certificate"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/Withdrawal"

        "github.com/fxamacker/cbor/v2"
        "golang.org/x/crypto/blake2b"
)

type TransactionBody struct {
        Inputs            []TransactionInput.TransactionInput   `cbor:"0,keyasint"`
        Outputs           []TransactionOutput.TransactionOutput `cbor:"1,keyasint"`
        Fee               int64                                 `cbor:"2,keyasint"`
        Ttl               int64                                 `cbor:"3,keyasint,omitempty"`
        Certificates      *Certificate.Certificates             `cbor:"4,keyasint,omitempty"`
        Withdrawals       *Withdrawal.Withdrawal                `cbor:"5,keyasint,omitempty"`
        UpdateProposals   []any                                 `cbor:"6,keyasint,omitempty"`
        AuxiliaryDataHash []byte                                `cbor:"7,keyasint,omitempty"`
        ValidityStart     int64                                 `cbor:"8,keyasint,omitempty"`
        Mint              MultiAsset.MultiAsset[int64]          `cbor:"9,keyasint,omitempty"`
        ScriptDataHash    []byte                                `cbor:"11,keyasint,omitempty"`
        Collateral        []TransactionInput.TransactionInput   `cbor:"13,keyasint,omitempty"`
        RequiredSigners   []serialization.PubKeyHash            `cbor:"14,keyasint,omitempty"`
        NetworkId         []byte                                `cbor:"15,keyasint,omitempty"`
        CollateralReturn  *TransactionOutput.TransactionOutput  `cbor:"16,keyasint,omitempty"`
        TotalCollateral   int                                   `cbor:"17,keyasint,omitempty"`
        ReferenceInputs   []TransactionInput.TransactionInput   `cbor:"18,keyasint,omitempty"`
}

type CborBody struct {
        Inputs            []TransactionInput.TransactionInput   `cbor:"0,keyasint"`
        Outputs           []TransactionOutput.TransactionOutput `cbor:"1,keyasint"`
        Fee               int64                                 `cbor:"2,keyasint"`
        Ttl               int64                                 `cbor:"3,keyasint,omitempty"`
        Certificates      *Certificate.Certificates             `cbor:"4,keyasint,omitempty"`
        Withdrawals       *Withdrawal.Withdrawal                `cbor:"5,keyasint,omitempty"`
        UpdateProposals   []any                                 `cbor:"6,keyasint,omitempty"`
        AuxiliaryDataHash []byte                                `cbor:"7,keyasint,omitempty"`
        ValidityStart     int64                                 `cbor:"8,keyasint,omitempty"`
        Mint              MultiAsset.MultiAsset[int64]          `cbor:"9,keyasint,omitempty"`
        ScriptDataHash    []byte                                `cbor:"11,keyasint,omitempty"`
        Collateral        []TransactionInput.TransactionInput   `cbor:"13,keyasint,omitempty"`
        RequiredSigners   []serialization.PubKeyHash            `cbor:"14,keyasint,omitempty"`
        NetworkId         []byte                                `cbor:"15,keyasint,omitempty"`
        CollateralReturn  *TransactionOutput.TransactionOutput  `cbor:"16,keyasint,omitempty"`
        TotalCollateral   int                                   `cbor:"17,keyasint,omitempty"`
        ReferenceInputs   []TransactionInput.TransactionInput   `cbor:"18,keyasint,omitempty"`
}

func (tx *TransactionBody) Hash() ([]byte, error) <span class="cov8" title="1">{
        bytes, err := cbor.Marshal(tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">hash, err := blake2b.New(32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_, err = hash.Write(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return hash.Sum(nil), nil</span>

}

func (tx *TransactionBody) Id() (serialization.TransactionId, error) <span class="cov8" title="1">{
        bytes, err := tx.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, err
        }</span>
        <span class="cov8" title="1">return serialization.TransactionId{Payload: bytes}, nil</span>
}

func (tx *TransactionBody) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        cborBody := CborBody{
                Inputs:            tx.Inputs,
                Outputs:           tx.Outputs,
                Fee:               tx.Fee,
                Ttl:               tx.Ttl,
                Certificates:      tx.Certificates,
                Withdrawals:       tx.Withdrawals,
                UpdateProposals:   tx.UpdateProposals,
                AuxiliaryDataHash: tx.AuxiliaryDataHash,
                ValidityStart:     tx.ValidityStart,
                Mint:              tx.Mint,
                ScriptDataHash:    tx.ScriptDataHash,
                Collateral:        tx.Collateral,
                RequiredSigners:   tx.RequiredSigners,
                NetworkId:         tx.NetworkId,
                CollateralReturn:  tx.CollateralReturn,
                TotalCollateral:   tx.TotalCollateral,
                ReferenceInputs:   tx.ReferenceInputs,
        }
        em, _ := cbor.CanonicalEncOptions().EncMode()
        return em.Marshal(cborBody)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package TransactionInput

import (
        "bytes"
        "encoding/hex"
        "strconv"
)

type TransactionInput struct {
        _             struct{} `cbor:",toarray"`
        TransactionId []byte
        Index         int
}

/*
*

        Clone returns a deep copy of the TransactionInput.

        Returns:
                TransactionInput: A deep copy of the TransactionInput.
*/
func (tx TransactionInput) Clone() TransactionInput <span class="cov8" title="1">{
        return TransactionInput{
                TransactionId: tx.TransactionId,
                Index:         tx.Index,
        }
}</span>

/*
*

        EqualTo checks if the TransactionInput is equal to another TransactionInput.

        Params:
                other TransactionInput: The TransactionInput to compare.

        Returns:


        bool: True if the TransactionInput is equal to the other TransactionInput, false otherwise.
*/
func (tx TransactionInput) EqualTo(other TransactionInput) bool <span class="cov8" title="1">{
        return bytes.Equal(tx.TransactionId, other.TransactionId) &amp;&amp;
                tx.Index == other.Index
}</span>

/*
*

        LessThan checks if the TransacctionInput is less than
        another TransactionInput based on index.

        Params:
                other TransactionInput: The TransactionInput to compare.

        Returns:


        bool: True if the TransactionInput is less than the other TransactionInput, false otherwise.
*/
func (tx TransactionInput) LessThan(other TransactionInput) bool <span class="cov8" title="1">{
        return tx.Index &lt; other.Index
}</span>

/*
*

        String returns a string representationof the TransactionInput
        in the format "transaction_id.index".
*/
func (tx TransactionInput) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(tx.TransactionId) + "." + strconv.Itoa(tx.Index)
}</span>

// func (tx TransactionInput) Hash() string {
//         final := append(tx.TransactionId[:], tx.Index)
//         blake_2b, _ := blake2b.New(TRANSACTION_HASH_SIZE, final)
//         KeyHash := blake_2b.Sum(make([]byte, 0))
//         return string(KeyHash)
// }
</pre>
		
		<pre class="file" id="file33" style="display: none">package TransactionOutput

import (
        "encoding/hex"
        "fmt"
        "reflect"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Value"

        "github.com/fxamacker/cbor/v2"
)

type TransactionOutputAlonzo struct {
        Address   Address.Address         `cbor:"0,keyasint"`
        Amount    Value.AlonzoValue       `cbor:"1,keyasint"`
        Datum     *PlutusData.DatumOption `cbor:"2,keyasint,omitempty"`
        ScriptRef *PlutusData.ScriptRef   `cbor:"3,keyasint,omitempty"`
}

/*
*

        Clone returns a dep copy of the TransactionOutputAlonzo.

        Returns:
                TransactionOutputAlonzo: A deep copy of the TransactionOutputAlonzo.
*/
func (t TransactionOutputAlonzo) Clone() TransactionOutputAlonzo <span class="cov8" title="1">{
        return TransactionOutputAlonzo{
                Address: t.Address,
                Amount:  t.Amount.Clone(),
                Datum:   t.Datum,
        }
}</span>

/*
*

        String returns a string representation of the TransactionOutputAlonzo,
        which includes the address and amount indicator.

        Returns:
                string: The string representation of TransactionOutputAlonzo.
*/
func (txo TransactionOutputAlonzo) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "%s:%s Datum :%v",
                txo.Address.String(),
                txo.Amount.ToValue().String(),
                txo.Datum,
        )
}</span>

type TransactionOutputShelley struct {
        Address   Address.Address
        Amount    Value.Value
        DatumHash serialization.DatumHash
        HasDatum  bool
}

/*
*

        Clone returns a deep copy of the TransactionOutputShelley.

        Returns:
                TransactionOutputShelley: A deep copy of the TransactionOutputShelley.
*/
func (t TransactionOutputShelley) Clone() TransactionOutputShelley <span class="cov8" title="1">{
        return TransactionOutputShelley{
                Address:   t.Address,
                Amount:    t.Amount.Clone(),
                DatumHash: t.DatumHash,
                HasDatum:  t.HasDatum,
        }
}</span>

/*
*

        String returns a string representation of the TransactionOutputShelley,


        which includes the address, amount and datum information in hexadecimal format.

        Returns:
                string: The string representation of TransactionOutputShelley.
*/
func (txo TransactionOutputShelley) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "%s:%s DATUM: %s",
                fmt.Sprint(txo.Address),
                txo.Amount,
                hex.EncodeToString(txo.DatumHash.Payload[:]),
        )
}</span>

type TxOWithDatum struct {
        _         struct{} `cbor:",toarray"`
        Address   Address.Address
        Amount    Value.Value
        DatumHash []byte
}
type TxOWithoutDatum struct {
        _       struct{} `cbor:",toarray"`
        Address Address.Address
        Amount  Value.Value
}

/*
*

        UnmarshalCBOR deserializes a CBOR-encoded byte slice into a TransactionOutputShelley,


        which determines whether the output has DATUM information and decodes accordingly.

        Params:


                value ([]byte): A CBOR-encoded byte slice representing the TransactionOutputShelley.

        Returns:
                error: An error if deserialization fails.
*/
func (txo *TransactionOutputShelley) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var x []any
        _ = cbor.Unmarshal(value, &amp;x)
        if len(x) == 3 </span><span class="cov8" title="1">{
                val := new(TxOWithDatum)
                err := cbor.Unmarshal(value, &amp;val)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">txo.HasDatum = true
                txo.Address = val.Address
                txo.Amount = val.Amount
                if len(val.DatumHash) &gt; 0 </span><span class="cov8" title="1">{

                        dthash := serialization.DatumHash{Payload: val.DatumHash}
                        txo.DatumHash = dthash

                }</span>
        } else<span class="cov8" title="1"> {
                val := new(TxOWithoutDatum)
                err := cbor.Unmarshal(value, &amp;val)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">txo.HasDatum = false
                txo.Address = val.Address
                txo.Amount = val.Amount</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

        MarshalCBOR serializes the TransactionOutputShelley into a CBOR-encoded byte slice,
        which is based on the DATUM information.

        Returns:


                          []byte: A CBOR-encoded byte slice representing the TransactionOutputShelley.
                           error: An error if serialization fails.
*/
func (txo *TransactionOutputShelley) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if txo.HasDatum </span><span class="cov8" title="1">{
                val := new(TxOWithDatum)
                val.DatumHash = txo.DatumHash.Payload[:]
                val.Address = txo.Address
                val.Amount = txo.Amount
                return cbor.Marshal(val)
        }</span> else<span class="cov8" title="1"> {
                val := new(TxOWithoutDatum)
                val.Address = txo.Address
                val.Amount = txo.Amount
                return cbor.Marshal(val)
        }</span>
}

// TODO
type TransactionOutput struct {
        PostAlonzo   TransactionOutputAlonzo
        PreAlonzo    TransactionOutputShelley
        IsPostAlonzo bool
}

/*
*

        Clone creates a deep copy of the TransactionOutput.

        Returns:
                TransactionOutput: A deep copy of the TransactionOutput.
*/
func (to TransactionOutput) Clone() TransactionOutput <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return TransactionOutput{
                        IsPostAlonzo: to.IsPostAlonzo,
                        PostAlonzo:   to.PostAlonzo.Clone(),
                }
        }</span> else<span class="cov8" title="1"> {
                return TransactionOutput{
                        IsPostAlonzo: to.IsPostAlonzo,
                        PreAlonzo:    to.PreAlonzo.Clone(),
                }
        }</span>

}

/*
*

        EqualTo checks if the current TransactionOutput is equal to another one.

        Params:
                other (TransactionOutput): The other TransactionOutput to compare.

        Returns:
                bool: True if the TransactionOutputs are equal, false otherwise.
*/
func (to *TransactionOutput) EqualTo(other TransactionOutput) bool <span class="cov8" title="1">{
        if to.IsPostAlonzo != other.IsPostAlonzo </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if to.IsPostAlonzo </span><span class="cov8" title="1">{
                coinEquality := to.PostAlonzo.Amount.Coin == other.PostAlonzo.Amount.Coin
                assetEquality := to.PostAlonzo.Amount.ToValue().
                        Equal(other.PostAlonzo.Amount.ToValue())
                datumEquality := reflect.DeepEqual(
                        to.PostAlonzo.Datum,
                        other.PostAlonzo.Datum,
                )
                return coinEquality &amp;&amp; assetEquality &amp;&amp; datumEquality
        }</span> else<span class="cov8" title="1"> {
                coinEquality := to.PreAlonzo.Amount.Coin == other.PreAlonzo.Amount.Coin
                assetEquality := to.PreAlonzo.Amount.Equal(other.PreAlonzo.Amount)
                datumEquality := reflect.DeepEqual(to.PreAlonzo.DatumHash, other.PreAlonzo.DatumHash)
                return coinEquality &amp;&amp; assetEquality &amp;&amp; datumEquality
        }</span>
}

/*
*

        GetAmount retrieves the value of the TransactionOutput as a Value object.

        Returns:
                Value.Value: The value of the TransactionOutput as a Value object.
*/
func (to *TransactionOutput) GetAmount() Value.Value <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return to.PostAlonzo.Amount.ToValue()
        }</span> else<span class="cov8" title="1"> {
                return to.PreAlonzo.Amount
        }</span>
}

/*
*

        SimpleTransactionOutput creates a simple TransactionOutput with a given address and value.

        Params:
                address (Address.Address): The recipinet address.
                value (Value.value): The value to send.

        Returns:
                TransactionOutput: A simple TransactionOutput.
*/
func SimpleTransactionOutput(
        address Address.Address,
        value Value.Value,
) TransactionOutput <span class="cov8" title="1">{
        return TransactionOutput{
                IsPostAlonzo: false,
                PreAlonzo: TransactionOutputShelley{
                        Address:  address,
                        Amount:   value,
                        HasDatum: false,
                },
        }
}</span>

/*
*

        SetDatum sets the Datum of the TransactionOutput.
        If it is a post Alonzo, it sets the Datum directly,
        otherwise it sets the DatumHash.

        Params:
                datum (*PlutusData.PlutusData): The Datum to set.
*/
func (to *TransactionOutput) SetDatum(datum *PlutusData.PlutusData) <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                l := PlutusData.DatumOptionInline(datum)
                to.PostAlonzo.Datum = &amp;l
        }</span> else<span class="cov8" title="1"> {
                dataHash, err := PlutusData.PlutusDataHash(datum)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">to.PreAlonzo.DatumHash = dataHash
                to.PreAlonzo.HasDatum = true</span>
        }
}

/*
*

        GetAddress retrieves the recipient address of the TransactionOutput.

        Returns:
                Address.Address: The recipient address.
*/
func (to *TransactionOutput) GetAddress() Address.Address <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return to.PostAlonzo.Address
        }</span> else<span class="cov8" title="1"> {
                return to.PreAlonzo.Address
        }</span>
}

/*
*

        GetAddressPointer retrieves a pointer to the recipient address of the TransactionOutput.

        Returns:
                *Address.Address: A pointer to the recipient address.
*/
func (to *TransactionOutput) GetAddressPointer() *Address.Address <span class="cov0" title="0">{
        if to.IsPostAlonzo </span><span class="cov0" title="0">{
                return &amp;to.PostAlonzo.Address
        }</span> else<span class="cov0" title="0"> {
                return &amp;to.PreAlonzo.Address
        }</span>
}

/*
*

        GetDatumHash retrieves, if available, the DatumHash of the TransactionOutput.

        Returns:
                *serialization.DatumHash: The DatumHash of the TransictionOutput or nil.
*/
func (to *TransactionOutput) GetDatumHash() *serialization.DatumHash <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return &amp;to.PreAlonzo.DatumHash
        }</span>
}

/*
*

        GetAddressPointer retrieves, if available, the Datum of the TransactionOutput.

        Returns:


        *PlutusData.PlutusData: The Datum of the TransictionOutput or an empty PlutusData.PlutusData.
*/
func (to *TransactionOutput) GetDatum() *PlutusData.PlutusData <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                switch d := to.PostAlonzo.Datum; d.DatumType </span>{
                case PlutusData.DatumTypeHash:<span class="cov0" title="0">
                        return nil</span>
                case PlutusData.DatumTypeInline:<span class="cov8" title="1">
                        return d.Inline</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        } else<span class="cov8" title="1"> {
                return nil
        }</span>
}

func (to *TransactionOutput) GetDatumOption() *PlutusData.DatumOption <span class="cov0" title="0">{
        if to.IsPostAlonzo </span><span class="cov0" title="0">{
                return to.PostAlonzo.Datum
        }</span> else<span class="cov0" title="0"> {
                d := PlutusData.DatumOptionHash(to.PreAlonzo.DatumHash.Payload)
                return &amp;d
        }</span>
}

/**
GetScriptRef retrieves, if available, the ScriptRef of the TransactionOutput.

Returns:
        *PlutusData.PlutusData: The ScriptRef of the TransictionOutput or an empty PlutusData.ScriptRef.
*/

func (to *TransactionOutput) GetScriptRef() *PlutusData.ScriptRef <span class="cov0" title="0">{
        if to.IsPostAlonzo </span><span class="cov0" title="0">{
                return to.PostAlonzo.ScriptRef
        }</span> else<span class="cov0" title="0"> {
                return new(PlutusData.ScriptRef)
        }</span>
}

/*
*

        GetValue retrieves the value of the TransactionOutput as a value object.

        Returns:
                Value.Value: The value of the TransactionOutput as a Value object.
*/
func (to *TransactionOutput) GetValue() Value.Value <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                return to.PostAlonzo.Amount.ToValue()
        }</span> else<span class="cov8" title="1"> {
                return to.PreAlonzo.Amount
        }</span>
}

/*
*

        Lovelace retireves the amount in Lovelace of the TransactionOutput.

        Returns:
                int64: The amount in Lovelace.
*/
func (to *TransactionOutput) Lovelace() int64 <span class="cov8" title="1">{
        if to.IsPostAlonzo </span><span class="cov8" title="1">{
                if to.PostAlonzo.Amount.HasAssets </span><span class="cov8" title="1">{
                        return to.PostAlonzo.Amount.Am.Coin
                }</span> else<span class="cov8" title="1"> {
                        return to.PostAlonzo.Amount.Coin
                }</span>
        } else<span class="cov8" title="1"> {
                if to.PreAlonzo.Amount.HasAssets </span><span class="cov8" title="1">{
                        return to.PreAlonzo.Amount.Am.Coin
                }</span> else<span class="cov8" title="1"> {
                        return to.PreAlonzo.Amount.Coin
                }</span>
        }
}

/*
*

        String returns a string representation of the TransactionOutput.

        Returns:
                string: A string representation of the TransactionOutput.
*/
func (txo TransactionOutput) String() string <span class="cov8" title="1">{
        if txo.IsPostAlonzo </span><span class="cov8" title="1">{
                return fmt.Sprint(txo.PostAlonzo)
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprint(txo.PreAlonzo)
        }</span>
}

/*
*

        UnmarshalCBOR deserializes a CBOR-encoded byte slice into a TransactionOutput,


                which determines the format of the output (pre- or post-Alonzo) and decodes accordingly.

                 Params:


                           value ([]byte): A CBOR-encoded byte slice representing the TransactionOutput.

                 Returns:
                           error: An error if deserialization fails.
*/
func (txo *TransactionOutput) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var x any
        _ = cbor.Unmarshal(value, &amp;x)
        if reflect.TypeOf(x).String() == "[]interface {}" </span><span class="cov8" title="1">{
                txo.IsPostAlonzo = false
                err := cbor.Unmarshal(value, &amp;txo.PreAlonzo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        } else<span class="cov8" title="1"> {
                txo.IsPostAlonzo = true
                err := cbor.Unmarshal(value, &amp;txo.PostAlonzo)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

        MarshalCBOR serializes the TransactionOutput into a CBOR-encoded byte slice, which
        encodes the output based on whether it is pre- or post- Alonzo.

        Returns:


        []byte: A CBOR-encoded byte slice representing the TransactionOutput.
        error: An error if serialization fails.
*/
func (txo *TransactionOutput) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if txo.IsPostAlonzo </span><span class="cov8" title="1">{
                return cbor.Marshal(txo.PostAlonzo)
        }</span> else<span class="cov8" title="1"> {
                return cbor.Marshal(txo.PreAlonzo)
        }</span>
}

/*
*

                SetAmount sets the amount of the TransactionOutput. In case of a post-Alonzo output,
                the amount is set directly, otherwise the amount is set.

                 Params:
                          amount Value.Value: The amount to set.
*/
func (txo *TransactionOutput) SetAmount(amount Value.Value) <span class="cov8" title="1">{
        if txo.IsPostAlonzo </span><span class="cov8" title="1">{
                txo.PostAlonzo.Amount = amount.ToAlonzoValue()
        }</span> else<span class="cov8" title="1"> {
                txo.PreAlonzo.Amount = amount
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package TransactionWitnessSet

import (
        "github.com/Salvionied/apollo/serialization/NativeScript"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/VerificationKeyWitness"
        "github.com/fxamacker/cbor/v2"
)

type normaltws struct {
        VkeyWitnesses      []VerificationKeyWitness.VerificationKeyWitness `cbor:"0,keyasint,omitempty"`
        NativeScripts      []NativeScript.NativeScript                     `cbor:"1,keyasint,omitempty"`
        BootstrapWitnesses []any                                           `cbor:"2,keyasint,omitempty"`
        PlutusV1Script     []PlutusData.PlutusV1Script                     `cbor:"3,keyasint,omitempty"`
        PlutusV2Script     []PlutusData.PlutusV2Script                     `cbor:"6,keyasint,omitempty"`
        PlutusV3Script     []PlutusData.PlutusV3Script                     `cbor:"7,keyasint,omitempty"`
        PlutusData         *PlutusData.PlutusIndefArray                    `cbor:"4,keyasint,omitempty"`
        Redeemer           []Redeemer.Redeemer                             `cbor:"5,keyasint,omitempty"`
}
type TransactionWitnessSet struct {
        VkeyWitnesses      []VerificationKeyWitness.VerificationKeyWitness `cbor:"0,keyasint,omitempty"`
        NativeScripts      []NativeScript.NativeScript                     `cbor:"1,keyasint,omitempty"`
        BootstrapWitnesses []any                                           `cbor:"2,keyasint,omitempty"`
        PlutusV1Script     []PlutusData.PlutusV1Script                     `cbor:"3,keyasint,omitempty"`
        PlutusV2Script     []PlutusData.PlutusV2Script                     `cbor:"6,keyasint,omitempty"`
        PlutusV3Script     []PlutusData.PlutusV3Script                     `cbor:"7,keyasint,omitempty"`
        PlutusData         PlutusData.PlutusIndefArray                     `cbor:"4,keyasint,omitempty"`
        Redeemer           []Redeemer.Redeemer                             `cbor:"5,keyasint,omitempty"`
}

type WithRedeemerNoScripts struct {
        VkeyWitnesses      []VerificationKeyWitness.VerificationKeyWitness `cbor:"0,keyasint,omitempty"`
        NativeScripts      []NativeScript.NativeScript                     `cbor:"1,keyasint,omitempty"`
        BootstrapWitnesses []any                                           `cbor:"2,keyasint,omitempty"`
        PlutusV1Script     []PlutusData.PlutusV1Script                     `cbor:"3,keyasint,"`
        PlutusV2Script     []PlutusData.PlutusV2Script                     `cbor:"6,keyasint,omitempty"`
        PlutusV3Script     []PlutusData.PlutusV3Script                     `cbor:"7,keyasint,omitempty"`
        PlutusData         *PlutusData.PlutusIndefArray                    `cbor:"4,keyasint,omitempty"`
        Redeemer           []Redeemer.Redeemer                             `cbor:"5,keyasint,omitempty"`
}

/*
*

        MarshalCBOR serializes the TransactionWitnessSet to a CBOR byte slice.

        Returns:
                []byte: The CBOR-serialized TransactionWitnessSet.
                error: An error if serialization fails.
*/
func (tws *TransactionWitnessSet) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        res := normaltws{}
        if len(tws.VkeyWitnesses) &gt; 0 </span><span class="cov0" title="0">{
                res.VkeyWitnesses = tws.VkeyWitnesses
        }</span>
        <span class="cov8" title="1">if len(tws.NativeScripts) &gt; 0 </span><span class="cov0" title="0">{
                res.NativeScripts = tws.NativeScripts
        }</span>
        <span class="cov8" title="1">if len(tws.BootstrapWitnesses) &gt; 0 </span><span class="cov0" title="0">{
                res.BootstrapWitnesses = tws.BootstrapWitnesses
        }</span>
        <span class="cov8" title="1">if len(tws.PlutusV1Script) &gt; 0 </span><span class="cov0" title="0">{
                res.PlutusV1Script = tws.PlutusV1Script
        }</span>
        <span class="cov8" title="1">if len(tws.PlutusV2Script) &gt; 0 </span><span class="cov0" title="0">{
                res.PlutusV2Script = tws.PlutusV2Script
        }</span>
        <span class="cov8" title="1">if len(tws.PlutusV3Script) &gt; 0 </span><span class="cov0" title="0">{
                res.PlutusV3Script = tws.PlutusV3Script
        }</span>
        <span class="cov8" title="1">if len(tws.PlutusData) &gt; 0 </span><span class="cov8" title="1">{
                res.PlutusData = &amp;tws.PlutusData
        }</span>
        <span class="cov8" title="1">if len(tws.Redeemer) &gt; 0 </span><span class="cov0" title="0">{
                res.Redeemer = tws.Redeemer
        }</span>
        <span class="cov8" title="1">return cbor.Marshal(res)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package UTxO

import (
        "encoding/hex"
        "fmt"

        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
)

type Container[T any] interface {
        EqualTo(other T) bool
}

type UTxO struct {
        _      struct{} `cbor:",toarray"`
        Input  TransactionInput.TransactionInput
        Output TransactionOutput.TransactionOutput
}

/*
*

        GetKey returns a unique key for the UTxO through its
        transaction ID and index.

        Returns:
                string: The unique key representing the UTxO.
*/
func (u UTxO) GetKey() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "%s:%d",
                hex.EncodeToString(u.Input.TransactionId),
                u.Input.Index,
        )
}</span>

/*
*

        Clone creates a deep copy of the UTxO instance.

        Returns:
                UTxO: A new UTxO instance.
*/
func (u UTxO) Clone() UTxO <span class="cov8" title="1">{
        return UTxO{
                Input:  u.Input.Clone(),
                Output: u.Output.Clone(),
        }
}</span>

/*
*

        EqualTo checks if the UTxO is equal to another object.

        Params:
                other interface{}: The object to compare with the UTxO.

        Returns:
                bool: True if the UTxO is equal to the proved object, false otherwise.
*/
func (u UTxO) EqualTo(other any) bool <span class="cov8" title="1">{
        utxo := other.(UTxO)
        return u.Input.EqualTo(utxo.Input) &amp;&amp; u.Output.EqualTo(utxo.Output)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package Value

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"

        "github.com/Salvionied/apollo/serialization/Amount"
        "github.com/Salvionied/apollo/serialization/MultiAsset"

        "github.com/fxamacker/cbor/v2"
)

type Value struct {
        Am        Amount.Amount
        Coin      int64
        HasAssets bool
}

type AlonzoValue struct {
        Am        Amount.AlonzoAmount
        Coin      int64
        HasAssets bool
}

/*
*

        UnmarshalCBOR deserializes CBOr-encoded data into an AlonzoValue.

        Params:
                value ([]byte): The CBOR-encoded data to be deserialized.

        Returns:
                error: An error if deserialization fails.
*/
func (val *AlonzoValue) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var rec any
        _ = cbor.Unmarshal(value, &amp;rec)
        if reflect.ValueOf(rec).Type().String() == "uint64" </span><span class="cov8" title="1">{
                ok, _ := rec.(uint64)
                val.Coin = int64(ok)
        }</span> else<span class="cov8" title="1"> {
                am := Amount.Amount{}
                err := cbor.Unmarshal(value, &amp;am)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">val.Am = am.ToAlonzo()
                val.HasAssets = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

        MarshalCBOR serializes the AlonzoValue into an CBOr-encoded data.

        Returns:
                []byte: The CBOR-encoded data.
                error: An error if deserialization fails.
*/
func (alVal *AlonzoValue) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if alVal.HasAssets </span><span class="cov8" title="1">{
                if alVal.Am.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">em, _ := cbor.CanonicalEncOptions().EncMode()
                return em.Marshal(alVal.Am)</span>
        } else<span class="cov8" title="1"> {
                if alVal.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">return cbor.Marshal(alVal.Coin)</span>
        }
}

/*
*

        Clone creates a copy of the AlonzoValue, including its assets.

        Returns:
                AlonzoValue: A copy of the AlonzoValue.
*/
func (alVal AlonzoValue) Clone() AlonzoValue <span class="cov8" title="1">{
        if alVal.HasAssets </span><span class="cov8" title="1">{
                return AlonzoValue{
                        Am:        alVal.Am.Clone(),
                        Coin:      alVal.Coin,
                        HasAssets: alVal.HasAssets,
                }
        }</span>
        <span class="cov8" title="1">return AlonzoValue{
                Coin:      alVal.Coin,
                HasAssets: alVal.HasAssets,
        }</span>
}

/*
*

        ToAlonzoValue converts a Value object to an AlonzoValue, preserving its attributes.

        Returns:
                AlonzoValue: An AlonzoValue converted from a Value object.
*/
func (val Value) ToAlonzoValue() AlonzoValue <span class="cov8" title="1">{
        return AlonzoValue{
                Am:        val.Am.ToAlonzo(),
                Coin:      val.Coin,
                HasAssets: val.HasAssets,
        }
}</span>

/*
*

        ToValue converts an AlonzoValue to a Value object, preserving its attributes.

        Returns:
                Value: A Value object converted from an AlonzoValue.
*/
func (alVal AlonzoValue) ToValue() Value <span class="cov8" title="1">{
        return Value{
                Am:        alVal.Am.ToShelley(),
                Coin:      alVal.Coin,
                HasAssets: alVal.HasAssets,
        }
}</span>

/*
*

        RemoveZeroAssets removes assets with zero values from a Value.

        Returns:
                Value: A Value without zero assets.
*/
func (val Value) RemoveZeroAssets() Value <span class="cov8" title="1">{
        res := val.Clone()
        if res.HasAssets </span><span class="cov8" title="1">{
                res.Am = res.Am.RemoveZeroAssets()
        }</span>
        <span class="cov8" title="1">return res</span>
}

/*
*

        Clone creates a copy of the Value, including its assets.

        Returns:
                Value: A copy of the Value.
*/
func (val Value) Clone() Value <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                return Value{
                        Am:        val.Am.Clone(),
                        Coin:      val.Coin,
                        HasAssets: val.HasAssets,
                }
        }</span> else<span class="cov8" title="1"> {
                return Value{
                        Coin:      val.Coin,
                        HasAssets: val.HasAssets,
                }
        }</span>
}

/*
*

        AddAssets adds MultiAsset assets to a Value.

        Params:


        other (MultiAsset.MultiAsset[int64]): the MultiAssets assets to be added.
*/
func (val *Value) AddAssets(other MultiAsset.MultiAsset[int64]) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.HasAssets = true
                val.Am.Coin = val.Coin
                val.Coin = 0
                val.Am.Value = other
        }</span> else<span class="cov8" title="1"> {
                val.Am.Value = val.Am.Value.Add(other)
        }</span>
}

/*
*

        SimpleValue creates a Value object with a specified coin value and a MultiAssets.

        Params:
                coin (int64): The coin value.
                assets (MultiAsset.MultiAsset[int64]): the assets.

        Returns:
                Value: A Value object.
*/
func SimpleValue(coin int64, assets MultiAsset.MultiAsset[int64]) Value <span class="cov8" title="1">{
        if len(assets) == 0 </span><span class="cov8" title="1">{
                return Value{
                        Coin: coin,
                }
        }</span>
        <span class="cov8" title="1">return Value{
                Am: Amount.Amount{
                        Coin:  coin,
                        Value: assets,
                },
                HasAssets: true,
        }</span>
}

/*
*

        SubLovelace subtracts a specified amount of Lovelace (coin) from the Value.
        In case that there aren't any assets, then it subtracts from the Coin field,
        otherwise from the AlonzoAmount's Coin field.

        Params:
                amount (int64): The amount of Lovelace (coin) to subtract.
*/
func (val *Value) SubLovelace(amount int64) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.Coin -= amount
        }</span> else<span class="cov8" title="1"> {
                val.Am.Coin -= amount
        }</span>
}

/*
*

        AddLovelace adds a specified amount of Lovelace (coin) from the Value.
        In case that there aren't any assets, then it adds to the Coin field,
        otherwise to the AlonzoAmount's Coin field.

        Params:
                amount (int64): The amount of Lovelace (coin) to add.
*/
func (val *Value) AddLovelace(amount int64) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.Coin += amount
        }</span> else<span class="cov8" title="1"> {
                val.Am.Coin += amount
        }</span>
}

/*
*

        SetLovelace sets a specified amount of Lovelace (coin) in the Value.
        In case that there aren't any assets, then it sets the Coin field,
        otherwise it sets the AlonzoAmount's Coin field.

        Params:
                amount (int64): The amount of Lovelace (coin) to set.
*/
func (val *Value) SetLovelace(amount int64) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.Coin = amount
        }</span> else<span class="cov8" title="1"> {
                val.Am.Coin = amount
        }</span>
}

/*
*

        SetMultiAsset sets the MultiAsset in the Value.

        Params:
                amount (MultiAsset.MultiAsset[int64]): The MultiAsset assets to set.
*/
func (val *Value) SetMultiAsset(amount MultiAsset.MultiAsset[int64]) <span class="cov8" title="1">{
        if !val.HasAssets </span><span class="cov8" title="1">{
                val.HasAssets = true
                val.Am.Coin = val.Coin
                val.Coin = 0
        }</span>
        <span class="cov8" title="1">val.Am.Value = amount</span>
}

/*
*

        GetCoin returns the amount of Lovelace (coin) in the Value.

        Returns:
                int64: The amount of Lovelace (coin).
*/
func (val Value) GetCoin() int64 <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                return val.Am.Coin
        }</span>
        <span class="cov8" title="1">return val.Coin</span>
}

/*
*

        GetAssets returns the MultiAsset assets in the Value.

        Returns:
                MultiAsset.MultiAsset[int64]: The MultiAsset assets.
*/
func (val Value) GetAssets() MultiAsset.MultiAsset[int64] <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                return val.Am.Value
        }</span>
        <span class="cov8" title="1">return nil</span>
}

/*
*

        Add function adds another Value to the current Value.

        Params:
                other (Value): The Value to add to the current Value.

        Returns:
                Value: The resulting Value after the addition.
*/
func (val Value) Add(other Value) Value <span class="cov8" title="1">{
        res := val.Clone()
        if other.HasAssets </span><span class="cov8" title="1">{
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am = res.Am.Add(other.Am)
                }</span> else<span class="cov0" title="0"> {
                        res.Am.Coin = res.Coin + other.Am.Coin
                        res.HasAssets = true
                        res.Am.Value = other.Am.Value
                }</span>
        } else<span class="cov8" title="1"> {
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am.Coin += other.Coin
                }</span> else<span class="cov8" title="1"> {
                        res.Coin += other.Coin
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
*

        Sub function subtracts another Value to the current Value.

        Params:
                other (Value): The Value to subtract to the current Value.

        Returns:
                Value: The resulting Value after the subtraction.
*/
func (val Value) Sub(other Value) Value <span class="cov8" title="1">{
        res := val.Clone()
        if other.HasAssets </span><span class="cov8" title="1">{
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am = res.Am.Sub(other.Am)
                }</span> else<span class="cov0" title="0"> {
                        res.Coin -= other.Am.Coin
                }</span>
        } else<span class="cov8" title="1"> {
                if res.HasAssets </span><span class="cov8" title="1">{
                        res.Am.Coin -= other.Coin
                }</span> else<span class="cov8" title="1"> {
                        res.Coin -= other.Coin
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

/*
*

        Less checks if the current Value is less than another Value.

        Params:
                other (Value): The Value to compare.

        Returns:


        bool: True if the current value is less than the other Value, false otherwise.
*/
func (val Value) Less(other Value) bool <span class="cov8" title="1">{
        return val.GetCoin() &lt;= other.GetCoin() &amp;&amp;
                val.GetAssets().Less(other.GetAssets())
}</span>

/*
*

        Equal checks if the current Value is equal to another Value.

        Params:
                other (Value): The Value to compare.

        Returns:


        bool: True if the current value is equal to the other Value, false otherwise.
*/
func (val Value) Equal(other Value) bool <span class="cov8" title="1">{
        if val.HasAssets != other.HasAssets </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if val.HasAssets </span><span class="cov8" title="1">{
                return val.Coin == other.Coin &amp;&amp; val.Am.Equal(other.Am)
        }</span> else<span class="cov8" title="1"> {
                return val.Coin == other.Coin
        }</span>
}

/*
*

        LessOrEqual checks if the current Value is less than or equal to another Value.

        Params:
                other (Value): The Value to compare.

        Returns:


        bool: True if the current value is less than or equal to the other Value, false otherwise.
*/
func (val Value) LessOrEqual(other Value) bool <span class="cov8" title="1">{
        return val.Equal(other) || val.Less(other)
}</span>

/*
*

        Greater checks if the current Value is greater than another Value.

        Params:
                other (Value): The Value to compare.

        Returns:


        bool: True if the current value is greater than the other Value, false otherwise.
*/
func (val Value) Greater(other Value) bool <span class="cov8" title="1">{
        return val.GetCoin() &gt;= other.GetCoin() &amp;&amp;
                val.GetAssets().Greater(other.GetAssets())

}</span>

/*
*

        GreaterOrEqual checks if the current Value is greater than or equal to another Value.

        Params:
                other (Value): The Value to compare.

        Returns:


        bool: True if the current value is greater than or equal to the other Value, false otherwise.
*/
func (val Value) GreaterOrEqual(other Value) bool <span class="cov8" title="1">{
        return val.Greater(other) || val.Equal(other)
}</span>

/*
*

        String reutnrs a string representation of the Value.

        Returns:
                string: The string representation of the Value.
*/
func (val Value) String() string <span class="cov0" title="0">{
        if val.HasAssets </span><span class="cov0" title="0">{
                return fmt.Sprint(val.Am)
        }</span> else<span class="cov0" title="0"> {
                return strconv.FormatInt(val.Coin, 10)
        }</span>
}

/*
*

        UnmarshalCBOR unmarshals a CBOR-encoded byte slice into the Value,


                which decoed either a uint64 into the Coin field or a CBOR-encoded Amount
                into the AlonzoAmount field.

                Params:
                    value ([]byte): The CBOR-encoded byte slice to unmarshal.

                  Returns:
                    error: An error if unmarshaling fails.
*/
func (val *Value) UnmarshalCBOR(value []byte) error <span class="cov8" title="1">{
        var rec any
        _ = cbor.Unmarshal(value, &amp;rec)
        if reflect.ValueOf(rec).Type().String() == "uint64" </span><span class="cov8" title="1">{
                ok, _ := rec.(uint64)
                val.Coin = int64(ok)
        }</span> else<span class="cov0" title="0"> {
                am := Amount.Amount{}
                err := cbor.Unmarshal(value, &amp;am)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">val.Am = am
                val.HasAssets = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

/*
*

        MarshalCBOR marshals the Value into a CBOR-encoded byte slice.
        If the Value has assets, then it encodes the AlonzoAmount using CBOR,
        otherwise it encodes the Coin field directly.

        Returns:
                []byte: The CBOR-encoded byte slice.
                error: An error if marshaling fails.
*/
func (val *Value) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        if val.HasAssets </span><span class="cov8" title="1">{
                if val.Am.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">em, _ := cbor.CanonicalEncOptions().EncMode()
                return em.Marshal(val.Am)</span>
        } else<span class="cov8" title="1"> {
                if val.Coin &lt; 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid coin value")
                }</span>
                <span class="cov8" title="1">return cbor.Marshal(val.Coin)</span>
        }
}

/*
*

                 PureLovelaceValue creates a Value with only a specified amount
                of Lovelace (coin) and no assets.

                Params:
                        coin (int64): The amount of Lovelace (coin) to set in the Value.

                Returns:


        Value: The Value with the specified amount of Lovelace and no assets.
*/
func PureLovelaceValue(coin int64) Value <span class="cov8" title="1">{
        return Value{Coin: coin, HasAssets: false}
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package Withdrawal

import (
        "fmt"
)

type Withdrawal map[[29]byte]int

func New() Withdrawal <span class="cov0" title="0">{
        m := make(map[[29]byte]int)
        return m
}</span>

func (w *Withdrawal) Add(stakeAddress [29]byte, amount int) error <span class="cov0" title="0">{
        _, exists := (*w)[stakeAddress]
        if exists </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "Withdrawal.Add: key already exists in map: %v",
                        stakeAddress,
                )
        }</span>
        <span class="cov0" title="0">(*w)[stakeAddress] = amount
        return nil</span>
}

func (w *Withdrawal) Size() int <span class="cov0" title="0">{
        return len(*w)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package serialization

import (
        "encoding/hex"
        "errors"
        "fmt"
        "math"
        "reflect"
        "strconv"

        "github.com/fxamacker/cbor/v2"
        "golang.org/x/crypto/blake2b"
)

/*
*
Blake2bHash computes the Blake2b hash of the given data.

Params:

        data ([]byte): The data to hash.

Returns:

        []byte: The Blake2b hash of the data.
        error: An error if the hashing fails.
*/
func Blake2bHash(data []byte) ([]byte, error) <span class="cov0" title="0">{
        hash, err := blake2b.New(32, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, err = hash.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return hash.Sum(nil), nil</span>
}

type ConstrainedBytes struct {
        Payload []byte
}

/*
*

        UnmarshalCBOR deserializes a CBOR-encoded byte slice into ConstrainedBytes.

        Params:
                data ([]byte): The CBOR-encoded byte slice.

        Returns:
                error: An error if deserialization fails.
*/
func (cb *ConstrainedBytes) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        err := cbor.Unmarshal(data, &amp;cb.Payload)
        return err
}</span>

/*
*

        MarshalCBOR serializes ConstrainedBytes into a CBOR-encoded byte slice.

        Returns:
                []byte: A CBOR-encoded byte slice representing the ConstrainedBytes.
                error: An error if serialization fails.
*/
func (cb *ConstrainedBytes) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        return cbor.Marshal(cb.Payload)
}</span>

const VERIFICATION_KEY_HASH_SIZE = 28

type TransactionId ConstrainedBytes
type ScriptHash [28]byte

/*
*

        Bytes returns the underlying byte slice of a ScriptHash.

        Returns:
                []byte: The byte slice representation of the ScriptHash.
*/
func (sh *ScriptHash) Bytes() []byte <span class="cov0" title="0">{
        return sh[:]
}</span>

type DatumHash ConstrainedBytes

/*
*

        Equal checks if two DatumHash instances are equal.

        Params:
                other (DatumHash): The other DatumHash to compare to.

        Returns:
                bool: True if the DatumHashes are equal, false otherwise.
*/
func (dh *DatumHash) Equal(other DatumHash) bool <span class="cov0" title="0">{
        return reflect.DeepEqual(dh.Payload, other.Payload)
}</span>

type ScriptDataHash ConstrainedBytes

type PubKeyHash [28]byte
type CustomBytes struct {
        Value string
        tp    string
}

func (cb *CustomBytes) Int() (int, error) <span class="cov0" title="0">{
        if cb.tp == "uint64" </span><span class="cov0" title="0">{
                value, err := strconv.ParseInt(cb.Value, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">if value &lt; math.MinInt || value &gt; math.MaxInt </span><span class="cov0" title="0">{
                        return 0, errors.New("value out of int range")
                }</span>
                <span class="cov0" title="0">return int(value), nil</span>
        }
        <span class="cov0" title="0">return 0, errors.New("not int")</span>
}

func (cb *CustomBytes) IsInt() bool <span class="cov0" title="0">{
        return cb.tp == "uint64"
}</span>

func NewCustomBytes(value string) CustomBytes <span class="cov0" title="0">{

        return CustomBytes{Value: hex.EncodeToString([]byte(value))}
}</span>

func NewCustomBytesInt(value int) CustomBytes <span class="cov0" title="0">{
        return CustomBytes{Value: strconv.Itoa(value), tp: "uint64"}
}</span>

/*
*

        String returns the Value's string representation of a CustomBytes.

        Returns:
                string: The Value's string representation of CustomBytes.
*/
func (cb *CustomBytes) String() string <span class="cov0" title="0">{
        if cb.tp == "uint64" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Int(%s)", cb.Value)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Bytes(%s)", cb.Value)</span>
}
func (cb *CustomBytes) HexString() string <span class="cov0" title="0">{
        return cb.Value
}</span>

/*
*

        MarshalCBOR serializes CustomBytes into a CBOR-encoded byte slice.

        Returns:
                []byte: A CBOR-encoded byte slice representing the CustomBytes.
                error: An error if serialization fails.
*/
func (cb *CustomBytes) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        // if cb.Value == "40" || cb.Value == "625b5d" {
        //         return cbor.Marshal(make([]byte, 0))
        // }
        if cb.tp == "string" </span><span class="cov0" title="0">{
                if cb.Value == "[]" </span><span class="cov0" title="0">{
                        return cbor.Marshal(make([]byte, 0))
                }</span>
                <span class="cov0" title="0">return cbor.Marshal(cb.Value)</span>
        }
        <span class="cov0" title="0">if cb.tp == "uint64" </span><span class="cov0" title="0">{
                value, err := strconv.ParseInt(cb.Value, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return cbor.Marshal(value)</span>
        }
        <span class="cov0" title="0">res, err := hex.DecodeString(cb.Value)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // if len(res) == 0 {
        //         return cbor.Marshal(make([]byte, 0))
        // }
        <span class="cov0" title="0">return cbor.Marshal(res)</span>

}

/*
*

        UnmarshalCBOR deserializes a CBOR-encoded byte slice into CustomBytes.

        Params:
                value ([]byte): The CBOR-encoded byte slice.

        Returns:
                error: An error if deserialization fails.
*/
func (cb *CustomBytes) UnmarshalCBOR(value []byte) error <span class="cov0" title="0">{
        var res any
        err := cbor.Unmarshal(value, &amp;res)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">switch res := res.(type) </span>{
        case []byte:<span class="cov0" title="0">
                cb.tp = "bytes"
                cb.Value = hex.EncodeToString(res)</span>
        case string:<span class="cov0" title="0">
                cb.tp = "string"
                cb.Value = res</span>
        case uint64:<span class="cov0" title="0">
                cb.tp = "uint64"
                cb.Value = strconv.FormatUint(res, 10)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid type for customBytes")</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package testutils

import (
        "fmt"

        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Asset"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/Policy"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/Value"
)

var TESTADDRESS = "addr_test1vrm9x2zsux7va6w892g38tvchnzahvcd9tykqf3ygnmwtaqyfg52x"

func InitUtxos() []UTxO.UTxO <span class="cov0" title="0">{
        utxos := make([]UTxO.UTxO, 0)
        for i := range 10 </span><span class="cov0" title="0">{
                tx_in := TransactionInput.TransactionInput{
                        TransactionId: make([]byte, 32),
                        Index:         i,
                }

                Addr, _ := Address.DecodeAddress(TESTADDRESS)
                policy := Policy.PolicyId{
                        Value: "00000000000000000000000000000000000000000000000000000000",
                }
                asset_name := AssetName.NewAssetNameFromString(
                        fmt.Sprintf("token%d", i),
                )
                Asset := Asset.Asset[int64]{
                        asset_name: int64((i + 1) * 100)}
                assets := MultiAsset.MultiAsset[int64]{policy: Asset}
                value := Value.SimpleValue(int64((i+1)*1000000),
                        assets)
                tx_out := TransactionOutput.SimpleTransactionOutput(
                        Addr, value)
                utxos = append(utxos, UTxO.UTxO{Input: tx_in, Output: tx_out})
        }</span>
        <span class="cov0" title="0">return utxos</span>
}
func InitUtxosDifferentiated() []UTxO.UTxO <span class="cov0" title="0">{
        utxos := make([]UTxO.UTxO, 0)
        for i := range 10 </span><span class="cov0" title="0">{
                tx_in := TransactionInput.TransactionInput{
                        TransactionId: make([]byte, 32),
                        Index:         i,
                }

                Addr, _ := Address.DecodeAddress(TESTADDRESS)
                policy := Policy.PolicyId{
                        Value: "00000000000000000000000000000000000000000000000000000000",
                }
                singleasset := Asset.Asset[int64]{}
                for j := range i </span><span class="cov0" title="0">{
                        asset_name := AssetName.NewAssetNameFromString(
                                fmt.Sprintf("token%d", j),
                        )
                        singleasset[asset_name] = int64((i + 1) * 100)
                }</span>

                <span class="cov0" title="0">assets := MultiAsset.MultiAsset[int64]{policy: singleasset}
                value := Value.SimpleValue(int64((i+1)*1000000),
                        assets)
                tx_out := TransactionOutput.SimpleTransactionOutput(
                        Addr, value)
                utxos = append(utxos, UTxO.UTxO{Input: tx_in, Output: tx_out})</span>
        }
        <span class="cov0" title="0">return utxos</span>
}

func InitUtxosCongested() []UTxO.UTxO <span class="cov0" title="0">{
        utxos := make([]UTxO.UTxO, 0)
        for i := range 100 </span><span class="cov0" title="0">{
                tx_in := TransactionInput.TransactionInput{
                        TransactionId: make([]byte, 32),
                        Index:         i,
                }

                Addr, _ := Address.DecodeAddress(TESTADDRESS)
                policy := Policy.PolicyId{
                        Value: fmt.Sprintf("0000000000000000000000000000000000000000000000000000000%d", i)[:56],
                }
                singleasset := Asset.Asset[int64]{}
                for j := range i </span><span class="cov0" title="0">{
                        asset_name := AssetName.NewAssetNameFromString(
                                fmt.Sprintf("token%d", j),
                        )
                        singleasset[asset_name] = int64((i + 1) * 100)
                }</span>

                <span class="cov0" title="0">assets := MultiAsset.MultiAsset[int64]{policy: singleasset}
                value := Value.SimpleValue(int64(2000000),
                        assets)
                tx_out := TransactionOutput.SimpleTransactionOutput(
                        Addr, value)
                utxos = append(utxos, UTxO.UTxO{Input: tx_in, Output: tx_out})</span>
        }
        <span class="cov0" title="0">return utxos</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package Base

import (
        "encoding/hex"
        "strconv"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Amount"
        "github.com/Salvionied/apollo/serialization/Asset"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Policy"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/Value"

        "github.com/fxamacker/cbor/v2"
)

type GenesisParameters struct {
        ActiveSlotsCoefficient float32 `json:"active_slots_coefficient"`
        UpdateQuorum           int     `json:"update_quorum"`
        MaxLovelaceSupply      string  `json:"max_lovelace_supply"`
        NetworkMagic           int     `json:"network_magic"`
        EpochLength            int     `json:"epoch_length"`
        SystemStart            int     `json:"system_start"`
        SlotsPerKesPeriod      int     `json:"slots_per_kes_period"`
        SlotLength             int     `json:"slot_length"`
        MaxKesEvolutions       int     `json:"max_kes_evolutions"`
        SecurityParam          int     `json:"security_param"`
}

type ProtocolParameters struct {
        MinFeeConstant                   int64              `json:"min_fee_b"`
        MinFeeCoefficient                int64              `json:"min_fee_a"`
        MaxBlockSize                     int                `json:"max_block_size"`
        MaxTxSize                        int                `json:"max_tx_size"`
        MaxBlockHeaderSize               int                `json:"max_block_header_size"`
        KeyDeposits                      string             `json:"key_deposit"`
        PoolDeposits                     string             `json:"pool_deposit"`
        PooolInfluence                   float32            `json:"a0"`
        MonetaryExpansion                float32            `json:"rho"`
        TreasuryExpansion                float32            `json:"tau"`
        DecentralizationParam            float32            `json:"decentralisation_param"`
        ExtraEntropy                     string             `json:"extra_entropy"`
        ProtocolMajorVersion             int                `json:"protocol_major_ver"`
        ProtocolMinorVersion             int                `json:"protocol_minor_ver"`
        MinUtxo                          string             `json:"min_utxo"`
        MinPoolCost                      string             `json:"min_pool_cost"`
        PriceMem                         float32            `json:"price_mem"`
        PriceStep                        float32            `json:"price_step"`
        MaxTxExMem                       string             `json:"max_tx_ex_mem"`
        MaxTxExSteps                     string             `json:"max_tx_ex_steps"`
        MaxBlockExMem                    string             `json:"max_block_ex_mem"`
        MaxBlockExSteps                  string             `json:"max_block_ex_steps"`
        MaxValSize                       string             `json:"max_val_size"`
        CollateralPercent                int                `json:"collateral_percent"`
        MaxCollateralInuts               int                `json:"max_collateral_inputs"`
        CoinsPerUtxoWord                 string             `json:"coins_per_utxo_word"`
        CoinsPerUtxoByte                 string             `json:"coins_per_utxo_byte"`
        CostModels                       map[string][]int64 `json:"cost_models"`
        MaximumReferenceScriptsSize      int                `json:"maximum_reference_scripts_size"`
        MinFeeReferenceScriptsRange      int                `json:"min_fee_reference_scripts_range"`
        MinFeeReferenceScriptsBase       int                `json:"min_fee_reference_scripts_base"`
        MinFeeReferenceScriptsMultiplier int                `json:"min_fee_reference_scripts_multiplier"`
}

func (p ProtocolParameters) GetCoinsPerUtxoByte() int <span class="cov0" title="0">{
        return 4310
}</span>

type Input struct {
        Address             string          `json:"address"`
        Amount              []AddressAmount `json:"amount"`
        OutputIndex         int             `json:"output_index"`
        DataHash            string          `json:"data_hash"`
        InlineDatum         string          `json:"inline_datum"`
        ReferenceScriptHash string          `json:"reference_script_hash"`
        Collateral          bool            `json:"collateral"`
        Reference           bool            `json:"reference"`
}

type Output struct {
        Address             string          `json:"address"`
        Amount              []AddressAmount `json:"amount"`
        OutputIndex         int             `json:"output_index"`
        DataHash            string          `json:"data_hash"`
        InlineDatum         string          `json:"inline_datum"`
        Collateral          bool            `json:"collateral"`
        ReferenceScriptHash string          `json:"reference_script_hash"`
}

func (o Output) ToUTxO(txHash string) *UTxO.UTxO <span class="cov0" title="0">{
        txOut := o.ToTransactionOutput()
        decodedTxHash, _ := hex.DecodeString(txHash)
        utxo := UTxO.UTxO{
                Input: TransactionInput.TransactionInput{
                        TransactionId: decodedTxHash,
                        Index:         o.OutputIndex,
                },
                Output: txOut,
        }
        return &amp;utxo
}</span>

func (o Output) ToTransactionOutput() TransactionOutput.TransactionOutput <span class="cov0" title="0">{
        address, _ := Address.DecodeAddress(o.Address)
        amount := o.Amount
        lovelace_amount := 0
        multi_assets := MultiAsset.MultiAsset[int64]{}
        for _, item := range amount </span><span class="cov0" title="0">{
                if item.Unit == "lovelace" </span><span class="cov0" title="0">{
                        amount, _ := strconv.Atoi(item.Quantity)
                        lovelace_amount += amount
                }</span> else<span class="cov0" title="0"> {
                        asset_quantity, _ := strconv.ParseInt(item.Quantity, 10, 64)

                        policy_id := Policy.PolicyId{Value: item.Unit[:56]}
                        asset_name := *AssetName.NewAssetNameFromHexString(item.Unit[56:])
                        _, ok := multi_assets[policy_id]
                        if !ok </span><span class="cov0" title="0">{
                                multi_assets[policy_id] = Asset.Asset[int64]{}
                        }</span>
                        <span class="cov0" title="0">multi_assets[policy_id][asset_name] = int64(asset_quantity)</span>
                }
        }
        <span class="cov0" title="0">var final_amount Value.Value
        if len(multi_assets) &gt; 0 </span><span class="cov0" title="0">{
                final_amount = Value.Value{
                        Am: Amount.Amount{
                                Coin:  int64(lovelace_amount),
                                Value: multi_assets,
                        },
                        HasAssets: true,
                }
        }</span> else<span class="cov0" title="0"> {
                final_amount = Value.Value{Coin: int64(lovelace_amount), HasAssets: false}
        }</span>
        <span class="cov0" title="0">datum_hash := serialization.DatumHash{}
        if o.DataHash != "" &amp;&amp; o.InlineDatum == "" </span><span class="cov0" title="0">{
                decoded_hash, _ := hex.DecodeString(o.DataHash)

                datum_hash = serialization.DatumHash{Payload: decoded_hash}
        }</span>
        <span class="cov0" title="0">datum := PlutusData.PlutusData{}
        if o.InlineDatum != "" </span><span class="cov0" title="0">{
                decoded, _ := hex.DecodeString(o.InlineDatum)

                var x PlutusData.PlutusData
                // TODO: error check correctly
                _ = cbor.Unmarshal(decoded, &amp;x)

                datum = x
                tx_out := TransactionOutput.TransactionOutput{
                        PostAlonzo: TransactionOutput.TransactionOutputAlonzo{
                                Address: address,
                                Amount:  final_amount.ToAlonzoValue(),
                                Datum: &amp;PlutusData.DatumOption{
                                        Inline:    &amp;datum,
                                        DatumType: 1,
                                },
                        },
                        IsPostAlonzo: true,
                }
                return tx_out
        }</span>
        <span class="cov0" title="0">tx_out := TransactionOutput.TransactionOutput{
                PreAlonzo: TransactionOutput.TransactionOutputShelley{
                        Address:   address,
                        Amount:    final_amount,
                        DatumHash: datum_hash,
                        HasDatum:  len(datum_hash.Payload) &gt; 0},
                IsPostAlonzo: false,
        }
        return tx_out</span>
}

type TxUtxos struct {
        TxHash  string   `json:"hash"`
        Inputs  []Input  `json:"inputs"`
        Outputs []Output `json:"outputs"`
}

type ChainContext interface {
        GetProtocolParams() (ProtocolParameters, error)
        GetGenesisParams() (GenesisParameters, error)
        Network() int
        Epoch() (int, error)
        MaxTxFee() (int, error)
        LastBlockSlot() (int, error)
        Utxos(address Address.Address) ([]UTxO.UTxO, error)
        SubmitTx(Transaction.Transaction) (serialization.TransactionId, error)
        EvaluateTx([]uint8) (map[string]Redeemer.ExecutionUnits, error)
        GetUtxoFromRef(txHash string, txIndex int) (*UTxO.UTxO, error)
        GetContractCbor(scriptHash string) (string, error)
}

type Epoch struct {
        // Sum of all the active stakes within the epoch in Lovelaces
        ActiveStake string `json:"active_stake"`

        // Number of blocks within the epoch
        BlockCount int `json:"block_count"`

        // Unix time of the end of the epoch
        EndTime int `json:"end_time"`

        // Epoch number
        Epoch int `json:"epoch"`

        // Sum of all the fees within the epoch in Lovelaces
        Fees string `json:"fees"`

        // Unix time of the first block of the epoch
        FirstBlockTime int `json:"first_block_time"`

        // Unix time of the last block of the epoch
        LastBlockTime int `json:"last_block_time"`

        // Sum of all the transactions within the epoch in Lovelaces
        Output string `json:"output"`

        // Unix time of the start of the epoch
        StartTime int `json:"start_time"`

        // Number of transactions within the epoch
        TxCount int `json:"tx_count"`
}

type Block struct {
        // Block creation time in UNIX time
        Time int `json:"time"`

        // Block number
        Height int `json:"height"`

        // Hash of the block
        Hash string `json:"hash"`

        // Slot number
        Slot int `json:"slot"`

        // Epoch number
        Epoch int `json:"epoch"`

        // Slot within the epoch
        EpochSlot int `json:"epoch_slot"`

        // Bech32 ID of the slot leader or specific block description in case there is no slot leader
        SlotLeader string `json:"slot_leader"`

        // Block size in Bytes
        Size int `json:"size"`

        // Number of transactions in the block
        TxCount int `json:"tx_count"`

        // Total output within the block in Lovelaces
        Output string `json:"output"`

        // Total fees within the block in Lovelaces
        Fees string `json:"fees"`

        // VRF key of the block
        BlockVRF string `json:"block_vrf"`

        // Hash of the previous block
        PreviousBlock string `json:"previous_block"`

        // Hash of the next block
        NextBlock string `json:"next_block"`

        // Number of block confirmations
        Confirmations int `json:"confirmations"`
}

type AddressUTXO struct {
        // Transaction hash of the UTXO
        TxHash string `json:"tx_hash"`

        // UTXO index in the transaction
        OutputIndex int             `json:"output_index"`
        Amount      []AddressAmount `json:"amount"`

        // Block hash of the UTXO
        Block string `json:"block"`

        // The hash of the transaction output datum
        DataHash    string `json:"data_hash"`
        InlineDatum string `json:"inline_datum"`
}

type AddressAmount struct {
        Unit     string `json:"unit"`
        Quantity string `json:"quantity"`
}

func Fee(
        context ChainContext,
        length int,
        exec_steps int,
        max_mem_unit int,
) (int, error) <span class="cov0" title="0">{
        protocol_param, err := context.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">return int(int64(length)*protocol_param.MinFeeCoefficient +
                protocol_param.MinFeeConstant +
                int64(exec_steps)*int64(protocol_param.PriceStep) +
                int64(max_mem_unit)*int64(protocol_param.PriceMem)), nil</span>

}

type BlockfrostProtocolParams struct {
        MinFeeConstant        int     `json:"min_fee_b"`
        MinFeeCoefficient     int     `json:"min_fee_a"`
        MaxBlockSize          int     `json:"max_block_size"`
        MaxTxSize             int     `json:"max_tx_size"`
        MaxBlockHeaderSize    int     `json:"max_block_header_size"`
        KeyDeposits           string  `json:"key_deposit"`
        PoolDeposits          string  `json:"pool_deposit"`
        PooolInfluence        float32 `json:"a0"`
        MonetaryExpansion     float32 `json:"rho"`
        TreasuryExpansion     float32 `json:"tau"`
        DecentralizationParam float32 `json:"decentralisation_param"`
        ExtraEntropy          string  `json:"extra_entropy"`
        ProtocolMajorVersion  int     `json:"protocol_major_ver"`
        ProtocolMinorVersion  int     `json:"protocol_minor_ver"`
        MinUtxo               string  `json:"min_utxo"`
        MinPoolCost           string  `json:"min_pool_cost"`
        PriceMem              float32 `json:"price_mem"`
        PriceStep             float32 `json:"price_step"`
        MaxTxExMem            string  `json:"max_tx_ex_mem"`
        MaxTxExSteps          string  `json:"max_tx_ex_steps"`
        MaxBlockExMem         string  `json:"max_block_ex_mem"`
        MaxBlockExSteps       string  `json:"max_block_ex_steps"`
        MaxValSize            string  `json:"max_val_size"`
        CollateralPercent     int     `json:"collateral_percent"`
        MaxCollateralInuts    int     `json:"max_collateral_inputs"`
        CoinsPerUtxoWord      string  `json:"coins_per_utxo_word"`
        CoinsPerUtxoByte      string  `json:"coins_per_utxo_byte"`
        //CostModels                               //map[string][]uint64 `json:"cost_models"`
        MaximumReferenceScriptsSize      int `json:"maximum_reference_scripts_size"`
        MinFeeReferenceScriptsRange      int `json:"min_fee_reference_scripts_range"`
        MinFeeReferenceScriptsBase       int `json:"min_fee_reference_scripts_base"`
        MinFeeReferenceScriptsMultiplier int `json:"min_fee_reference_scripts_multiplier"`
}

func (p BlockfrostProtocolParams) ToBaseParams() ProtocolParameters <span class="cov0" title="0">{
        return ProtocolParameters{
                MinFeeConstant:                   int64(p.MinFeeConstant),
                MinFeeCoefficient:                int64(p.MinFeeCoefficient),
                MaxBlockSize:                     p.MaxBlockSize,
                MaxTxSize:                        p.MaxTxSize,
                MaxBlockHeaderSize:               p.MaxBlockHeaderSize,
                KeyDeposits:                      p.KeyDeposits,
                PoolDeposits:                     p.PoolDeposits,
                PooolInfluence:                   p.PooolInfluence,
                MonetaryExpansion:                p.MonetaryExpansion,
                TreasuryExpansion:                p.TreasuryExpansion,
                DecentralizationParam:            p.DecentralizationParam,
                ExtraEntropy:                     p.ExtraEntropy,
                ProtocolMajorVersion:             p.ProtocolMajorVersion,
                ProtocolMinorVersion:             p.ProtocolMinorVersion,
                MinUtxo:                          p.MinUtxo,
                MinPoolCost:                      p.MinPoolCost,
                PriceMem:                         p.PriceMem,
                PriceStep:                        p.PriceStep,
                MaxTxExMem:                       p.MaxTxExMem,
                MaxTxExSteps:                     p.MaxTxExSteps,
                MaxBlockExMem:                    p.MaxBlockExMem,
                MaxBlockExSteps:                  p.MaxBlockExSteps,
                MaxValSize:                       p.MaxValSize,
                CollateralPercent:                p.CollateralPercent,
                MaxCollateralInuts:               p.MaxCollateralInuts,
                CoinsPerUtxoWord:                 p.CoinsPerUtxoWord,
                CoinsPerUtxoByte:                 p.CoinsPerUtxoByte,
                MaximumReferenceScriptsSize:      p.MaximumReferenceScriptsSize,
                MinFeeReferenceScriptsRange:      p.MinFeeReferenceScriptsRange,
                MinFeeReferenceScriptsBase:       p.MinFeeReferenceScriptsBase,
                MinFeeReferenceScriptsMultiplier: p.MinFeeReferenceScriptsMultiplier,
        }
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package BlockFrostChainContext

import (
        "bytes"
        "context"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Amount"
        "github.com/Salvionied/apollo/serialization/Asset"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Policy"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/Value"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/Salvionied/apollo/txBuilding/Backend/Cache"

        "github.com/fxamacker/cbor/v2"
)

type BlockFrostChainContext struct {
        client                    *http.Client
        _epoch_info               Base.Epoch
        _epoch                    int
        _Network                  int
        _genesis_param            Base.GenesisParameters
        _protocol_param           Base.ProtocolParameters
        _baseUrl                  string
        _projectId                string
        ctx                       context.Context
        CustomSubmissionEndpoints []string
}

func NewBlockfrostChainContext(
        baseUrl string,
        network int,
        projectId ...string,
) (BlockFrostChainContext, error) <span class="cov8" title="1">{
        ctx := context.Background()
        file, err := os.ReadFile("config.ini")
        var cse []string
        if err == nil </span><span class="cov0" title="0">{
                cse = strings.Split(string(file), "\n")
        }</span> else<span class="cov8" title="1"> {
                cse = []string{}
        }</span>

        <span class="cov8" title="1">var _projectId string
        if len(projectId) &gt; 0 </span><span class="cov8" title="1">{
                _projectId = projectId[0]
        }</span>

        <span class="cov8" title="1">var _baseUrl string
        if strings.Contains(baseUrl, "blockfrost.io") </span><span class="cov8" title="1">{
                _baseUrl = baseUrl + "/v0"
        }</span> else<span class="cov0" title="0"> {
                _baseUrl = baseUrl
        }</span>

        <span class="cov8" title="1">bfc := BlockFrostChainContext{
                client:                    &amp;http.Client{},
                _Network:                  network,
                _baseUrl:                  _baseUrl,
                _projectId:                _projectId,
                ctx:                       ctx,
                CustomSubmissionEndpoints: cse,
        }
        err = bfc.Init()
        if err != nil </span><span class="cov0" title="0">{
                return bfc, err
        }</span>
        <span class="cov8" title="1">return bfc, nil</span>
}
func (bfc *BlockFrostChainContext) Init() error <span class="cov8" title="1">{
        latest_epochs, err := bfc.LatestEpoch()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">bfc._epoch_info = latest_epochs
        //Init Genesis
        params, err := bfc.GenesisParams()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">bfc._genesis_param = params
        //init epoch
        latest_params, err := bfc.LatestEpochParams()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">bfc._protocol_param = latest_params
        return nil</span>
}

func (bfc *BlockFrostChainContext) GetUtxoFromRef(
        txHash string,
        index int,
) (*UTxO.UTxO, error) <span class="cov0" title="0">{
        txOuts, err := bfc.TxOuts(txHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, txOut := range txOuts </span><span class="cov0" title="0">{
                if txOut.OutputIndex == index </span><span class="cov0" title="0">{
                        return txOut.ToUTxO(txHash), nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New("UTXO doesn't exist")</span>
}

func (bfc *BlockFrostChainContext) TxOuts(
        txHash string,
) ([]Base.Output, error) <span class="cov0" title="0">{
        req, _ := http.NewRequestWithContext(
                bfc.ctx,
                "GET",
                fmt.Sprintf("%s/txs/%s/utxos", bfc._baseUrl, txHash),
                nil,
        )
        if bfc._projectId != "" </span><span class="cov0" title="0">{
                req.Header.Set("project_id", bfc._projectId)
        }</span>
        <span class="cov0" title="0">res, err := bfc.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var response Base.TxUtxos
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return response.Outputs, nil</span>

}

func (bfc *BlockFrostChainContext) LatestBlock() (Base.Block, error) <span class="cov0" title="0">{
        bb := Base.Block{}
        req, _ := http.NewRequestWithContext(
                bfc.ctx,
                "GET",
                bfc._baseUrl+"/blocks/latest",
                nil,
        )
        if bfc._projectId != "" </span><span class="cov0" title="0">{
                req.Header.Set("project_id", bfc._projectId)
        }</span>
        <span class="cov0" title="0">res, err := bfc.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return bb, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return bb, err
        }</span>
        <span class="cov0" title="0">var response Base.Block
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return bb, err
        }</span>
        <span class="cov0" title="0">return response, nil</span>
}

func (bfc *BlockFrostChainContext) LatestEpoch() (Base.Epoch, error) <span class="cov8" title="1">{
        resultingEpoch := Base.Epoch{}
        found := Cache.Get[Base.Epoch]("latest_epoch", &amp;resultingEpoch)
        timest := time.Time{}
        foundTime := Cache.Get[time.Time]("latest_epoch_time", &amp;timest)
        if !found || !foundTime || time.Since(timest) &gt; 5*time.Minute </span><span class="cov8" title="1">{
                req, _ := http.NewRequestWithContext(
                        bfc.ctx,
                        "GET",
                        bfc._baseUrl+"/epochs/latest",
                        nil,
                )
                if bfc._projectId != "" </span><span class="cov8" title="1">{
                        req.Header.Set("project_id", bfc._projectId)
                }</span>
                <span class="cov8" title="1">res, err := bfc.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return resultingEpoch, err
                }</span>
                <span class="cov8" title="1">defer res.Body.Close()
                body, err := io.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return resultingEpoch, err
                }</span>
                <span class="cov8" title="1">var response Base.Epoch
                err = json.Unmarshal(body, &amp;response)
                if err != nil </span><span class="cov0" title="0">{
                        return resultingEpoch, err
                }</span>
                <span class="cov8" title="1">Cache.Set("latest_epoch", response)
                now := time.Now()
                Cache.Set("latest_epoch_time", now)
                return response, nil</span>
        } else<span class="cov0" title="0"> {
                return resultingEpoch, nil
        }</span>
}

func (bfc *BlockFrostChainContext) AddressUtxos(
        address string,
        gather bool,
) ([]Base.AddressUTXO, error) <span class="cov0" title="0">{
        if gather </span><span class="cov0" title="0">{
                var i = 1
                result := make([]Base.AddressUTXO, 0)
                for </span><span class="cov0" title="0">{
                        req, _ := http.NewRequestWithContext(
                                bfc.ctx,
                                "GET",
                                fmt.Sprintf(
                                        "%s/addresses/%s/utxos?page=%s",
                                        bfc._baseUrl,
                                        address,
                                        strconv.Itoa(i),
                                ),
                                nil,
                        )
                        if bfc._projectId != "" </span><span class="cov0" title="0">{
                                req.Header.Set("project_id", bfc._projectId)
                        }</span>
                        <span class="cov0" title="0">res, err := bfc.client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">defer res.Body.Close()
                        body, err := io.ReadAll(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">var response []Base.AddressUTXO
                        err = json.Unmarshal(body, &amp;response)
                        if len(response) == 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, response...)
                        i++</span>
                }
                <span class="cov0" title="0">return result, nil</span>
        } else<span class="cov0" title="0"> {
                req, _ := http.NewRequestWithContext(bfc.ctx, "GET", fmt.Sprintf("%s/addresses/%s/utxos", bfc._baseUrl, address), nil)
                if bfc._projectId != "" </span><span class="cov0" title="0">{
                        req.Header.Set("project_id", bfc._projectId)
                }</span>
                <span class="cov0" title="0">res, err := bfc.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer res.Body.Close()
                body, err := io.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var response []Base.AddressUTXO
                err = json.Unmarshal(body, &amp;response)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }
}

func (bfc *BlockFrostChainContext) LatestEpochParams() (Base.ProtocolParameters, error) <span class="cov8" title="1">{
        pm := Base.ProtocolParameters{}
        found := Cache.Get[Base.ProtocolParameters]("latest_epoch_params", &amp;pm)
        timest := time.Time{}
        foundTime := Cache.Get[time.Time]("latest_epoch_params_time", &amp;timest)
        if !found || !foundTime || time.Since(timest) &gt; 5*time.Minute </span><span class="cov8" title="1">{
                req, _ := http.NewRequestWithContext(
                        bfc.ctx,
                        "GET",
                        bfc._baseUrl+"/epochs/latest/parameters",
                        nil,
                )
                if bfc._projectId != "" </span><span class="cov8" title="1">{
                        req.Header.Set("project_id", bfc._projectId)
                }</span>
                <span class="cov8" title="1">res, err := bfc.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return pm, err
                }</span>
                <span class="cov8" title="1">defer res.Body.Close()
                body, err := io.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return pm, err
                }</span>
                <span class="cov8" title="1">var response = Base.BlockfrostProtocolParams{}
                err = json.Unmarshal(body, &amp;response)
                if err != nil </span><span class="cov0" title="0">{
                        return pm, err
                }</span>
                <span class="cov8" title="1">Cache.Set("latest_epoch_params", response)
                now := time.Now()
                Cache.Set("latest_epoch_params_time", now)
                return response.ToBaseParams(), nil</span>
        } else<span class="cov0" title="0"> {
                return pm, nil
        }</span>
}

func (bfc *BlockFrostChainContext) GenesisParams() (Base.GenesisParameters, error) <span class="cov8" title="1">{
        gp := Base.GenesisParameters{}
        found := Cache.Get[Base.GenesisParameters]("genesis_params", &amp;gp)
        timestamp := ""
        foundTime := Cache.Get[string]("genesis_params_time", &amp;timestamp)
        timest := time.Time{}
        if timestamp != "" </span><span class="cov0" title="0">{
                timest, _ = time.Parse(time.RFC3339, timestamp)
        }</span>
        <span class="cov8" title="1">if !found || !foundTime || time.Since(timest) &gt; 5*time.Minute </span><span class="cov8" title="1">{
                req, _ := http.NewRequestWithContext(
                        bfc.ctx,
                        "GET",
                        bfc._baseUrl+"/Genesis",
                        nil,
                )
                if bfc._projectId != "" </span><span class="cov8" title="1">{
                        req.Header.Set("project_id", bfc._projectId)
                }</span>
                <span class="cov8" title="1">res, err := bfc.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return gp, err
                }</span>
                <span class="cov8" title="1">defer res.Body.Close()
                body, err := io.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return gp, err
                }</span>
                <span class="cov8" title="1">var response = Base.GenesisParameters{}
                err = json.Unmarshal(body, &amp;response)
                if err != nil </span><span class="cov0" title="0">{
                        return gp, err
                }</span>
                <span class="cov8" title="1">Cache.Set("genesis_params", response)
                now := time.Now()
                Cache.Set("genesis_params_time", now)
                return response, nil</span>
        } else<span class="cov0" title="0"> {

                return gp, nil
        }</span>
}
func (bfc *BlockFrostChainContext) _CheckEpochAndUpdate() error <span class="cov8" title="1">{
        if bfc._epoch_info.EndTime &lt;= int(time.Now().Unix()) </span><span class="cov0" title="0">{
                latest_epochs, err := bfc.LatestEpoch()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">bfc._epoch_info = latest_epochs
                bfc._epoch = latest_epochs.Epoch
                latestParams, err := bfc.GetProtocolParams()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">bfc._protocol_param = latestParams
                latestGensParams, err := bfc.GetGenesisParams()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">bfc._genesis_param = latestGensParams</span>

        }
        <span class="cov8" title="1">return nil</span>
}

func (bfc *BlockFrostChainContext) Network() int <span class="cov0" title="0">{
        return bfc._Network
}</span>

func (bfc *BlockFrostChainContext) Epoch() (int, error) <span class="cov0" title="0">{
        err := bfc._CheckEpochAndUpdate()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return bfc._epoch, nil</span>
}

func (bfc *BlockFrostChainContext) LastBlockSlot() (int, error) <span class="cov0" title="0">{
        block, err := bfc.LatestBlock()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return block.Slot, nil</span>
}

func (bfc *BlockFrostChainContext) GetGenesisParams() (Base.GenesisParameters, error) <span class="cov0" title="0">{
        gp := Base.GenesisParameters{}
        err := bfc._CheckEpochAndUpdate()
        if err != nil </span><span class="cov0" title="0">{
                return gp, err
        }</span>
        <span class="cov0" title="0">return bfc._genesis_param, nil</span>
}

func (bfc *BlockFrostChainContext) GetProtocolParams() (Base.ProtocolParameters, error) <span class="cov8" title="1">{
        pps := Base.ProtocolParameters{}
        err := bfc._CheckEpochAndUpdate()
        if err != nil </span><span class="cov0" title="0">{
                return pps, err
        }</span>
        <span class="cov8" title="1">return bfc._protocol_param, nil</span>
}

func (bfc *BlockFrostChainContext) MaxTxFee() (int, error) <span class="cov8" title="1">{
        protocol_param, err := bfc.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">maxTxExSteps, _ := strconv.Atoi(protocol_param.MaxTxExSteps)
        maxTxExMem, _ := strconv.Atoi(protocol_param.MaxTxExMem)
        return Base.Fee(bfc, protocol_param.MaxTxSize, maxTxExSteps, maxTxExMem)</span>
}

func (bfc *BlockFrostChainContext) Utxos(
        address Address.Address,
) ([]UTxO.UTxO, error) <span class="cov0" title="0">{
        results, err := bfc.AddressUtxos(address.String(), true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">utxos := make([]UTxO.UTxO, 0)
        for _, result := range results </span><span class="cov0" title="0">{
                decodedTxId, _ := hex.DecodeString(result.TxHash)
                tx_in := TransactionInput.TransactionInput{
                        TransactionId: decodedTxId,
                        Index:         result.OutputIndex,
                }
                amount := result.Amount
                lovelace_amount := 0
                multi_assets := MultiAsset.MultiAsset[int64]{}
                for _, item := range amount </span><span class="cov0" title="0">{
                        if item.Unit == "lovelace" </span><span class="cov0" title="0">{
                                amount, _ := strconv.Atoi(item.Quantity)

                                lovelace_amount += amount
                        }</span> else<span class="cov0" title="0"> {
                                asset_quantity, _ := strconv.ParseInt(item.Quantity, 10, 64)
                                policy_id := Policy.PolicyId{Value: item.Unit[:56]}
                                asset_name := *AssetName.NewAssetNameFromHexString(item.Unit[56:])
                                _, ok := multi_assets[policy_id]
                                if !ok </span><span class="cov0" title="0">{
                                        multi_assets[policy_id] = Asset.Asset[int64]{}
                                }</span>
                                <span class="cov0" title="0">multi_assets[policy_id][asset_name] = int64(asset_quantity)</span>
                        }
                }
                <span class="cov0" title="0">var final_amount Value.Value
                if len(multi_assets) &gt; 0 </span><span class="cov0" title="0">{
                        final_amount = Value.Value{
                                Am: Amount.Amount{
                                        Coin:  int64(lovelace_amount),
                                        Value: multi_assets,
                                },
                                HasAssets: true,
                        }
                }</span> else<span class="cov0" title="0"> {
                        final_amount = Value.Value{Coin: int64(lovelace_amount), HasAssets: false}
                }</span>
                <span class="cov0" title="0">datum_hash := serialization.DatumHash{}
                if result.DataHash != "" &amp;&amp; result.InlineDatum == "" </span><span class="cov0" title="0">{

                        datum_hash = serialization.DatumHash{}
                        copy(datum_hash.Payload[:], result.DataHash[:])
                }</span>
                <span class="cov0" title="0">var tx_out TransactionOutput.TransactionOutput
                if result.InlineDatum != "" </span><span class="cov0" title="0">{
                        decoded, _ := hex.DecodeString(result.InlineDatum)
                        var x PlutusData.PlutusData
                        err := cbor.Unmarshal(decoded, &amp;x)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">l := PlutusData.DatumOptionInline(&amp;x)

                        tx_out = TransactionOutput.TransactionOutput{IsPostAlonzo: true,
                                PostAlonzo: TransactionOutput.TransactionOutputAlonzo{
                                        Address: address,
                                        Amount:  final_amount.ToAlonzoValue(),
                                        Datum:   &amp;l},
                        }</span>
                } else<span class="cov0" title="0"> {
                        tx_out = TransactionOutput.TransactionOutput{PreAlonzo: TransactionOutput.TransactionOutputShelley{
                                Address:   address,
                                Amount:    final_amount,
                                DatumHash: datum_hash,
                                HasDatum:  len(datum_hash.Payload) &gt; 0}, IsPostAlonzo: false}
                }</span>
                <span class="cov0" title="0">utxos = append(utxos, UTxO.UTxO{Input: tx_in, Output: tx_out})</span>
        }
        <span class="cov0" title="0">return utxos, nil</span>
}

func (bfc *BlockFrostChainContext) SpecialSubmitTx(
        tx Transaction.Transaction,
        logger chan string,
) (serialization.TransactionId, error) <span class="cov0" title="0">{
        resId := serialization.TransactionId{}
        txBytes, _ := cbor.Marshal(tx)
        if bfc.CustomSubmissionEndpoints != nil </span><span class="cov0" title="0">{
                logger &lt;- ("Custom Submission Endpoints Found, submitting...")
                for _, endpoint := range bfc.CustomSubmissionEndpoints </span><span class="cov0" title="0">{
                        logger &lt;- fmt.Sprint("TRYING WITH:", endpoint)
                        req, _ := http.NewRequestWithContext(
                                bfc.ctx,
                                "POST",
                                endpoint,
                                bytes.NewBuffer(txBytes),
                        )
                        if bfc._projectId != "" </span><span class="cov0" title="0">{
                                req.Header.Set("project_id", bfc._projectId)
                        }</span>
                        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/cbor")
                        res, err := bfc.client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return resId, err
                        }</span>
                        <span class="cov0" title="0">defer res.Body.Close()
                        body, err := io.ReadAll(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return resId, err
                        }</span>
                        <span class="cov0" title="0">var response any
                        err = json.Unmarshal(body, &amp;response)
                        if err != nil </span><span class="cov0" title="0">{
                                return resId, err
                        }</span>
                        <span class="cov0" title="0">logger &lt;- fmt.Sprint("RESPONSE:", response)</span>
                }
        }
        <span class="cov0" title="0">req, _ := http.NewRequestWithContext(
                bfc.ctx,
                "POST",
                bfc._baseUrl+"/tx/submit",
                bytes.NewBuffer(txBytes),
        )
        if bfc._projectId != "" </span><span class="cov0" title="0">{
                req.Header.Set("project_id", bfc._projectId)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/cbor")
        res, err := bfc.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return resId, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return resId, err
        }</span>
        <span class="cov0" title="0">var response any
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return resId, err
        }</span>
        <span class="cov0" title="0">hash, _ := tx.TransactionBody.Hash()
        return serialization.TransactionId{Payload: hash}, nil</span>
}

func (bfc *BlockFrostChainContext) SubmitTx(
        tx Transaction.Transaction,
) (serialization.TransactionId, error) <span class="cov8" title="1">{
        resId := serialization.TransactionId{}
        txBytes, _ := cbor.Marshal(tx)
        if bfc.CustomSubmissionEndpoints != nil </span><span class="cov8" title="1">{
                for _, endpoint := range bfc.CustomSubmissionEndpoints </span><span class="cov0" title="0">{
                        req, _ := http.NewRequestWithContext(
                                bfc.ctx,
                                "POST",
                                endpoint,
                                bytes.NewBuffer(txBytes),
                        )
                        if bfc._projectId != "" </span><span class="cov0" title="0">{
                                req.Header.Set("project_id", bfc._projectId)
                        }</span>
                        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/cbor")
                        res, err := bfc.client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return resId, err
                        }</span>
                        <span class="cov0" title="0">defer res.Body.Close()
                        body, err := io.ReadAll(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return resId, err
                        }</span>
                        <span class="cov0" title="0">var response any
                        err = json.Unmarshal(body, &amp;response)
                        if err != nil </span><span class="cov0" title="0">{
                                return resId, err
                        }</span>
                }
        }
        <span class="cov8" title="1">req, _ := http.NewRequestWithContext(
                bfc.ctx,
                "POST",
                bfc._baseUrl+"/tx/submit",
                bytes.NewBuffer(txBytes),
        )
        if bfc._projectId != "" </span><span class="cov8" title="1">{
                req.Header.Set("project_id", bfc._projectId)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/cbor")
        res, err := bfc.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, err
        }</span>
        <span class="cov8" title="1">var response any
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, err
        }</span>
        <span class="cov8" title="1">if res.Status != "200 OK" </span><span class="cov8" title="1">{
                return serialization.TransactionId{}, fmt.Errorf(
                        "error submitting tx: %v",
                        response,
                )
        }</span>
        <span class="cov0" title="0">hash, err := tx.TransactionBody.Hash()
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, err
        }</span>
        <span class="cov0" title="0">return serialization.TransactionId{Payload: hash}, nil</span>
}

type EvalResult struct {
        Result map[string]map[string]int `json:"EvaluationResult"`
}

type ExecutionResult struct {
        Result EvalResult `json:"result"`
}

func (bfc *BlockFrostChainContext) EvaluateTx(
        tx []byte,
) (map[string]Redeemer.ExecutionUnits, error) <span class="cov8" title="1">{
        encoded := hex.EncodeToString(tx)
        req, _ := http.NewRequestWithContext(
                bfc.ctx,
                "POST",
                bfc._baseUrl+"/utils/txs/evaluate",
                strings.NewReader(encoded),
        )
        if bfc._projectId != "" </span><span class="cov8" title="1">{
                req.Header.Set("project_id", bfc._projectId)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/cbor")
        res, err := bfc.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var x any
        err = json.Unmarshal(body, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var response ExecutionResult
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">final_result := make(map[string]Redeemer.ExecutionUnits, 0)
        for k, v := range response.Result.Result </span><span class="cov0" title="0">{
                final_result[k] = Redeemer.ExecutionUnits{
                        Steps: int64(v["steps"]),
                        Mem:   int64(v["memory"]),
                }
        }</span>
        <span class="cov8" title="1">return final_result, nil</span>
}

type BlockfrostContractCbor struct {
        Cbor string `json:"cbor"`
}

func (bfc *BlockFrostChainContext) GetContractCbor(
        scriptHash string,
) (string, error) <span class="cov0" title="0">{
        req, _ := http.NewRequestWithContext(
                bfc.ctx,
                "GET",
                fmt.Sprintf("%s/scripts/%s/cbor", bfc._baseUrl, scriptHash),
                nil,
        )
        if bfc._projectId != "" </span><span class="cov0" title="0">{
                req.Header.Set("project_id", bfc._projectId)
        }</span>
        <span class="cov0" title="0">res, err := bfc.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">var response BlockfrostContractCbor
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return response.Cbor, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package Cache

import (
        "encoding/json"
        "fmt"
        "os"
)

func Get[T any](key string, val any) bool <span class="cov0" title="0">{
        dat, err := os.ReadFile(fmt.Sprintf("./tmp/%s.txt", key))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(dat, &amp;val)
        return err == nil</span>
}

func Set[T any](key string, value T) <span class="cov0" title="0">{
        val, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: proper error handling
                fmt.Println(err)
        }</span>
        <span class="cov0" title="0">err = os.WriteFile(fmt.Sprintf("./tmp/%s.txt", key), val, 0644)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: proper error handling
                fmt.Println(err)
        }</span>

}
</pre>
		
		<pre class="file" id="file43" style="display: none">package FixedChainContext

import (
        "reflect"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Asset"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/Policy"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/Value"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"

        "github.com/fxamacker/cbor/v2"
)

const TEST_ADDR = "addr_test1vr2p8st5t5cxqglyjky7vk98k7jtfhdpvhl4e97cezuhn0cqcexl7"

type CborSerializable interface {
        cbor.Marshaler
        cbor.Unmarshaler
}

func CheckTwoWayCbor[T CborSerializable](serializable T) <span class="cov0" title="0">{
        restored := new(T)
        serialized, _ := cbor.Marshal(serializable)
        // TODO: properly error check
        _ = cbor.Unmarshal(serialized, restored)
        if !reflect.DeepEqual(serializable, restored) </span><span class="cov0" title="0">{
                panic("Invalid serialization")</span>
        }
}

type FixedChainContext struct {
        ProtocolParams Base.ProtocolParameters
        GenesisParams  Base.GenesisParameters
}

func InitFixedChainContext() FixedChainContext <span class="cov0" title="0">{
        return FixedChainContext{ProtocolParams: Base.ProtocolParameters{
                MinFeeConstant:        155381,
                MinFeeCoefficient:     44,
                MaxBlockSize:          73728,
                MaxTxSize:             16384,
                MaxBlockHeaderSize:    1100,
                KeyDeposits:           "2000000",
                PoolDeposits:          "500000000",
                PooolInfluence:        0.3,
                TreasuryExpansion:     0.2,
                DecentralizationParam: 0,
                ExtraEntropy:          "",
                ProtocolMajorVersion:  6,
                ProtocolMinorVersion:  0,
                MinUtxo:               "1000000",
                MinPoolCost:           "340000000",
                PriceMem:              0.0577,
                PriceStep:             0.0000721,
                MaxTxExMem:            "10000000",
                MaxTxExSteps:          "10000000000",
                MaxBlockExMem:         "500000000",
                MaxBlockExSteps:       "40000000000",
                MaxValSize:            "5000",
                CoinsPerUtxoWord:      "34482",
                //CoinsPerUtxoByte:      "4310",
        },
                GenesisParams: Base.GenesisParameters{
                        ActiveSlotsCoefficient: 0.05,
                        MaxLovelaceSupply:      "45000000000000000",
                        NetworkMagic:           764824073,
                        EpochLength:            432000,
                        SlotsPerKesPeriod:      129600,
                        MaxKesEvolutions:       62,
                        SlotLength:             1,
                        UpdateQuorum:           5,
                        SecurityParam:          2160,
                        SystemStart:            1506203091,
                }}
}</span>

func (f FixedChainContext) GetProtocolParams() (Base.ProtocolParameters, error) <span class="cov0" title="0">{
        return f.ProtocolParams, nil
}</span>

func (f FixedChainContext) GetGenesisParams() (Base.GenesisParameters, error) <span class="cov0" title="0">{
        return f.GenesisParams, nil
}</span>

func (f FixedChainContext) Network() int <span class="cov0" title="0">{
        return f.GenesisParams.NetworkMagic
}</span>

func (f FixedChainContext) Epoch() (int, error) <span class="cov0" title="0">{
        return 300, nil
}</span>

func (f FixedChainContext) LastBlockSlot() (int, error) <span class="cov0" title="0">{
        return 2000, nil
}</span>

func (f FixedChainContext) MaxTxFee() (int, error) <span class="cov0" title="0">{
        return 100, nil
}</span>

func (f FixedChainContext) GetUtxoFromRef(
        txHash string,
        txIndex int,
) (*UTxO.UTxO, error) <span class="cov0" title="0">{
        return &amp;UTxO.UTxO{}, nil
}</span>

func (f FixedChainContext) Utxos(address Address.Address) ([]UTxO.UTxO, error) <span class="cov0" title="0">{
        tx_in1 := TransactionInput.TransactionInput{
                TransactionId: []byte{
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                        0x01,
                },
                Index: 0,
        }
        tx_in2 := TransactionInput.TransactionInput{
                TransactionId: []byte{
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                        0x02,
                },
                Index: 1,
        }

        tx_out1 := TransactionOutput.SimpleTransactionOutput(
                address,
                Value.PureLovelaceValue(5000000),
        )
        tx_out2 := TransactionOutput.SimpleTransactionOutput(
                address,
                Value.SimpleValue(
                        6000000,
                        MultiAsset.MultiAsset[int64]{
                                Policy.PolicyId{Value: "11111111111111111111111111111111111111111111111111111111"}: Asset.Asset[int64]{
                                        AssetName.NewAssetNameFromString("Token1"): 1,
                                        AssetName.NewAssetNameFromString("Token2"): 2,
                                },
                        },
                ),
        )
        return []UTxO.UTxO{
                {Input: tx_in1, Output: tx_out1},
                {Input: tx_in2, Output: tx_out2},
        }, nil
}</span>

func (f FixedChainContext) SubmitTx(
        tx Transaction.Transaction,
) (serialization.TransactionId, error) <span class="cov0" title="0">{
        return serialization.TransactionId{}, nil
}</span>

func (f FixedChainContext) EvaluateTx(
        tx []uint8,
) (map[string]Redeemer.ExecutionUnits, error) <span class="cov0" title="0">{
        return map[string]Redeemer.ExecutionUnits{
                "spend:0": {Mem: 399882, Steps: 175940720},
        }, nil
}</span>

func (f FixedChainContext) GetContractCbor(scriptHash string) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package MaestroChainContext

import (
        "encoding/hex"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/fxamacker/cbor/v2"
        "github.com/maestro-org/go-sdk/client"
        "github.com/maestro-org/go-sdk/utils"
)

type MaestroChainContext struct {
        _epoch_info     Base.Epoch
        _epoch          int
        _Network        int
        _genesis_param  Base.GenesisParameters
        _protocol_param Base.ProtocolParameters
        client          *client.Client
        latestUpdate    time.Time
}

func NewMaestroChainContext(
        network int,
        projectId string,
) (MaestroChainContext, error) <span class="cov0" title="0">{
        var networkString string
        switch network </span>{
        case 0:<span class="cov0" title="0">
                networkString = "mainnet"</span>
        case 1:<span class="cov0" title="0">
                networkString = "testnet"</span>
        case 2:<span class="cov0" title="0">
                networkString = "preview"</span>
        case 3:<span class="cov0" title="0">
                networkString = "preprod"</span>
        default:<span class="cov0" title="0">
                return MaestroChainContext{}, errors.New("invalid network")</span>
        }
        <span class="cov0" title="0">maestroClient := client.NewClient(projectId, networkString)
        mcc := MaestroChainContext{
                client: maestroClient, _Network: network,
        }
        err := mcc.Init()
        return mcc, err</span>
}
func (mcc *MaestroChainContext) Init() error <span class="cov0" title="0">{
        latest_epochs, err := mcc.LatestEpoch()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">mcc._epoch_info = latest_epochs
        params, err := mcc.GenesisParams()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">mcc._genesis_param = params
        latest_params, err := mcc.LatestEpochParams()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">mcc._protocol_param = latest_params
        return nil</span>
}

func (mcc *MaestroChainContext) LatestBlock() (Base.Block, error) <span class="cov0" title="0">{
        latestBlock := Base.Block{}
        latestBlockFromApi, err := mcc.client.LatestBlock()
        if err != nil </span><span class="cov0" title="0">{
                return latestBlock, err
        }</span>
        <span class="cov0" title="0">if latestBlockFromApi == nil </span><span class="cov0" title="0">{
                return latestBlock, nil
        }</span> else<span class="cov0" title="0"> {
                tmpTime, _ := time.Parse("2006-01-02 15:04:05", latestBlockFromApi.Data.Timestamp)
                latestBlock.Time = int(tmpTime.Unix())
                latestBlock.Height = int(latestBlockFromApi.Data.Height)
                latestBlock.Hash = latestBlockFromApi.Data.Hash
                latestBlock.Slot = int(latestBlockFromApi.Data.AbsoluteSlot)
                latestBlock.Epoch = int(latestBlockFromApi.Data.Epoch)
                latestBlock.EpochSlot = int(latestBlockFromApi.Data.EpochSlot)
                latestBlock.SlotLeader = latestBlockFromApi.Data.BlockProducer
                latestBlock.Size = int(latestBlockFromApi.Data.Size)
                latestBlock.TxCount = len(latestBlockFromApi.Data.TxHashes)
                latestBlock.Output = latestBlockFromApi.Data.TotalOutputLovelace
                latestBlock.Fees = strconv.FormatInt(latestBlockFromApi.Data.TotalFees, 10)
                latestBlock.BlockVRF = latestBlockFromApi.Data.VrfKey
                latestBlock.PreviousBlock = latestBlockFromApi.Data.PreviousBlock
                latestBlock.NextBlock = latestBlockFromApi.Data.Hash
                latestBlock.Confirmations = int(latestBlockFromApi.Data.Confirmations)
        }</span>
        <span class="cov0" title="0">return latestBlock, nil</span>
}

func (mcc *MaestroChainContext) LatestEpoch() (Base.Epoch, error) <span class="cov0" title="0">{
        epoch := Base.Epoch{}
        latestEpoch, err := mcc.client.CurrentEpoch()
        if err != nil </span><span class="cov0" title="0">{
                return epoch, err
        }</span>
        <span class="cov0" title="0">epoch.ActiveStake = ""
        epoch.BlockCount = int(latestEpoch.Data.BlkCount)
        epoch.EndTime = int(latestEpoch.LastUpdated.BlockSlot)
        epoch.Fees = latestEpoch.Data.Fees
        epoch.FirstBlockTime = int(latestEpoch.Data.StartTime)
        epoch.StartTime = int(latestEpoch.Data.StartTime)
        epoch.TxCount = int(latestEpoch.Data.TxCount)
        return epoch, nil</span>

}

func parseMaestroFloat(floatString string) float32 <span class="cov0" title="0">{
        if floatString == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">splitString := strings.Split(floatString, "/")
        top := splitString[0]
        bottom := splitString[1]
        topFloat, _ := strconv.ParseFloat(top, 32)
        bottomFloat, _ := strconv.ParseFloat(bottom, 32)
        return float32(topFloat / bottomFloat)</span>
}

func (mcc *MaestroChainContext) LatestEpochParams() (Base.ProtocolParameters, error) <span class="cov0" title="0">{
        protocolParams := Base.ProtocolParameters{}
        ppFromApi, err := mcc.client.ProtocolParameters()
        if err != nil </span><span class="cov0" title="0">{
                return protocolParams, err
        }</span>
        // Map ALL the fields
        <span class="cov0" title="0">protocolParams.MinFeeConstant = int64(
                ppFromApi.Data.MinFeeConstant.LovelaceAmount.Lovelace,
        )
        protocolParams.MinFeeCoefficient = int64(ppFromApi.Data.MinFeeCoefficient)
        protocolParams.MaxTxSize = int(ppFromApi.Data.MaxTransactionSize.Bytes)
        protocolParams.MaxBlockSize = int(ppFromApi.Data.MaxBlockBodySize.Bytes)
        protocolParams.MaxBlockHeaderSize = int(
                ppFromApi.Data.MaxBlockHeaderSize.Bytes,
        )
        protocolParams.KeyDeposits = strconv.FormatInt(
                ppFromApi.Data.StakeCredentialDeposit.LovelaceAmount.Lovelace,
                10,
        )
        protocolParams.PoolDeposits = strconv.FormatInt(
                ppFromApi.Data.StakePoolDeposit.LovelaceAmount.Lovelace,
                10,
        )
        parsedPoolInfl, _ := strconv.ParseFloat(
                ppFromApi.Data.StakePoolPledgeInfluence,
                32,
        )
        protocolParams.PooolInfluence = float32(parsedPoolInfl)
        monExp, _ := strconv.ParseFloat(ppFromApi.Data.MonetaryExpansion, 32)
        protocolParams.MonetaryExpansion = float32(monExp)
        tresExp, _ := strconv.ParseFloat(ppFromApi.Data.TreasuryExpansion, 32)
        protocolParams.TreasuryExpansion = float32(tresExp)
        protocolParams.DecentralizationParam = 0
        protocolParams.ExtraEntropy = ""
        protocolParams.ProtocolMajorVersion = int(
                ppFromApi.Data.ProtocolVersion.Major,
        )
        protocolParams.ProtocolMinorVersion = int(
                ppFromApi.Data.ProtocolVersion.Minor,
        )
        //CHECK HERE
        //protocolParams.MinUtxo = ppFromApi.Data.
        protocolParams.MinPoolCost = strconv.FormatInt(
                ppFromApi.Data.MinStakePoolCost.LovelaceAmount.Lovelace,
                10,
        )
        protocolParams.PriceMem = parseMaestroFloat(
                ppFromApi.Data.ScriptExecutionPrices.Memory,
        )
        protocolParams.PriceStep = parseMaestroFloat(
                ppFromApi.Data.ScriptExecutionPrices.Steps,
        )
        protocolParams.MaxTxExMem = strconv.FormatInt(
                ppFromApi.Data.MaxExecutionUnitsPerTransaction.Memory,
                10,
        )
        protocolParams.MaxTxExSteps = strconv.FormatInt(
                ppFromApi.Data.MaxExecutionUnitsPerTransaction.Steps,
                10,
        )
        protocolParams.MaxBlockExMem = strconv.FormatInt(
                ppFromApi.Data.MaxExecutionUnitsPerBlock.Memory,
                10,
        )
        protocolParams.MaxBlockExSteps = strconv.FormatInt(
                ppFromApi.Data.MaxExecutionUnitsPerBlock.Steps,
                10,
        )
        protocolParams.MaxValSize = strconv.FormatInt(
                ppFromApi.Data.MaxValueSize.Bytes,
                10,
        )
        protocolParams.CollateralPercent = int(ppFromApi.Data.CollateralPercentage)
        protocolParams.MaxCollateralInuts = int(ppFromApi.Data.MaxCollateralInputs)
        protocolParams.CoinsPerUtxoByte = strconv.FormatInt(
                ppFromApi.Data.MinUtxoDepositCoefficient,
                10,
        )
        protocolParams.CoinsPerUtxoWord = "0"
        //protocolParams.CostModels = ppFromApi.Data.CostModels
        return protocolParams, nil</span>
}

func (mcc *MaestroChainContext) GenesisParams() (Base.GenesisParameters, error) <span class="cov0" title="0">{
        genesisParams := Base.GenesisParameters{}
        // NO GENESIS PARAMS IN MAESTRO
        return genesisParams, nil
}</span>

func (mcc *MaestroChainContext) Network() int <span class="cov0" title="0">{
        return mcc._Network
}</span>

func (mcc *MaestroChainContext) Epoch() (int, error) <span class="cov0" title="0">{
        if time.Since(mcc.latestUpdate) &gt; time.Minute*5 </span><span class="cov0" title="0">{
                new_epoch, err := mcc.LatestEpoch()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov0" title="0">mcc._epoch = new_epoch.Epoch</span>
        }
        <span class="cov0" title="0">return mcc._epoch, nil</span>
}

func (mcc *MaestroChainContext) LastBlockSlot() (int, error) <span class="cov0" title="0">{
        block, err := mcc.LatestBlock()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return block.Slot, nil</span>
}

func (mcc *MaestroChainContext) GetGenesisParams() (Base.GenesisParameters, error) <span class="cov0" title="0">{
        if time.Since(mcc.latestUpdate) &gt; time.Minute*5 </span><span class="cov0" title="0">{
                params, err := mcc.GenesisParams()
                if err != nil </span><span class="cov0" title="0">{
                        return Base.GenesisParameters{}, err
                }</span>
                <span class="cov0" title="0">mcc._genesis_param = params</span>
        }
        <span class="cov0" title="0">return mcc._genesis_param, nil</span>
}

func (mcc *MaestroChainContext) GetProtocolParams() (Base.ProtocolParameters, error) <span class="cov0" title="0">{
        if time.Since(mcc.latestUpdate) &gt; time.Minute*5 </span><span class="cov0" title="0">{
                latest_params, err := mcc.LatestEpochParams()
                if err != nil </span><span class="cov0" title="0">{
                        return Base.ProtocolParameters{}, err
                }</span>
                <span class="cov0" title="0">mcc._protocol_param = latest_params
                mcc.latestUpdate = time.Now()</span>
        }
        <span class="cov0" title="0">return mcc._protocol_param, nil</span>
}

func (mcc *MaestroChainContext) MaxTxFee() (int, error) <span class="cov0" title="0">{
        protocol_param, err := mcc.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">maxTxExSteps, _ := strconv.Atoi(protocol_param.MaxTxExSteps)
        maxTxExMem, _ := strconv.Atoi(protocol_param.MaxTxExMem)
        return Base.Fee(mcc, protocol_param.MaxTxSize, maxTxExSteps, maxTxExMem)</span>
}
func (mcc *MaestroChainContext) TxOuts(txHash string) ([]Base.Output, error) <span class="cov0" title="0">{
        tx, err := mcc.client.TransactionDetails(txHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">outputs := make([]Base.Output, 0)
        for idx, txOut := range tx.Data.Outputs </span><span class="cov0" title="0">{
                amount := []Base.AddressAmount{}
                for _, addrAmount := range txOut.Assets </span><span class="cov0" title="0">{
                        amount = append(amount, Base.AddressAmount{
                                Unit:     addrAmount.Unit,
                                Quantity: strconv.FormatInt(addrAmount.Amount, 10),
                        })
                }</span>
                <span class="cov0" title="0">output := Base.Output{
                        Address:             txOut.Address,
                        OutputIndex:         idx,
                        ReferenceScriptHash: txOut.ReferenceScript.Hash,
                        Amount:              amount,
                }
                outputs = append(outputs, output)</span>
        }
        <span class="cov0" title="0">return outputs, nil</span>
}

func (mcc *MaestroChainContext) GetUtxoFromRef(
        txHash string,
        index int,
) (*UTxO.UTxO, error) <span class="cov0" title="0">{
        var utxo *UTxO.UTxO
        params := utils.NewParameters()
        params.WithCbor()
        txOutputByRef, err := mcc.client.TransactionOutputFromReference(
                txHash,
                index,
                params,
        )
        if err != nil </span><span class="cov0" title="0">{
                return utxo, err
        }</span>
        <span class="cov0" title="0">decodedCbor, _ := hex.DecodeString(txOutputByRef.Data.TxOutCbor)
        output := TransactionOutput.TransactionOutput{}
        err = cbor.Unmarshal(decodedCbor, &amp;output)
        if err != nil </span><span class="cov0" title="0">{

                return nil, err
        }</span>
        <span class="cov0" title="0">decodedHash, _ := hex.DecodeString(txHash)
        utxo = &amp;UTxO.UTxO{
                Input: TransactionInput.TransactionInput{
                        TransactionId: decodedHash,
                        Index:         index,
                },
                Output: output,
        }
        return utxo, nil</span>
}

func (mcc *MaestroChainContext) AddressUtxos(
        address string,
        gather bool,
) ([]Base.AddressUTXO, error) <span class="cov0" title="0">{
        addressUtxos := make([]Base.AddressUTXO, 0)
        params := utils.NewParameters()
        params.ResolveDatums()
        utxosAtAddressAtApi, err := mcc.client.UtxosAtAddress(address, params)
        if err != nil </span><span class="cov0" title="0">{
                return addressUtxos, err
        }</span>

        <span class="cov0" title="0">for _, maestroUtxo := range utxosAtAddressAtApi.Data </span><span class="cov0" title="0">{
                assets := make([]Base.AddressAmount, 0)
                for _, asset := range maestroUtxo.Assets </span><span class="cov0" title="0">{
                        assets = append(assets, Base.AddressAmount{
                                Unit:     asset.Unit,
                                Quantity: strconv.FormatInt(asset.Amount, 10),
                        })
                }</span>
                <span class="cov0" title="0">utxo := Base.AddressUTXO{
                        Amount:      assets,
                        OutputIndex: int(maestroUtxo.Index),
                        TxHash:      maestroUtxo.TxHash,
                        InlineDatum: fmt.Sprint(maestroUtxo.Datum),
                }
                addressUtxos = append(addressUtxos, utxo)</span>
        }

        <span class="cov0" title="0">if gather </span><span class="cov0" title="0">{
                for utxosAtAddressAtApi.NextCursor != "" </span><span class="cov0" title="0">{
                        params.Cursor(utxosAtAddressAtApi.NextCursor)
                        utxosAtAddressAtApi, err = mcc.client.UtxosAtAddress(
                                address,
                                params,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return addressUtxos, err
                        }</span>
                        <span class="cov0" title="0">for _, maestroUtxo := range utxosAtAddressAtApi.Data </span><span class="cov0" title="0">{
                                assets := make([]Base.AddressAmount, 0)
                                for _, asset := range maestroUtxo.Assets </span><span class="cov0" title="0">{
                                        assets = append(assets, Base.AddressAmount{
                                                Unit:     asset.Unit,
                                                Quantity: strconv.FormatInt(asset.Amount, 10),
                                        })
                                }</span>
                                <span class="cov0" title="0">utxo := Base.AddressUTXO{
                                        Amount:      assets,
                                        OutputIndex: int(maestroUtxo.Index),
                                        TxHash:      maestroUtxo.TxHash,
                                        InlineDatum: fmt.Sprint(maestroUtxo.Datum),
                                }
                                addressUtxos = append(addressUtxos, utxo)</span>
                        }
                }
        }

        <span class="cov0" title="0">return addressUtxos, nil</span>

}

func (mcc *MaestroChainContext) Utxos(
        address Address.Address,
) ([]UTxO.UTxO, error) <span class="cov0" title="0">{
        utxos := make([]UTxO.UTxO, 0)
        params := utils.NewParameters()
        params.WithCbor()
        params.ResolveDatums()
        utxosAtAddressAtApi, err := mcc.client.UtxosAtAddress(
                address.String(),
                params,
        )
        if err != nil </span><span class="cov0" title="0">{
                return utxos, err
        }</span>

        <span class="cov0" title="0">for _, maestroUtxo := range utxosAtAddressAtApi.Data </span><span class="cov0" title="0">{
                utxo := UTxO.UTxO{}
                decodedHash, _ := hex.DecodeString(maestroUtxo.TxHash)
                utxo.Input = TransactionInput.TransactionInput{
                        TransactionId: decodedHash,
                        Index:         int(maestroUtxo.Index),
                }
                output := TransactionOutput.TransactionOutput{}
                decodedCbor, _ := hex.DecodeString(maestroUtxo.TxOutCbor)
                err = cbor.Unmarshal(decodedCbor, &amp;output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">utxo.Output = output
                utxos = append(utxos, utxo)</span>
        }

        <span class="cov0" title="0">for utxosAtAddressAtApi.NextCursor != "" </span><span class="cov0" title="0">{
                params.Cursor(utxosAtAddressAtApi.NextCursor)
                utxosAtAddressAtApi, err = mcc.client.UtxosAtAddress(
                        address.String(),
                        params,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return utxos, err
                }</span>
                <span class="cov0" title="0">for _, maestroUtxo := range utxosAtAddressAtApi.Data </span><span class="cov0" title="0">{
                        utxo := UTxO.UTxO{}
                        decodedHash, _ := hex.DecodeString(maestroUtxo.TxHash)
                        utxo.Input = TransactionInput.TransactionInput{
                                TransactionId: decodedHash,
                                Index:         int(maestroUtxo.Index),
                        }
                        output := TransactionOutput.TransactionOutput{}
                        decodedCbor, _ := hex.DecodeString(maestroUtxo.TxOutCbor)
                        err = cbor.Unmarshal(decodedCbor, &amp;output)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">utxo.Output = output
                        utxos = append(utxos, utxo)</span>
                }
        }

        <span class="cov0" title="0">return utxos, nil</span>
}

func (mcc *MaestroChainContext) SubmitTx(
        tx Transaction.Transaction,
) (serialization.TransactionId, error) <span class="cov0" title="0">{
        txBytes, err := tx.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, err
        }</span>
        <span class="cov0" title="0">txHex := hex.EncodeToString(txBytes)
        resp, err := mcc.client.SubmitTx(txHex)
        if err != nil </span><span class="cov0" title="0">{

                return serialization.TransactionId{}, err
        }</span>
        <span class="cov0" title="0">decodedResponseHash, _ := hex.DecodeString(resp.Data)
        return serialization.TransactionId{
                Payload: []byte(decodedResponseHash),
        }, nil</span>
}

type EvalResult struct {
        Result map[string]map[string]int `json:"EvaluationResult"`
}

type ExecutionResult struct {
        Result EvalResult `json:"result"`
}

func (mcc *MaestroChainContext) EvaluateTx(
        tx []byte,
) (map[string]Redeemer.ExecutionUnits, error) <span class="cov0" title="0">{
        final_result := make(map[string]Redeemer.ExecutionUnits)
        encodedTx := hex.EncodeToString(tx)
        evaluation, err := mcc.client.EvaluateTx(encodedTx)
        if err != nil </span><span class="cov0" title="0">{
                return final_result, err
        }</span>
        <span class="cov0" title="0">for _, eval := range evaluation </span><span class="cov0" title="0">{
                final_result[eval.RedeemerTag+":"+strconv.Itoa(eval.RedeemerIndex)] = Redeemer.ExecutionUnits{
                        Mem:   eval.ExUnits.Mem,
                        Steps: eval.ExUnits.Steps,
                }
        }</span>
        <span class="cov0" title="0">return final_result, nil</span>
}

func (mcc *MaestroChainContext) GetContractCbor(
        scriptHash string,
) (string, error) <span class="cov0" title="0">{
        res, err := mcc.client.ScriptByHash(scriptHash)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">scCborBytes := res.Data.Bytes
        bytes := []byte{}
        decodedBytes, _ := hex.DecodeString(scCborBytes)
        _ = cbor.Unmarshal(decodedBytes, &amp;bytes)
        return hex.EncodeToString(bytes), nil</span>

}
</pre>
		
		<pre class="file" id="file45" style="display: none">package OgmiosChainContext

import (
        "context"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log"
        "strconv"
        "strings"
        "time"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Amount"
        "github.com/Salvionied/apollo/serialization/Asset"
        "github.com/Salvionied/apollo/serialization/AssetName"
        "github.com/Salvionied/apollo/serialization/MultiAsset"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/Policy"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/serialization/Value"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/SundaeSwap-finance/kugo"
        "github.com/SundaeSwap-finance/ogmigo/v6"
        "github.com/SundaeSwap-finance/ogmigo/v6/ouroboros/chainsync"
        "github.com/SundaeSwap-finance/ogmigo/v6/ouroboros/chainsync/num"
        "github.com/SundaeSwap-finance/ogmigo/v6/ouroboros/shared"

        "github.com/fxamacker/cbor/v2"
)

type OgmiosChainContext struct {
        _epoch_info     Base.Epoch
        _epoch          int
        _Network        int
        _genesis_param  Base.GenesisParameters
        _protocol_param Base.ProtocolParameters
        ogmigo          *ogmigo.Client
        kugo            *kugo.Client
}

func NewOgmiosChainContext(
        ogmigoClient *ogmigo.Client,
        kugoClient *kugo.Client,
) OgmiosChainContext <span class="cov8" title="1">{
        occ := OgmiosChainContext{
                ogmigo: ogmigoClient,
                kugo:   kugoClient,
        }
        return occ
}</span>

func (occ *OgmiosChainContext) Init() <span class="cov8" title="1">{
        latest_epochs := occ.LatestEpoch()
        occ._epoch_info = latest_epochs
        //Init Genesis
        params := occ.GenesisParams()
        occ._genesis_param = params
        //init epoch
        latest_params := occ.LatestEpochParams()
        occ._protocol_param = latest_params
}</span>

func multiAsset_OgmigoToApollo(
        m map[string]map[string]num.Int,
) MultiAsset.MultiAsset[int64] <span class="cov0" title="0">{
        if len(m) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">assetMap := make(map[Policy.PolicyId]Asset.Asset[int64])
        for policy, tokens := range m </span><span class="cov0" title="0">{
                tokensMap := make(map[AssetName.AssetName]int64)
                for token, amt := range tokens </span><span class="cov0" title="0">{
                        tok := *AssetName.NewAssetNameFromHexString(token)
                        tokensMap[tok] = amt.Int64()
                }</span>
                <span class="cov0" title="0">pol := Policy.PolicyId{
                        Value: policy,
                }
                assetMap[pol] = make(map[AssetName.AssetName]int64)
                assetMap[pol] = tokensMap</span>
        }
        <span class="cov0" title="0">return assetMap</span>
}

func value_OgmigoToApollo(v shared.Value) Value.AlonzoValue <span class="cov0" title="0">{
        ass := multiAsset_OgmigoToApollo(v.AssetsExceptAda())
        if ass == nil </span><span class="cov0" title="0">{
                return Value.AlonzoValue{
                        Am:        Amount.AlonzoAmount{},
                        Coin:      v.AdaLovelace().Int64(),
                        HasAssets: false,
                }
        }</span>
        <span class="cov0" title="0">return Value.AlonzoValue{
                Am: Amount.AlonzoAmount{
                        Coin:  v.AdaLovelace().Int64(),
                        Value: ass,
                },
                Coin:      0,
                HasAssets: true,
        }</span>
}

func datum_OgmigoToApollo(d string, dh string) *PlutusData.DatumOption <span class="cov0" title="0">{
        if d != "" </span><span class="cov0" title="0">{
                datumBytes, err := hex.DecodeString(d)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(
                                err,
                                "OgmiosChainContext: Failed to decode datum from hex: %v",
                                d,
                        )
                }</span>
                <span class="cov0" title="0">var pd PlutusData.PlutusData
                err = cbor.Unmarshal(datumBytes, &amp;pd)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(
                                err,
                                "OgmiosChainContext: datum is not valid plutus data: %v",
                                d,
                        )
                }</span>
                <span class="cov0" title="0">res := PlutusData.DatumOptionInline(&amp;pd)
                return &amp;res</span>
        }
        <span class="cov0" title="0">if dh != "" </span><span class="cov0" title="0">{
                datumHashBytes, err := hex.DecodeString(dh)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(
                                err,
                                "OgmiosChainContext: Failed to decode datum hash from hex: %v",
                                dh,
                        )
                }</span>
                <span class="cov0" title="0">res := PlutusData.DatumOptionHash(datumHashBytes)
                return &amp;res</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func scriptRef_OgmigoToApollo(
        script json.RawMessage,
) (*PlutusData.ScriptRef, error) <span class="cov0" title="0">{
        if len(script) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">var tmpData struct {
                Language string `json:"language"`
                Cbor     string `json:"cbor"`
        }
        if err := json.Unmarshal(script, &amp;tmpData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">scriptBytes, err := hex.DecodeString(tmpData.Cbor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ref := PlutusData.ScriptRef(scriptBytes)
        return &amp;ref, nil</span>
}

func Utxo_OgmigoToApollo(u shared.Utxo) UTxO.UTxO <span class="cov0" title="0">{
        txHashRaw, err := hex.DecodeString(u.Transaction.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "Failed to decode ogmigo transaction ID")
        }</span>
        <span class="cov0" title="0">addr, err := Address.DecodeAddress(u.Address)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "Failed to decode ogmigo address")
        }</span>
        <span class="cov0" title="0">datum := datum_OgmigoToApollo(u.Datum, u.DatumHash)
        v := value_OgmigoToApollo(u.Value)
        scriptRef, err := scriptRef_OgmigoToApollo(u.Script)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "Failed to convert script ref from ogmigo")
        }</span>
        <span class="cov0" title="0">return UTxO.UTxO{
                Input: TransactionInput.TransactionInput{
                        TransactionId: txHashRaw,
                        Index:         int(u.Index),
                },
                Output: TransactionOutput.TransactionOutput{
                        PostAlonzo: TransactionOutput.TransactionOutputAlonzo{
                                Address:   addr,
                                Amount:    v,
                                Datum:     datum,
                                ScriptRef: scriptRef,
                        },
                        PreAlonzo:    TransactionOutput.TransactionOutputShelley{},
                        IsPostAlonzo: true,
                },
        }</span>
}

func (occ *OgmiosChainContext) GetUtxoFromRef(
        txHash string,
        index int,
) (*UTxO.UTxO, error) <span class="cov8" title="1">{
        ctx := context.Background()
        utxos, err := occ.ogmigo.UtxosByTxIn(ctx, chainsync.TxInQuery{
                Transaction: shared.UtxoTxID{
                        ID: txHash,
                },
                Index: uint32(index),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "REQUEST PROTOCOL")
        }</span>
        <span class="cov8" title="1">if len(utxos) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span> else<span class="cov0" title="0"> {
                apolloUtxo := Utxo_OgmigoToApollo(utxos[0])
                return &amp;apolloUtxo, nil
        }</span>
}

func statequeryValue_toAddressAmount(v shared.Value) []Base.AddressAmount <span class="cov0" title="0">{
        amts := make([]Base.AddressAmount, 0)
        amts = append(amts, Base.AddressAmount{
                Unit:     "lovelace",
                Quantity: strconv.FormatInt(v.AdaLovelace().Int64(), 10),
        })
        for policyId, tokenMap := range v.AssetsExceptAda() </span><span class="cov0" title="0">{
                for tokenName, quantity := range tokenMap </span><span class="cov0" title="0">{
                        amts = append(amts, Base.AddressAmount{
                                Unit:     policyId + tokenName,
                                Quantity: strconv.FormatInt(quantity.Int64(), 10),
                        })
                }</span>
        }
        <span class="cov0" title="0">return amts</span>
}

func kugoValue_toSharedValue(v kugo.Value) shared.Value <span class="cov0" title="0">{
        result := shared.Value{}
        for policyId, assets := range v </span><span class="cov0" title="0">{
                for assetName, amt := range assets </span><span class="cov0" title="0">{
                        if _, ok := result[policyId]; !ok </span><span class="cov0" title="0">{
                                result[policyId] = map[string]num.Int{}
                        }</span>
                        <span class="cov0" title="0">result[policyId][assetName] = amt</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

func chainsyncValue_toAddressAmount(v shared.Value) []Base.AddressAmount <span class="cov0" title="0">{
        // same as above
        return statequeryValue_toAddressAmount(v)
}</span>

func (occ *OgmiosChainContext) TxOuts(txHash string) []Base.Output <span class="cov0" title="0">{
        ctx := context.Background()
        outs := make([]Base.Output, 1)
        more_utxos := true
        chunk_size := 10
        for more_utxos </span><span class="cov0" title="0">{
                queries := make([]chainsync.TxInQuery, chunk_size)
                for ix := range queries </span><span class="cov0" title="0">{
                        queries[ix] = chainsync.TxInQuery{
                                Transaction: shared.UtxoTxID{
                                        ID: txHash,
                                },
                                Index: uint32(ix),
                        }
                }</span>
                <span class="cov0" title="0">us, err := occ.ogmigo.UtxosByTxIn(ctx, queries...)
                if len(us) &lt; chunk_size || err != nil </span><span class="cov0" title="0">{
                        more_utxos = false
                }</span>
                <span class="cov0" title="0">for _, u := range us </span><span class="cov0" title="0">{
                        am := statequeryValue_toAddressAmount(u.Value)
                        apolloUtxo := Base.Output{
                                Address:             u.Address,
                                Amount:              am,
                                OutputIndex:         int(u.Index),
                                DataHash:            u.DatumHash,
                                InlineDatum:         u.Datum,
                                Collateral:          false, // Can querying ogmios return collateral outputs?
                                ReferenceScriptHash: "",    // TODO
                        }
                        outs = append(outs, apolloUtxo)
                }</span>
        }
        <span class="cov0" title="0">return outs</span>
}

// Seems unused
func (occ *OgmiosChainContext) LatestBlock() Base.Block <span class="cov0" title="0">{
        ctx := context.Background()
        point, err := occ.ogmigo.ChainTip(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(
                        "OgmiosChainContext: LatestBlock: failed to request chain tip",
                        err,
                )
        }</span>
        <span class="cov0" title="0">s, ok := point.PointStruct()
        if !ok </span><span class="cov0" title="0">{
                log.Fatal("OgmiosChainContext: LatestBlock: expected a struct")
        }</span>
        <span class="cov0" title="0">return Base.Block{
                Hash: s.ID,
                Slot: int(s.Slot),
        }</span>
}

func (occ *OgmiosChainContext) LatestEpoch() Base.Epoch <span class="cov8" title="1">{
        ctx := context.Background()
        current, err := occ.ogmigo.CurrentEpoch(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(
                        err,
                        "OgmiosChainContext: LatestEpoch: failed to request current epoch",
                )
        }</span>
        <span class="cov8" title="1">return Base.Epoch{
                Epoch: int(current),
        }</span>
}

func (occ *OgmiosChainContext) AddressUtxos(
        address string,
        gather bool,
) []Base.AddressUTXO <span class="cov0" title="0">{
        ctx := context.Background()
        addressUtxos := make([]Base.AddressUTXO, 0)
        matches, err := occ.kugo.Matches(
                ctx,
                kugo.OnlyUnspent(),
                kugo.Address(address),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "OgmiosChainContext: AddressUtxos: kupo request failed")
        }</span>
        <span class="cov0" title="0">for _, match := range matches </span><span class="cov0" title="0">{
                datum := ""
                if match.DatumType == "inline" </span><span class="cov0" title="0">{
                        datum, err = occ.kugo.Datum(ctx, match.DatumHash)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(
                                        err,
                                        "OgmiosChainContext: AddressUtxos: kupo datum request failed",
                                )
                        }</span>
                }
                <span class="cov0" title="0">addressUtxos = append(addressUtxos, Base.AddressUTXO{
                        TxHash:      match.TransactionID,
                        OutputIndex: match.OutputIndex,
                        Amount: chainsyncValue_toAddressAmount(
                                kugoValue_toSharedValue(match.Value),
                        ),
                        // We probably don't need this info and kupo doesn't provide it in this query
                        Block:       "",
                        DataHash:    match.DatumHash,
                        InlineDatum: datum,
                })</span>
        }
        <span class="cov0" title="0">return addressUtxos</span>

}

type Lovelace struct {
        Lovelace uint64 `json:"lovelace"`
}

type Bytes struct {
        Bytes uint64 `json:"bytes"`
}

type Prices struct {
        Memory float64 `json:"memory"`
        Cpu    float64 `json:"cpu"`
}

func parseFraction(s string) (int64, int64, error) <span class="cov8" title="1">{
        before, after, found := strings.Cut(s, "/")
        if !found </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("parseFraction: Not a fraction: %s", s)
        }</span>
        <span class="cov8" title="1">n, err := strconv.ParseInt(before, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("parseFraction: %w", err)
        }</span>
        <span class="cov8" title="1">d, err := strconv.ParseInt(after, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("parseFraction: %w", err)
        }</span>
        <span class="cov8" title="1">return n, d, nil</span>
}

func (p *Prices) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        var x struct {
                Memory string `json:"memory"`
                Cpu    string `json:"cpu"`
        }
        err := json.Unmarshal(b, &amp;x)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">mn, md, err := parseFraction(x.Memory)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.Memory = float64(mn) / float64(md)
        cn, cd, err := parseFraction(x.Cpu)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.Cpu = float64(cn) / float64(cd)
        return nil</span>
}

type Version struct {
        Major uint64 `json:"major"`
        Minor uint64 `json:"minor"`
        Patch uint64 `json:"patch"`
}

type ExUnits struct {
        Cpu    uint64 `json:"cpu"`
        Memory uint64 `json:"memory"`
}

type OgmiosProtocolParameters struct {
        MinFeeConstant                  Lovelace               `json:"minFeeConstant"`
        MinFeeCoefficient               uint64                 `json:"minFeeCoefficient"`
        MaxBlockSize                    Bytes                  `json:"maxBlockBodySize"`
        MaxTxSize                       Bytes                  `json:"maxTransactionSize"`
        MaxBlockHeaderSize              Bytes                  `json:"maxBlockHeaderSize"`
        KeyDeposits                     Lovelace               `json:"stakeCredentialDeposit"`
        PoolDeposits                    Lovelace               `json:"stakePoolDeposit"`
        PoolInfluence                   string                 `json:"stakePoolPledgeInfluence"`
        MonetaryExpansion               string                 `json:"monetaryExpansion"`
        TreasuryExpansion               string                 `json:"treasuryExpansion"`
        ExtraEntropy                    string                 `json:"extraEntropy"`
        MaxValSize                      Bytes                  `json:"maxValueSize"`
        ScriptExecutionPrices           Prices                 `json:"scriptExecutionPrices"`
        MinUtxoDepositCoefficient       uint64                 `json:"minUtxoDepositCoefficient"`
        MinUtxoDepositConstant          Lovelace               `json:"minUtxoDepositConstant"`
        MinStakePoolCost                Lovelace               `json:"minStakePoolCost"`
        MaxExecutionUnitsPerTransaction ExUnits                `json:"maxExecutionUnitsPerTransaction"`
        MaxExecutionUnitsPerBlock       ExUnits                `json:"maxExecutionUnitsPerBlock"`
        CollateralPercentage            uint64                 `json:"collateralPercentage"`
        MaxCollateralInputs             uint64                 `json:"maxCollateralInputs"`
        MaximumReferenceScriptsSize     uint64                 `json:"maximumReferenceScriptsSize"`
        MinFeeReferenceScripts          MinFeeReferenceScripts `json:"minFeeReferenceScripts"`
        Version                         Version                `json:"version"`
        CostModels                      map[string][]int64     `json:"plutusCostModels"`
}

type MinFeeReferenceScripts struct {
        Range      float64 `json:"range"`
        Base       float64 `json:"base"`
        Multiplier float64 `json:"multiplier"`
}

func ratio(s string) float32 <span class="cov8" title="1">{
        n, d, ok := strings.Cut(s, "/")
        if !ok </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">num, err := strconv.Atoi(n)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">den, err := strconv.Atoi(d)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return float32(num) / float32(den)</span>
}

func (occ *OgmiosChainContext) LatestEpochParams() Base.ProtocolParameters <span class="cov8" title="1">{
        ctx := context.Background()
        pparams, err := occ.ogmigo.CurrentProtocolParameters(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(
                        err,
                        "OgmiosChainContext: LatestEpochParams: protocol parameters request failed",
                )
        }</span>
        <span class="cov8" title="1">var ogmiosParams OgmiosProtocolParameters
        if err := json.Unmarshal(pparams, &amp;ogmiosParams); err != nil </span><span class="cov0" title="0">{
                log.Fatal(
                        err,
                        "OgmiosChainContext: LatestEpochParams: failed to parse protocol parameters",
                )
        }</span>

        <span class="cov8" title="1">return Base.ProtocolParameters{
                MinFeeConstant:     int64(ogmiosParams.MinFeeConstant.Lovelace),
                MinFeeCoefficient:  int64(ogmiosParams.MinFeeCoefficient),
                MaxBlockSize:       int(ogmiosParams.MaxBlockSize.Bytes),
                MaxTxSize:          int(ogmiosParams.MaxTxSize.Bytes),
                MaxBlockHeaderSize: int(ogmiosParams.MaxBlockHeaderSize.Bytes),
                KeyDeposits: strconv.FormatUint(
                        ogmiosParams.KeyDeposits.Lovelace,
                        10,
                ),
                PoolDeposits: strconv.FormatUint(
                        ogmiosParams.PoolDeposits.Lovelace,
                        10,
                ),
                PooolInfluence:    ratio(ogmiosParams.PoolInfluence),
                MonetaryExpansion: ratio(ogmiosParams.MonetaryExpansion),
                TreasuryExpansion: ratio(ogmiosParams.TreasuryExpansion),
                // Unsure if ogmios reports this, but it's 0 on mainnet and
                // preview
                DecentralizationParam: 0,
                ExtraEntropy:          ogmiosParams.ExtraEntropy,
                MinUtxo: strconv.FormatUint(
                        ogmiosParams.MinUtxoDepositConstant.Lovelace,
                        10,
                ),
                ProtocolMajorVersion: int(ogmiosParams.Version.Major),
                ProtocolMinorVersion: int(ogmiosParams.Version.Minor),
                MinPoolCost: strconv.FormatUint(
                        ogmiosParams.MinStakePoolCost.Lovelace,
                        10,
                ),
                PriceMem: float32(
                        ogmiosParams.ScriptExecutionPrices.Memory,
                ),
                PriceStep: float32(ogmiosParams.ScriptExecutionPrices.Cpu),
                MaxTxExMem: strconv.FormatUint(
                        ogmiosParams.MaxExecutionUnitsPerTransaction.Memory,
                        10,
                ),
                MaxTxExSteps: strconv.FormatUint(
                        ogmiosParams.MaxExecutionUnitsPerTransaction.Cpu,
                        10,
                ),
                MaxBlockExMem: strconv.FormatUint(
                        ogmiosParams.MaxExecutionUnitsPerBlock.Memory,
                        10,
                ),
                MaxBlockExSteps: strconv.FormatUint(
                        ogmiosParams.MaxExecutionUnitsPerBlock.Cpu,
                        10,
                ),
                MaxValSize: strconv.FormatUint(
                        ogmiosParams.MaxValSize.Bytes,
                        10,
                ),
                CollateralPercent:  int(ogmiosParams.CollateralPercentage),
                MaxCollateralInuts: int(ogmiosParams.MaxCollateralInputs),
                CoinsPerUtxoByte: strconv.FormatUint(
                        ogmiosParams.MinUtxoDepositCoefficient,
                        10,
                ),
                // PerUtxoWord is deprecated https://cips.cardano.org/cips/cip55/
                CoinsPerUtxoWord: strconv.FormatUint(
                        ogmiosParams.MinUtxoDepositCoefficient,
                        10,
                ),
                MaximumReferenceScriptsSize: int(
                        ogmiosParams.MaximumReferenceScriptsSize,
                ),
                MinFeeReferenceScriptsRange: int(
                        ogmiosParams.MinFeeReferenceScripts.Range,
                ),
                MinFeeReferenceScriptsBase: int(
                        ogmiosParams.MinFeeReferenceScripts.Base,
                ),
                MinFeeReferenceScriptsMultiplier: int(
                        ogmiosParams.MinFeeReferenceScripts.Multiplier,
                ),
                CostModels: ogmiosParams.CostModels,
        }</span>
}

func (occ *OgmiosChainContext) GenesisParams() Base.GenesisParameters <span class="cov8" title="1">{
        genesisParams := Base.GenesisParameters{}
        //TODO
        return genesisParams
}</span>
func (occ *OgmiosChainContext) _CheckEpochAndUpdate() bool <span class="cov8" title="1">{
        if occ._epoch_info.EndTime &lt;= int(time.Now().Unix()) </span><span class="cov8" title="1">{
                latest_epochs := occ.LatestEpoch()
                occ._epoch_info = latest_epochs
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (occ *OgmiosChainContext) Network() int <span class="cov0" title="0">{
        return occ._Network
}</span>

func (occ *OgmiosChainContext) Epoch() (int, error) <span class="cov0" title="0">{
        if occ._CheckEpochAndUpdate() </span><span class="cov0" title="0">{
                new_epoch := occ.LatestEpoch()
                occ._epoch = new_epoch.Epoch
        }</span>
        <span class="cov0" title="0">return occ._epoch, nil</span>
}

// Seems unused
func (occ *OgmiosChainContext) LastBlockSlot() (int, error) <span class="cov0" title="0">{
        block := occ.LatestBlock()
        return block.Slot, nil
}</span>

func (occ *OgmiosChainContext) GetGenesisParams() (Base.GenesisParameters, error) <span class="cov0" title="0">{
        if occ._CheckEpochAndUpdate() </span><span class="cov0" title="0">{
                params := occ.GenesisParams()
                occ._genesis_param = params
        }</span>
        <span class="cov0" title="0">return occ._genesis_param, nil</span>
}

func (occ *OgmiosChainContext) GetProtocolParams() (Base.ProtocolParameters, error) <span class="cov8" title="1">{
        if occ._CheckEpochAndUpdate() </span><span class="cov8" title="1">{
                latest_params := occ.LatestEpochParams()
                occ._protocol_param = latest_params
        }</span>
        <span class="cov8" title="1">return occ._protocol_param, nil</span>
}

func (occ *OgmiosChainContext) MaxTxFee() (int, error) <span class="cov8" title="1">{
        protocol_param, _ := occ.GetProtocolParams()
        maxTxExSteps, _ := strconv.Atoi(protocol_param.MaxTxExSteps)
        maxTxExMem, _ := strconv.Atoi(protocol_param.MaxTxExMem)
        return Base.Fee(occ, protocol_param.MaxTxSize, maxTxExSteps, maxTxExMem)
}</span>

// Copied from blockfrost context def since it just calls AddressUtxos and then
// converts
func (occ *OgmiosChainContext) Utxos(
        address Address.Address,
) ([]UTxO.UTxO, error) <span class="cov0" title="0">{
        results := occ.AddressUtxos(address.String(), true)
        utxos := make([]UTxO.UTxO, 0)
        for _, result := range results </span><span class="cov0" title="0">{
                decodedTxId, _ := hex.DecodeString(result.TxHash)
                tx_in := TransactionInput.TransactionInput{
                        TransactionId: decodedTxId,
                        Index:         result.OutputIndex,
                }
                amount := result.Amount
                lovelace_amount := 0
                multi_assets := MultiAsset.MultiAsset[int64]{}
                for _, item := range amount </span><span class="cov0" title="0">{
                        if item.Unit == "lovelace" </span><span class="cov0" title="0">{
                                amount, err := strconv.Atoi(item.Quantity)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Fatal(err)
                                }</span>
                                <span class="cov0" title="0">lovelace_amount += amount</span>
                        } else<span class="cov0" title="0"> {
                                asset_quantity, err := strconv.ParseInt(item.Quantity, 10, 64)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Fatal(err)
                                }</span>
                                <span class="cov0" title="0">policy_id := Policy.PolicyId{Value: item.Unit[:56]}
                                asset_name := *AssetName.NewAssetNameFromHexString(item.Unit[56:])
                                _, ok := multi_assets[policy_id]
                                if !ok </span><span class="cov0" title="0">{
                                        multi_assets[policy_id] = Asset.Asset[int64]{}
                                }</span>
                                <span class="cov0" title="0">multi_assets[policy_id][asset_name] = int64(asset_quantity)</span>
                        }
                }
                <span class="cov0" title="0">var final_amount Value.Value
                if len(multi_assets) &gt; 0 </span><span class="cov0" title="0">{
                        final_amount = Value.Value{
                                Am: Amount.Amount{
                                        Coin:  int64(lovelace_amount),
                                        Value: multi_assets,
                                },
                                HasAssets: true,
                        }
                }</span> else<span class="cov0" title="0"> {
                        final_amount = Value.Value{Coin: int64(lovelace_amount), HasAssets: false}
                }</span>
                <span class="cov0" title="0">datum_hash := serialization.DatumHash{}
                if result.DataHash != "" &amp;&amp; result.InlineDatum == "" </span><span class="cov0" title="0">{

                        datum_hash = serialization.DatumHash{}
                        copy(datum_hash.Payload[:], result.DataHash[:])
                }</span>
                <span class="cov0" title="0">var tx_out TransactionOutput.TransactionOutput
                if result.InlineDatum != "" </span><span class="cov0" title="0">{
                        decoded, err := hex.DecodeString(result.InlineDatum)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">var x PlutusData.PlutusData
                        err = cbor.Unmarshal(decoded, &amp;x)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                        <span class="cov0" title="0">l := PlutusData.DatumOptionInline(&amp;x)
                        tx_out = TransactionOutput.TransactionOutput{IsPostAlonzo: true,
                                PostAlonzo: TransactionOutput.TransactionOutputAlonzo{
                                        Address: address,
                                        Amount:  final_amount.ToAlonzoValue(),
                                        Datum:   &amp;l},
                        }</span>
                } else<span class="cov0" title="0"> {
                        tx_out = TransactionOutput.TransactionOutput{PreAlonzo: TransactionOutput.TransactionOutputShelley{
                                Address:   address,
                                Amount:    final_amount,
                                DatumHash: datum_hash,
                                HasDatum:  len(datum_hash.Payload) &gt; 0}, IsPostAlonzo: false}
                }</span>
                <span class="cov0" title="0">utxos = append(utxos, UTxO.UTxO{Input: tx_in, Output: tx_out})</span>
        }
        <span class="cov0" title="0">return utxos, nil</span>
}

func (occ *OgmiosChainContext) SubmitTx(
        tx Transaction.Transaction,
) (serialization.TransactionId, error) <span class="cov0" title="0">{
        ctx := context.Background()
        bytes, err := tx.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "OgmiosChainContext: SubmitTx: Error getting tx bytes")
        }</span>
        <span class="cov0" title="0">_, err = occ.ogmigo.SubmitTx(ctx, hex.EncodeToString(bytes))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "OgmiosChainContext: SubmitTx: Error submitting tx")
        }</span>
        <span class="cov0" title="0">txId, _ := tx.TransactionBody.Id()
        return txId, nil</span>

}

func (occ *OgmiosChainContext) EvaluateTx(
        tx []uint8,
) (map[string]Redeemer.ExecutionUnits, error) <span class="cov8" title="1">{
        final_result := make(map[string]Redeemer.ExecutionUnits)
        ctx := context.Background()
        eval, err := occ.ogmigo.EvaluateTx(ctx, hex.EncodeToString(tx))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err, "OgmiosChainContext: EvaluateTx: Error evaluating tx")
        }</span>
        <span class="cov8" title="1">for _, e := range eval.ExUnits </span><span class="cov0" title="0">{
                final_result[e.Validator.Purpose] = Redeemer.ExecutionUnits{
                        Mem:   int64(e.Budget.Memory),
                        Steps: int64(e.Budget.Cpu),
                }
        }</span>
        <span class="cov8" title="1">return final_result, nil</span>
}

// This is unused
func (occ *OgmiosChainContext) GetContractCbor(
        scriptHash string,
) (string, error) <span class="cov0" title="0">{
        //TODO
        return "", nil
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package UtxorpcChainContext

import (
        "encoding/hex"
        "errors"
        "fmt"
        "strconv"
        "time"

        "connectrpc.com/connect"
        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/Address"
        "github.com/Salvionied/apollo/serialization/Redeemer"
        "github.com/Salvionied/apollo/serialization/Transaction"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/utxorpc/go-codegen/utxorpc/v1alpha/query"
        utxorpc "github.com/utxorpc/go-sdk"
        "github.com/utxorpc/go-sdk/cardano"
)

type UtxorpcChainContext struct {
        _Network        int
        _protocol_param Base.ProtocolParameters
        _genesis_param  Base.GenesisParameters
        client          *cardano.Client
        latestUpdate    time.Time
}

// Interface requirements (no UTxO RPC equivalent, yet)
func (u *UtxorpcChainContext) GetContractCbor(
        scriptHash string,
) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func NewUtxorpcChainContext(
        baseUrl string,
        network int,
        dmtrApiKey ...string,
) (UtxorpcChainContext, error) <span class="cov8" title="1">{
        var _dmtrApiKey string
        if len(dmtrApiKey) &gt; 0 </span><span class="cov0" title="0">{
                _dmtrApiKey = dmtrApiKey[0]
        }</span>
        // Check config
        <span class="cov8" title="1">if baseUrl == "" &amp;&amp; _dmtrApiKey == "" </span><span class="cov0" title="0">{
                return UtxorpcChainContext{}, errors.New(
                        "provide either a URL or a Demeter API key",
                )
        }</span>

        <span class="cov8" title="1">var networkString string
        switch network </span>{
        case 0:<span class="cov8" title="1">
                networkString = "mainnet"</span>
        case 1:<span class="cov0" title="0">
                networkString = "testnet"</span> // ?
        case 2:<span class="cov0" title="0">
                networkString = "preview"</span>
        case 3:<span class="cov0" title="0">
                networkString = "preprod"</span>
        default:<span class="cov0" title="0">
                return UtxorpcChainContext{}, errors.New("invalid network")</span>
        }
        <span class="cov8" title="1">if baseUrl == "" </span><span class="cov0" title="0">{
                baseUrl = fmt.Sprintf(
                        "https://%s.utxorpc-v0.demeter.run",
                        networkString,
                )
        }</span>
        <span class="cov8" title="1">cardanoclient := cardano.NewClient(utxorpc.WithBaseUrl(baseUrl))
        if _dmtrApiKey != "" </span><span class="cov0" title="0">{
                cardanoclient.UtxorpcClient.SetHeader("dmtr-api-key", _dmtrApiKey)
        }</span>
        <span class="cov8" title="1">u := UtxorpcChainContext{
                client: cardanoclient, _Network: network,
        }
        err := u.init()
        return u, err</span>
}

func (u *UtxorpcChainContext) init() error <span class="cov8" title="1">{
        _, err := u.GetProtocolParams()
        return err
}</span>

func (u *UtxorpcChainContext) Network() int <span class="cov0" title="0">{
        return u._Network
}</span>

func (u *UtxorpcChainContext) GetGenesisParams() (Base.GenesisParameters, error) <span class="cov0" title="0">{
        if time.Since(u.latestUpdate) &gt; time.Minute*5 </span><span class="cov0" title="0">{
                genesisParams := Base.GenesisParameters{}
                gpFromApi, err := u.client.UtxorpcClient.ReadGenesis(
                        connect.NewRequest(&amp;query.ReadGenesisRequest{}),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return genesisParams, err
                }</span>
                <span class="cov0" title="0">gpCardano := gpFromApi.Msg.GetCardano()
                // Map the fields
                if gpCardano.GetActiveSlotsCoeff() != nil </span><span class="cov0" title="0">{
                        genesisParams.ActiveSlotsCoefficient = float32(
                                gpCardano.GetActiveSlotsCoeff().GetNumerator(),
                        ) / float32(
                                gpCardano.GetActiveSlotsCoeff().GetDenominator(),
                        )
                }</span>
                <span class="cov0" title="0">genesisParams.UpdateQuorum = int(gpCardano.GetUpdateQuorum())
                if gpCardano.GetMaxLovelaceSupply() != nil </span><span class="cov0" title="0">{
                        genesisParams.MaxLovelaceSupply = gpCardano.GetMaxLovelaceSupply().
                                String()
                }</span>
                <span class="cov0" title="0">genesisParams.NetworkMagic = int(gpCardano.GetNetworkMagic())
                genesisParams.EpochLength = int(gpCardano.GetEpochLength())
                // SystemStart is a string timestamp, need to parse to unix timestamp
                // For now, leave as 0 or parse if needed
                genesisParams.SlotsPerKesPeriod = int(gpCardano.GetSlotsPerKesPeriod())
                genesisParams.SlotLength = int(gpCardano.GetSlotLength())
                genesisParams.MaxKesEvolutions = int(gpCardano.GetMaxKesEvolutions())
                genesisParams.SecurityParam = int(gpCardano.GetSecurityParam())

                u._genesis_param = genesisParams
                u.latestUpdate = time.Now()
                return genesisParams, nil</span>
        }
        <span class="cov0" title="0">return u._genesis_param, nil</span>
}

func (u *UtxorpcChainContext) GetProtocolParams() (Base.ProtocolParameters, error) <span class="cov8" title="1">{
        if time.Since(u.latestUpdate) &gt; time.Minute*5 </span><span class="cov8" title="1">{
                protocolParams := Base.ProtocolParameters{}
                ppFromApi, err := u.client.UtxorpcClient.ReadParams(
                        connect.NewRequest(&amp;query.ReadParamsRequest{}),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return protocolParams, err
                }</span>
                <span class="cov8" title="1">ppCardano := ppFromApi.Msg.GetValues().GetCardano()
                // Map ALL the fields
                minFeeConstant, _ := strconv.ParseInt(
                        ppCardano.GetMinFeeConstant().String(),
                        10,
                        64,
                )
                minFeeCoefficient, _ := strconv.ParseInt(
                        ppCardano.GetMinFeeCoefficient().String(),
                        10,
                        64,
                )
                protocolParams.MinFeeConstant = minFeeConstant
                protocolParams.MinFeeCoefficient = minFeeCoefficient
                protocolParams.MaxTxSize = int(ppCardano.GetMaxTxSize())
                protocolParams.MaxBlockSize = int(ppCardano.GetMaxBlockBodySize())
                protocolParams.MaxBlockHeaderSize = int(
                        ppCardano.GetMaxBlockHeaderSize(),
                )
                stakeKeyDeposit, _ := strconv.ParseUint(
                        ppCardano.GetStakeKeyDeposit().String(),
                        10,
                        64,
                )
                poolDeposit, _ := strconv.ParseUint(
                        ppCardano.GetPoolDeposit().String(),
                        10,
                        64,
                )
                protocolParams.KeyDeposits = strconv.FormatUint(stakeKeyDeposit, 10)
                protocolParams.PoolDeposits = strconv.FormatUint(poolDeposit, 10)
                if ppCardano.GetPoolInfluence().GetDenominator() != 0 </span><span class="cov8" title="1">{
                        protocolParams.PooolInfluence = float32(
                                uint32(
                                        ppCardano.GetPoolInfluence().GetNumerator(),
                                ) / ppCardano.GetPoolInfluence().
                                        GetDenominator(),
                        )
                }</span> else<span class="cov0" title="0"> {
                        protocolParams.PooolInfluence = 0
                }</span>
                <span class="cov8" title="1">if ppCardano.GetMonetaryExpansion().GetDenominator() != 0 </span><span class="cov8" title="1">{
                        protocolParams.MonetaryExpansion = float32(
                                uint32(
                                        ppCardano.GetMonetaryExpansion().GetNumerator(),
                                ) / ppCardano.GetMonetaryExpansion().
                                        GetDenominator(),
                        )
                }</span> else<span class="cov0" title="0"> {
                        protocolParams.MonetaryExpansion = 0
                }</span>
                <span class="cov8" title="1">if ppCardano.GetTreasuryExpansion().GetDenominator() != 0 </span><span class="cov8" title="1">{
                        protocolParams.TreasuryExpansion = float32(
                                uint32(
                                        ppCardano.GetTreasuryExpansion().GetNumerator(),
                                ) / ppCardano.GetTreasuryExpansion().
                                        GetDenominator(),
                        )
                }</span> else<span class="cov0" title="0"> {
                        protocolParams.TreasuryExpansion = 0
                }</span>
                <span class="cov8" title="1">protocolParams.DecentralizationParam = 0
                protocolParams.ExtraEntropy = ""
                protocolParams.ProtocolMajorVersion = int(
                        ppCardano.GetProtocolVersion().GetMajor(),
                )
                protocolParams.ProtocolMinorVersion = int(
                        ppCardano.GetProtocolVersion().GetMinor(),
                )
                //CHECK HERE
                //protocolParams.MinUtxo = ppFromApi.Data.
                protocolParams.MinPoolCost = ppCardano.GetMinPoolCost().String()
                if ppCardano.GetPrices().GetMemory().GetDenominator() != 0 </span><span class="cov8" title="1">{
                        protocolParams.PriceMem = float32(
                                uint32(
                                        ppCardano.GetPrices().GetMemory().GetNumerator(),
                                ) / ppCardano.GetPrices().
                                        GetMemory().
                                        GetDenominator(),
                        )
                }</span> else<span class="cov0" title="0"> {
                        protocolParams.PriceMem = 0
                }</span>
                <span class="cov8" title="1">if ppCardano.GetPrices().GetSteps().GetDenominator() != 0 </span><span class="cov8" title="1">{
                        protocolParams.PriceStep = float32(
                                uint32(
                                        ppCardano.GetPrices().GetSteps().GetNumerator(),
                                ) / ppCardano.GetPrices().
                                        GetSteps().
                                        GetDenominator(),
                        )
                }</span> else<span class="cov0" title="0"> {
                        protocolParams.PriceStep = 0
                }</span>
                <span class="cov8" title="1">protocolParams.MaxTxExMem = strconv.FormatUint(
                        ppCardano.GetMaxExecutionUnitsPerTransaction().GetMemory(),
                        10,
                )
                protocolParams.MaxTxExSteps = strconv.FormatUint(
                        ppCardano.GetMaxExecutionUnitsPerTransaction().GetSteps(),
                        10,
                )
                protocolParams.MaxBlockExMem = strconv.FormatUint(
                        ppCardano.GetMaxExecutionUnitsPerBlock().GetMemory(),
                        10,
                )
                protocolParams.MaxBlockExSteps = strconv.FormatUint(
                        ppCardano.GetMaxExecutionUnitsPerBlock().GetSteps(),
                        10,
                )
                protocolParams.MaxValSize = strconv.FormatUint(
                        ppCardano.GetMaxValueSize(),
                        10,
                )
                protocolParams.CollateralPercent = int(
                        ppCardano.GetCollateralPercentage(),
                )
                protocolParams.MaxCollateralInuts = int(
                        ppCardano.GetMaxCollateralInputs(),
                )
                protocolParams.CoinsPerUtxoByte = ppCardano.GetCoinsPerUtxoByte().
                        String()
                protocolParams.CoinsPerUtxoWord = "0"
                protocolParams.CostModels = map[string][]int64{
                        "PlutusV1": ppCardano.GetCostModels().GetPlutusV1().GetValues(),
                        "PlutusV2": ppCardano.GetCostModels().GetPlutusV2().GetValues(),
                        "PlutusV3": ppCardano.GetCostModels().GetPlutusV3().GetValues(),
                }
                u._protocol_param = protocolParams
                u.latestUpdate = time.Now()</span>
        }
        <span class="cov8" title="1">return u._protocol_param, nil</span>
}

func (u *UtxorpcChainContext) GetUtxoFromRef(
        txHash string,
        txIndex int,
) (*UTxO.UTxO, error) <span class="cov8" title="1">{
        resp, err := u.client.GetUtxoByRef(txHash, uint32(txIndex))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read UTxO: %w", err)
        }</span>

        <span class="cov8" title="1">if len(resp.Msg.Items) == 0 </span><span class="cov8" title="1">{
                return nil, nil // Not found
        }</span>

        <span class="cov0" title="0">item := resp.Msg.Items[0]
        tmpUtxo := UTxO.UTxO{}
        tmpUtxo.Input = TransactionInput.TransactionInput{
                TransactionId: item.TxoRef.Hash,
                Index:         int(item.TxoRef.Index),
        }
        tmpOutput := TransactionOutput.TransactionOutput{}
        err = tmpOutput.UnmarshalCBOR(item.NativeBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal output: %w", err)
        }</span>
        <span class="cov0" title="0">tmpUtxo.Output = tmpOutput
        return &amp;tmpUtxo, nil</span>
}

func (u *UtxorpcChainContext) EvaluateTx(
        txBytes []byte,
) (map[string]Redeemer.ExecutionUnits, error) <span class="cov8" title="1">{
        resp, err := u.client.EvaluateTransaction(hex.EncodeToString(txBytes))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to evaluate transaction: %w", err)
        }</span>

        // Parse the response
        <span class="cov0" title="0">result := make(map[string]Redeemer.ExecutionUnits)
        report := resp.Msg.GetReport()
        if report != nil </span><span class="cov0" title="0">{
                if cardanoEval := report.GetCardano(); cardanoEval != nil </span><span class="cov0" title="0">{
                        tagStrings := []string{"spend", "mint", "cert", "wdrl"}
                        for _, r := range cardanoEval.Redeemers </span><span class="cov0" title="0">{
                                tagStr := tagStrings[r.Purpose]
                                key := fmt.Sprintf("%s:%d", tagStr, r.Index)
                                result[key] = Redeemer.ExecutionUnits{
                                        Steps: int64(r.ExUnits.Steps),
                                        Mem:   int64(r.ExUnits.Memory),
                                }
                        }</span>
                }
        }
        <span class="cov0" title="0">return result, nil</span>
}

func (u *UtxorpcChainContext) Epoch() (int, error) <span class="cov0" title="0">{
        resp, err := u.client.GetTip()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read tip: %w", err)
        }</span>
        <span class="cov0" title="0">slot := resp.Msg.Tip.Slot
        epochLength := uint64(432000) // Mainnet epoch length
        if u._Network != 0 </span><span class="cov0" title="0">{
                epochLength = 86400 // Testnet
        }</span>
        <span class="cov0" title="0">epoch := int(slot / epochLength)
        return epoch, nil</span>
}

func (u *UtxorpcChainContext) MaxTxFee() (int, error) <span class="cov8" title="1">{
        protocol_param, err := u.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">maxTxExSteps, err := strconv.Atoi(protocol_param.MaxTxExSteps)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">maxTxExMem, err := strconv.Atoi(protocol_param.MaxTxExMem)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return Base.Fee(u, protocol_param.MaxTxSize, maxTxExSteps, maxTxExMem)</span>
}

func (u *UtxorpcChainContext) LastBlockSlot() (int, error) <span class="cov0" title="0">{
        ppFromApi, err := u.client.UtxorpcClient.ReadParams(
                connect.NewRequest(&amp;query.ReadParamsRequest{}),
        )
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return int(ppFromApi.Msg.GetLedgerTip().GetSlot()), nil</span>
}

func (u *UtxorpcChainContext) Utxos(
        address Address.Address,
) ([]UTxO.UTxO, error) <span class="cov0" title="0">{
        addrCbor, err := address.MarshalCBOR()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal address: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := u.client.GetUtxosByAddress(addrCbor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get UTxOs: %w", err)
        }</span>

        <span class="cov0" title="0">ret := make([]UTxO.UTxO, 0, len(resp.Msg.Items))
        for _, item := range resp.Msg.Items </span><span class="cov0" title="0">{
                tmpUtxo := UTxO.UTxO{}
                tmpUtxo.Input = TransactionInput.TransactionInput{
                        TransactionId: item.TxoRef.Hash,
                        Index:         int(item.TxoRef.Index),
                }
                tmpOutput := TransactionOutput.TransactionOutput{}
                err = tmpOutput.UnmarshalCBOR(item.NativeBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return ret, fmt.Errorf("failed to unmarshal output: %w", err)
                }</span>
                <span class="cov0" title="0">tmpUtxo.Output = tmpOutput
                ret = append(ret, tmpUtxo)</span>
        }
        <span class="cov0" title="0">return ret, nil</span>
}

func (u *UtxorpcChainContext) SubmitTx(
        tx Transaction.Transaction,
) (serialization.TransactionId, error) <span class="cov8" title="1">{
        txBytes, err := tx.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return serialization.TransactionId{}, fmt.Errorf(
                        "failed to encode transaction: %w",
                        err,
                )
        }</span>

        <span class="cov8" title="1">resp, err := u.client.SubmitTransaction(hex.EncodeToString(txBytes))
        if err != nil </span><span class="cov8" title="1">{
                return serialization.TransactionId{}, fmt.Errorf(
                        "failed to submit transaction: %w",
                        err,
                )
        }</span>

        <span class="cov0" title="0">return serialization.TransactionId{Payload: resp.Msg.GetRef()}, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package Errors

import (
        "fmt"

        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
)

type InvalidTransactionException struct {
        Inputs  []UTxO.UTxO
        Outputs []TransactionOutput.TransactionOutput
        Fees    int64
}

/*
*

                Error returns a formatted error message for the InvalidTransactionException.

                Returns:
                           string: The formatted error message describing the exception.
*/
func (i *InvalidTransactionException) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf(`
                The Input UTxOs cannot cover the transaction Outputs and tx fee. \n
                Inputs: %v \n
                Outputs: %v \n
                Fees: %d \n
        `, i.Inputs, i.Outputs, i.Fees)
}</span>

type TransactionTooBigError struct {
        Msg string
}

/*
*

        Error returns the error message associated with the TransactionTooBigError.

        Returns:
*/
func (i *TransactionTooBigError) Error() string <span class="cov0" title="0">{
        return i.Msg
}</span>

type InputExclusionError struct {
        Msg string
}

/*
* Error returns the error message associated with the InputExclusionError.

                Returns:
                          string: The error message describing the error.
*/
func (i *InputExclusionError) Error() string <span class="cov0" title="0">{
        return i.Msg
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package TxBuilder

import (
        "encoding/hex"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/PlutusData"
        "github.com/Salvionied/apollo/serialization/TransactionWitnessSet"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"
        "github.com/fxamacker/cbor/v2"
)

// import (
//         "encoding/hex"
//         "errors"
//         "fmt"
//         "reflect"
//         "sort"
//         "strconv"

//         "github.com/Salvionied/apollo/serialization"
//         "github.com/Salvionied/apollo/serialization/Address"
//         "github.com/Salvionied/apollo/serialization/Amount"
//         "github.com/Salvionied/apollo/serialization/Asset"
//         "github.com/Salvionied/apollo/serialization/AssetName"
//         "github.com/Salvionied/apollo/serialization/Certificate"
//         "github.com/Salvionied/apollo/serialization/Key"
//         "github.com/Salvionied/apollo/serialization/Metadata"
//         "github.com/Salvionied/apollo/serialization/MultiAsset"
//         "github.com/Salvionied/apollo/serialization/NativeScript"
//         "github.com/Salvionied/apollo/serialization/PlutusData"
//         "github.com/Salvionied/apollo/serialization/Policy"
//         "github.com/Salvionied/apollo/serialization/Redeemer"
//         "github.com/Salvionied/apollo/serialization/Transaction"
//         "github.com/Salvionied/apollo/serialization/TransactionBody"
//         "github.com/Salvionied/apollo/serialization/TransactionInput"
//         "github.com/Salvionied/apollo/serialization/TransactionOutput"
//         "github.com/Salvionied/apollo/serialization/TransactionWitnessSet"
//         "github.com/Salvionied/apollo/serialization/UTxO"
//         "github.com/Salvionied/apollo/serialization/Value"
//         "github.com/Salvionied/apollo/serialization/Withdrawal"
//         "github.com/Salvionied/apollo/txBuilding/Backend/Base"
//         "github.com/Salvionied/apollo/txBuilding/CoinSelection"
//         "github.com/Salvionied/apollo/txBuilding/Errors"
//         "github.com/Salvionied/apollo/txBuilding/Utils"

//         "github.com/fxamacker/cbor/v2"
//         "golang.org/x/exp/slices"
// )

// //SOON TO BE DEPRECATED

// var FAKE_ADDRESS, _ = Address.DecodeAddress("addr1v8xrqjtlfluk9axpmjj5enh0uw0cduwhz7txsqyl36m3ukgqdsn8w")
// var fake_vkey_decoded, err = hex.DecodeString("5797dc2cc919dfec0bb849551ebdf30d96e5cbe0f33f734a87fe826db30f7ef9")

// var fake_vkey = Key.VerificationKey{Payload: fake_vkey_decoded}

// var fake_tx_signature, _ = hex.DecodeString("577ccb5b487b64e396b0976c6f71558e52e44ad254db7d06dfb79843e5441a5d763dd42a")

// /**
// * TransactionBuilder
// * This is the main object used to build a transaction. Soon To Be Deprecated
// **/
// type TransactionBuilder struct {
//         Context                      Base.ChainContext
//         UtxoSelectors                []CoinSelection.UTxOSelector
//         ExecutionMemoryBuffer        float32
//         ExecutionStepBuffer          float32
//         Ttl                          int64
//         ValidityStart                int64
//         LoadedUtxos                  []UTxO.UTxO
//         AuxiliaryData                Metadata.AuxiliaryData
//         NativeScripts                []PlutusData.ScriptHashable
//         Mint                         MultiAsset.MultiAsset[int64]
//         RequiredSigners              []serialization.PubKeyHash
//         Collaterals                  []UTxO.UTxO
//         Certificates                 []Certificate.Certificate
//         Withdrawals                  []Withdrawal.Withdrawal
//         ReferenceInputs              []TransactionInput.TransactionInput
//         Inputs                       []UTxO.UTxO
//         ExcludedInputs               []UTxO.UTxO
//         InputAddresses               []Address.Address
//         Outputs                      []TransactionOutput.TransactionOutput
//         Fee                          int64
//         Datums                       map[string]PlutusData.PlutusData
//         CollateralReturn             *TransactionOutput.TransactionOutput
//         TotalCollateral              int64
//         InputsToRedeemers            map[string]Redeemer.Redeemer
//         MintingScriptToRedeemers     []MintingScriptToRedeemer
//         InputsToScripts              map[string]PlutusData.ScriptHashable
//         ReferenceScripts             []PlutusData.ScriptHashable
//         ShouldEstimateExecutionUnits bool
// }

// func InitBuilder(context Base.ChainContext) TransactionBuilder {
//         txbuilder := TransactionBuilder{}
//         txbuilder.Context = context
//         txbuilder.UtxoSelectors = []CoinSelection.UTxOSelector{
//                 CoinSelection.LargestFirstSelector{},
//                 CoinSelection.RandomImproveMultiAsset{}}
//         txbuilder.ExecutionMemoryBuffer = 0.2
//         txbuilder.ExecutionStepBuffer = 0.2
//         txbuilder.ShouldEstimateExecutionUnits = true
//         txbuilder.AuxiliaryData = Metadata.AuxiliaryData{}
//         return txbuilder
// }

// func (tb *TransactionBuilder) AddLoadedUTxOs(loadedTxs []UTxO.UTxO) {
//         tb.LoadedUtxos = loadedTxs[:]
// }

// func (tb *TransactionBuilder) Redeemers() []Redeemer.Redeemer {
//         res := []Redeemer.Redeemer{}
//         for _, redeemer := range tb.InputsToRedeemers {
//                 res = append(res, redeemer)
//         }
//         for _, redeemer := range tb.MintingScriptToRedeemers {
//                 res = append(res, redeemer.Redeemer)
//         }
//         return res
// }

// func (tb *TransactionBuilder) RedeemersReferences() []*Redeemer.Redeemer {
//         res := []*Redeemer.Redeemer{}
//         for _, redeemer := range tb.InputsToRedeemers {
//                 res = append(res, &amp;redeemer)
//         }
//         for _, redeemer := range tb.MintingScriptToRedeemers {
//                 res = append(res, &amp;redeemer.Redeemer)
//         }
//         return res
// }

// func (tb *TransactionBuilder) AddInput(utxo UTxO.UTxO) {
//         tb.Inputs = append(tb.Inputs, utxo)
// }

// func (tb *TransactionBuilder) AddInputAddress(address Address.Address) {
//         tb.InputAddresses = append(tb.InputAddresses, address)
// }

// func (tb *TransactionBuilder) AddScriptInput(utxo UTxO.UTxO, script interface{}, datum *PlutusData.PlutusData, redeemer *Redeemer.Redeemer, isV1 bool) error {
//         if utxo.Output.GetAddress().AddressType != 0b0001 &amp;&amp;
//                 utxo.Output.GetAddress().AddressType != 0b0010 &amp;&amp;
//                 utxo.Output.GetAddress().AddressType != 0b0011 &amp;&amp;
//                 utxo.Output.GetAddress().AddressType != 0b0101 {
//                 return errors.New("expect the output address of utxo to of script type")
//         }

//         if datumHash, _ := PlutusData.HashDatum(datum); datum != nil &amp;&amp;
//                 utxo.Output.GetDatumHash() != nil &amp;&amp;
//                 !utxo.Output.GetDatumHash().Equal(datumHash) {
//                 return fmt.Errorf("datum hash in transaction output is %s, but actual datum hash from input datum is %s", hex.EncodeToString(utxo.Output.GetDatumHash().Payload[:]), hex.EncodeToString(datumHash.Payload))
//         }

//         if datum != nil {
//                 datumHash, _ := PlutusData.HashDatum(datum)
//                 x := hex.EncodeToString(datumHash.Payload)
//                 if tb.Datums == nil {
//                         tb.Datums = make(map[string]PlutusData.PlutusData)
//                 }
//                 tb.Datums[x] = *datum

//         }
//         if redeemer != nil {
//                 if tb.InputsToRedeemers == nil {
//                         tb.InputsToRedeemers = make(map[string]Redeemer.Redeemer)
//                 }
//                 tb.InputsToRedeemers[Utils.ToCbor(utxo)] = *redeemer
//         }
//         if script != nil {
//                 tb.InputsToScripts = make(map[string]PlutusData.ScriptHashable)
//         }
//         if utxo.Output.IsPostAlonzo &amp;&amp; len(*utxo.Output.PostAlonzo.ScriptRef) &gt; 0 {
//                 tb.InputsToScripts[Utils.ToCbor(utxo)] = PlutusData.PlutusV2Script(*utxo.Output.GetScriptRef())
//                 tb.ReferenceInputs = append(tb.ReferenceInputs, utxo.Input)
//                 tb.ReferenceScripts = append(tb.ReferenceScripts, PlutusData.PlutusV2Script(*utxo.Output.GetScriptRef()))
//         } else if script == nil {
//                 for _, i := range tb.LoadedUtxos {
//                         if i.Output.IsPostAlonzo &amp;&amp; len(*i.Output.PostAlonzo.ScriptRef) &gt; 0 {
//                                 tb.InputsToScripts[Utils.ToCbor(i)] = PlutusData.PlutusV2Script(*i.Output.GetScriptRef())
//                                 tb.ReferenceInputs = append(tb.ReferenceInputs, i.Input)
//                                 tb.ReferenceScripts = append(tb.ReferenceScripts, PlutusData.PlutusV2Script(*i.Output.GetScriptRef()))
//                                 break
//                         }
//                 }
//         } else {
//                 if isV1 {
//                         val, ok := script.(PlutusData.PlutusV1Script)
//                         if !ok {
//                                 return errors.New("script type error")
//                         }
//                         tb.InputsToScripts[Utils.ToCbor(utxo)] = val
//                 } else {
//                         val, ok := script.(PlutusData.PlutusV2Script)
//                         if !ok {
//                                 return errors.New("script type error")
//                         }
//                         tb.InputsToScripts[Utils.ToCbor(utxo)] = val
//                 }
//         }

//         tb.Inputs = append(tb.Inputs, utxo)
//         return nil
// }

// func (tb *TransactionBuilder) AddMintingScript(script interface{}, redeemer Redeemer.Redeemer) {
//         //TODO : implement
// }

// func (tb *TransactionBuilder) AddOutput(txOut TransactionOutput.TransactionOutput, datum *PlutusData.PlutusData, add_datum_to_witness bool) {
//         if datum != nil {
//                 txOut.SetDatum(datum)
//         }
//         tb.Outputs = append(tb.Outputs, txOut)
//         //TODO: implement
//         // if datum != nil &amp;&amp; add_datum_to_witness {
//         //         tb._datums [datum.Hash()] = datum
//         // }
// }

// func (tb *TransactionBuilder) _GetTotalKeyDeposit() int64 {
//         //TODO: Implement
//         return 0
// }

// func (tb *TransactionBuilder) _AddingAssetMakeOutputOverflow(
//         output TransactionOutput.TransactionOutput,
//         tempAssets Asset.Asset[int64],
//         policyId Policy.PolicyId,
//         assetName AssetName.AssetName,
//         amount int64,
//         maxValSize string) bool {
//         attemptAssets := tempAssets.Clone()
//         attemptAssets.Add(Asset.Asset[int64]{assetName: amount})
//         attemptMultiAsset := MultiAsset.MultiAsset[int64]{policyId: attemptAssets}

//         newAmount := Value.Value{Am: Amount.Amount{Coin: 0, Value: attemptMultiAsset}, Coin: 0, HasAssets: true}
//         currAmount := output.GetValue().Clone()

//         attemptAmount := newAmount.Add(currAmount)

//         requiredLovelace := Utils.MinLovelacePostAlonzo(TransactionOutput.SimpleTransactionOutput(output.GetAddress(), attemptAmount), tb.Context)

//         attemptAmount.SetLovelace(requiredLovelace)
//         bytes, _ := cbor.Marshal(attemptAmount)
//         maxValSz, _ := strconv.Atoi(maxValSize)
//         return len(bytes) &gt; maxValSz
// }

// func (tb *TransactionBuilder) _pack_multiassets_for_change(ChangeAddress Address.Address, ChangeEstimator Value.Value, maxValSize string) []MultiAsset.MultiAsset[int64] {
//         multiAssetArray := make([]MultiAsset.MultiAsset[int64], 0)
//         base_coin := Value.PureLovelaceValue(ChangeEstimator.GetCoin())
//         output := TransactionOutput.SimpleTransactionOutput(ChangeAddress, base_coin)
//         for policyId, assets := range ChangeEstimator.GetAssets() {
//                 tempMultiAsset := MultiAsset.MultiAsset[int64]{}
//                 tempValue := Value.Value{}
//                 tempAssets := Asset.Asset[int64]{}
//                 oldAmount := output.GetValue().Clone()
//                 for asset_name, amount := range assets {
//                         if tb._AddingAssetMakeOutputOverflow(
//                                 output,
//                                 tempAssets,
//                                 policyId,
//                                 asset_name,
//                                 amount,
//                                 maxValSize) {
//                                 tempMultiAsset = tempMultiAsset.Add(MultiAsset.MultiAsset[int64]{policyId: tempAssets})
//                                 tempValue.SetMultiAsset(tempMultiAsset)

//                                 multiAssetArray = append(multiAssetArray, output.GetValue().GetAssets())
//                                 baseCoin := Value.PureLovelaceValue(0)
//                                 output = TransactionOutput.SimpleTransactionOutput(ChangeAddress, baseCoin)
//                                 tempMultiAsset = MultiAsset.MultiAsset[int64]{}
//                                 tempValue = Value.Value{}
//                                 tempAssets = Asset.Asset[int64]{}
//                         }

//                         tempAssets = tempAssets.Add(Asset.Asset[int64]{asset_name: amount})
//                 }
//                 tempMultiAsset = tempMultiAsset.Add(MultiAsset.MultiAsset[int64]{policyId: tempAssets})
//                 tempValue.SetMultiAsset(tempMultiAsset)
//                 output.SetAmount(output.GetValue().Add(tempValue))
//                 updatedAmount := output.GetValue().Clone()
//                 required_lovelace := Utils.MinLovelacePostAlonzo(TransactionOutput.SimpleTransactionOutput(ChangeAddress, updatedAmount), tb.Context)
//                 updatedAmount.SetLovelace(required_lovelace)
//                 cbor, _ := cbor.Marshal(updatedAmount)
//                 maxValSz, _ := strconv.Atoi(maxValSize)
//                 if len(cbor) &gt; maxValSz {
//                         output.SetAmount(oldAmount)
//                         break
//                 }
//         }
//         multiAssetArray = append(multiAssetArray, output.GetValue().GetAssets())
//         return multiAssetArray
// }

// func (tb *TransactionBuilder) _CalcChange(fees int64, inputs []UTxO.UTxO, outputs []TransactionOutput.TransactionOutput, address Address.Address, preciseFee bool, respectMinUtxo bool) ([]TransactionOutput.TransactionOutput, error) {
//         changeOutputArr := make([]TransactionOutput.TransactionOutput, 0)
//         requested := Value.SimpleValue(fees, MultiAsset.MultiAsset[int64]{})
//         for _, output := range outputs {
//                 requested = requested.Add(output.GetValue())
//         }
//         provided := Value.Value{}
//         for _, input := range inputs {
//                 provided = provided.Add(input.Output.GetValue())
//         }
//         if tb.Mint != nil {
//                 provided.AddAssets(tb.Mint)
//         }
//         //TODO: Implement withdrawals
//         provided.SubLovelace(tb._GetTotalKeyDeposit())
//         if !requested.Less(provided) {
//                 return changeOutputArr, &amp;Errors.InvalidTransactionException{inputs, outputs, fees}
//         }
//         change := provided.Sub(requested)
//         if change.HasAssets {
//                 multiAsset := change.GetAssets()
//                 for policyId, assets := range multiAsset {
//                         for assetName, amount := range assets {
//                                 if amount == 0 {
//                                         delete(multiAsset[policyId], assetName)
//                                 }
//                         }
//                         if len(multiAsset[policyId]) == 0 {
//                                 delete(multiAsset, policyId)
//                         }
//                 }
//                 change.SetMultiAsset(multiAsset)
//         }

//         if !change.HasAssets {
//                 minLovelace := Utils.MinLovelacePostAlonzo(
//                         TransactionOutput.SimpleTransactionOutput(address, change), tb.Context)
//                 if respectMinUtxo &amp;&amp; change.GetCoin() &lt; minLovelace {
//                         return changeOutputArr, &amp;CoinSelection.InsufficientUtxoBalanceError{
//                                 fmt.Sprintf("The change output %v is less than the minimum Lovelace value %v", change.GetCoin(), minLovelace)}
//                 }
//                 lovelace_change := Value.PureLovelaceValue(change.GetCoin())
//                 changeOutputArr = append(changeOutputArr, TransactionOutput.SimpleTransactionOutput(address, lovelace_change))
//         }
//         if change.HasAssets {
//                 multiAssetArray := tb._pack_multiassets_for_change(address, change, tb.Context.GetProtocolParams().MaxValSize)
//                 for i, multiAsset := range multiAssetArray {
//                         if respectMinUtxo &amp;&amp; change.GetCoin() &lt; Utils.MinLovelacePostAlonzo(TransactionOutput.SimpleTransactionOutput(address, Value.SimpleValue(0, multiAsset)), tb.Context) {
//                                 return changeOutputArr, &amp;CoinSelection.InsufficientUtxoBalanceError{
//                                         fmt.Sprintf("Not Enough Ada left to cover non-ADA assets in change address")}
//                         }
//                         var changeValue Value.Value
//                         if i == len(multiAssetArray)-1 {
//                                 changeValue = Value.SimpleValue(change.GetCoin(), multiAsset)
//                         } else {
//                                 changeValue = Value.SimpleValue(0, multiAsset)
//                                 changeValue.SetLovelace(Utils.MinLovelacePostAlonzo(TransactionOutput.SimpleTransactionOutput(address, changeValue), tb.Context))
//                         }
//                         changeOutputArr = append(changeOutputArr, TransactionOutput.SimpleTransactionOutput(address, changeValue))
//                         change = change.Sub(changeValue)
//                 }
//         }
//         return changeOutputArr, nil
// }

// func (tb *TransactionBuilder) _MergeChanges(changes []TransactionOutput.TransactionOutput, change_output_index int) {
//         if change_output_index != -1 &amp;&amp; len(changes) == 1 {
//                 tb.Outputs[change_output_index].SetAmount(tb.Outputs[change_output_index].GetValue().Add(changes[0].GetValue()))
//         } else {
//                 tb.Outputs = append(tb.Outputs, changes...)
//         }

// }

// func (tb *TransactionBuilder) _AddChangeAndFee(
//         changeAddress *Address.Address,
//         mergeChange bool) error {
//         ogInputs := Utils.Copy(tb.Inputs)
//         ogOutputs := Utils.Copy(tb.Outputs)
//         changeOutputIndex := -1
//         if changeAddress != nil {
//                 if mergeChange {
//                         for i, output := range ogOutputs {
//                                 if changeAddress == output.GetAddressPointer() {
//                                         if changeOutputIndex == -1 || output.GetValue().GetCoin() == 0 {
//                                                 changeOutputIndex = i
//                                         }
//                                 }
//                         }
//                 }
//                 tb.Fee = tb._EstimateFee()
//                 changes, err := tb._CalcChange(tb.Fee, tb.Inputs, tb.Outputs, *changeAddress, true, !mergeChange)
//                 if err != nil {
//                         return err
//                 }
//                 tb._MergeChanges(changes, changeOutputIndex)
//         }
//         tb.Fee = tb._EstimateFee()

//         if changeAddress != nil {

//                 tb.Outputs = ogOutputs
//                 changes, err := tb._CalcChange(tb.Fee, ogInputs, ogOutputs, *changeAddress, true, !mergeChange)

//                 if err != nil {
//                         return err
//                 }
//                 tb._MergeChanges(changes, changeOutputIndex)
//         }
//         return nil
// }

// func (tb *TransactionBuilder) _EstimateFee() int64 {
//         plutusExecutionUnits := Redeemer.ExecutionUnits{Mem: 0, Steps: 0}
//         for _, redeemer := range tb.Redeemers() {
//                 plutusExecutionUnits.Sum(redeemer.ExUnits)
//         }
//         fullFakeTx, _ := tb._BuildFullFakeTx()
//         fakeTxBytes, _ := cbor.Marshal(fullFakeTx)
//         estimatedFee := Utils.Fee(tb.Context, len(fakeTxBytes), plutusExecutionUnits.Steps, plutusExecutionUnits.Mem, tb.ReferenceInputs)
//         return estimatedFee
// }

// func (tb *TransactionBuilder) _ScriptDataHash() *serialization.ScriptDataHash {
//         if len(tb.Datums) &gt; 0 || len(tb.Redeemers()) &gt; 0 {
//                 witnessSet := tb.BuildWitnessSet()
//                 sdh, _ := ScriptDataHash(
//                         tb.Context,
//                         witnessSet,
//                 )
//                 return &amp;serialization.ScriptDataHash{Payload: sdh.Payload}

//         }
//         return nil
// }

func ScriptDataHash(
        chainContext Base.ChainContext,
        witnessSet TransactionWitnessSet.TransactionWitnessSet,
) (*serialization.ScriptDataHash, error) <span class="cov0" title="0">{
        cost_models := map[int]cbor.Marshaler{}
        redeemers := witnessSet.Redeemer
        PV1Scripts := witnessSet.PlutusV1Script
        PV2Scripts := witnessSet.PlutusV2Script
        datums := witnessSet.PlutusData
        var err error
        isV1 := len(PV1Scripts) &gt; 0
        if len(redeemers) &gt; 0 </span><span class="cov0" title="0">{
                if len(PV2Scripts) &gt; 0 </span><span class="cov0" title="0">{
                        cost_models = PlutusData.COST_MODELSV2
                }</span> else<span class="cov0" title="0"> if !isV1 </span><span class="cov0" title="0">{
                        cost_models = PlutusData.COST_MODELSV2
                }</span>
        }
        <span class="cov0" title="0">var redeemer_bytes []byte

        if len(redeemers) == 0 </span><span class="cov0" title="0">{
                redeemer_bytes, _ = hex.DecodeString("a0")
        }</span> else<span class="cov0" title="0"> {
                redeemer_bytes, _ = cbor.Marshal(redeemers)
        }</span>
        <span class="cov0" title="0">var datum_bytes []byte
        if datums.Len() &gt; 0 </span><span class="cov0" title="0">{

                datum_bytes, err = cbor.Marshal(datums)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                datum_bytes = []byte{}
        }</span>
        <span class="cov0" title="0">var cost_model_bytes []byte
        if isV1 </span><span class="cov0" title="0">{
                cost_model_bytes, err = cbor.Marshal(PlutusData.COST_MODELSV1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        } else<span class="cov0" title="0"> {
                cost_model_bytes, err = cbor.Marshal(cost_models)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">total_bytes := append(redeemer_bytes, datum_bytes...)
        total_bytes = append(total_bytes, cost_model_bytes...)
        hash, err := serialization.Blake2bHash(total_bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;serialization.ScriptDataHash{Payload: hash}, nil</span>

}

// func (tb *TransactionBuilder) _BuildTxBody() TransactionBody.TransactionBody {
//         inputs := make([]TransactionInput.TransactionInput, 0)
//         for _, input := range tb.Inputs {
//                 inputs = append(inputs, input.Input)
//         }
//         collaterals := make([]TransactionInput.TransactionInput, 0)
//         for _, collateral := range tb.Collaterals {
//                 collaterals = append(collaterals, collateral.Input)
//         }
//         data_hash := tb._ScriptDataHash()
//         script_data_hash := make([]byte, 0)
//         if data_hash != nil {
//                 script_data_hash = data_hash.Payload
//         }
//         aux_data_hash := tb.AuxiliaryData.Hash()
//         return TransactionBody.TransactionBody{
//                 Inputs:            inputs,
//                 Outputs:           tb.Outputs,
//                 Fee:               tb.Fee,
//                 Ttl:               tb.Ttl,
//                 Mint:              tb.Mint,
//                 AuxiliaryDataHash: aux_data_hash,
//                 ScriptDataHash:    script_data_hash,
//                 RequiredSigners:   tb.RequiredSigners,
//                 ValidityStart:     tb.ValidityStart,
//                 Collateral:        collaterals,
//                 // Certificates:      tb.Certificates,
//                 // Withdrawals:       tb.Withdrawals,
//                 CollateralReturn: tb.CollateralReturn,
//                 TotalCollateral:  int(tb.TotalCollateral),
//                 ReferenceInputs:  tb.ReferenceInputs,
//         }
// }

// func (tb *TransactionBuilder) _InputVkeyHashes() []serialization.PubKeyHash {
//         result := make([]serialization.PubKeyHash, 0)
//         for _, input := range append(tb.Inputs, tb.Collaterals...) {
//                 pkh := serialization.PubKeyHash{}
//                 copy(pkh[:], input.Output.GetAddress().PaymentPart)
//                 result = append(result, pkh)
//         }
//         return result
// }

// // func (tb *TransactionBuilder) _BuildFakeVkeyWitnesses() []serialization.VerificationKeyWitness {
// //         vkey_hashes := tb._InputVkeyHashes()
// //         vkey_hashes = append(vkey_hashes, tb.RequiredSigners...)
// //         //vkey_hashes = append(vkey_hashes, tb._NativeScriptVkeyHashes()...)
// //         //vkey_hashes = append(vkey_hashes, tb._CertificateVkeyHashes()...)
// //         //vkey_hashes = append(vkey_hashes, tb._WithdrawalVkeyHashes()...)
// //         result := make([]serialization.VerificationKeyWitness, 0)
// //         for _, vkey_hash := range vkey_hashes {
// //                 result = append(result, serialization.VerificationKeyWitness{Vkey: serialization.VerificationKey{vkey_hash.Payload}, Signature: fake_tx_signature})
// //         }
// //         return result
// // }

// func (tb *TransactionBuilder) _BuildFakeWitnessSet() TransactionWitnessSet.TransactionWitnessSet {
//         witnessSet := tb.BuildWitnessSet()
//         //witnessSet.VkeyWitnesses = tb._BuildFakeVkeyWitnesses()
//         return witnessSet
// }
// func (tb *TransactionBuilder) AllScripts() []PlutusData.ScriptHashable {
//         allscripts := []PlutusData.ScriptHashable{}
//         allscripts = append(allscripts, tb.NativeScripts...)
//         for _, s := range tb.InputsToScripts {
//                 allscripts = append(allscripts, s)
//         }
//         for _, s := range tb.MintingScriptToRedeemers {
//                 allscripts = append(allscripts, s.Script)
//         }
//         return allscripts
// }

// func (tb *TransactionBuilder) Scripts() ([]NativeScript.NativeScript, []PlutusData.PlutusV1Script, []PlutusData.PlutusV2Script) {
//         nativeScripts := make([]NativeScript.NativeScript, 0)
//         plutusV1Scripts := make([]PlutusData.PlutusV1Script, 0)
//         plutusV2Scripts := make([]PlutusData.PlutusV2Script, 0)
//         redeemers := tb.Redeemers()
//         if len(tb.Datums) &gt; 0 || len(redeemers) &gt; 0 || len(tb.NativeScripts) &gt; 0 {
//                 for _, script := range tb.AllScripts() {
//                         switch script.(type) {
//                         case NativeScript.NativeScript:
//                                 nativeScripts = append(nativeScripts, script.(NativeScript.NativeScript))
//                         case PlutusData.PlutusV1Script:
//                                 plutusV1Scripts = append(plutusV1Scripts, script.(PlutusData.PlutusV1Script))
//                         case PlutusData.PlutusV2Script:
//                                 plutusV2Scripts = append(plutusV2Scripts, script.(PlutusData.PlutusV2Script))
//                         }
//                 }
//         }
//         return nativeScripts, plutusV1Scripts, plutusV2Scripts
// }

// func (tb *TransactionBuilder) _BuildFullFakeTx() (Transaction.Transaction, error) {
//         tmp_builder := tb.Copy()
//         txBody := tmp_builder._BuildTxBody()
//         if txBody.Fee == 0 {
//                 txBody.Fee = int64(tmp_builder.Context.MaxTxFee())
//         }
//         witness := tmp_builder._BuildFakeWitnessSet()
//         tx := Transaction.Transaction{
//                 TransactionBody:       txBody,
//                 TransactionWitnessSet: witness,
//         }
//         bytes, _ := cbor.Marshal(tx)
//         if len(bytes) &gt; tmp_builder.Context.GetProtocolParams().MaxTxSize {
//                 return tx, &amp;Errors.TransactionTooBigError{
//                         fmt.Sprintf("Transaction is too big, %d bytes, max is %d", len(bytes), tmp_builder.Context.GetProtocolParams().MaxTxSize)}
//         }
//         return tx, nil
// }

// func (tb *TransactionBuilder) BuildWitnessSet() TransactionWitnessSet.TransactionWitnessSet {
//         nativeScripts, plutusV1Scripts, plutusV2Scripts := tb.Scripts()
//         plutusdata := make([]PlutusData.PlutusData, 0)
//         for _, datum := range tb.Datums {
//                 plutusdata = append(plutusdata, datum)
//         }
//         if len(plutusdata) == 0 {
//                 return TransactionWitnessSet.TransactionWitnessSet{
//                         NativeScripts:  nativeScripts,
//                         PlutusV1Script: plutusV1Scripts,
//                         PlutusV2Script: plutusV2Scripts,
//                         PlutusData:     nil,
//                         Redeemer:       tb.Redeemers(),
//                 }
//         }
//         return TransactionWitnessSet.TransactionWitnessSet{
//                 NativeScripts:  nativeScripts,
//                 PlutusV1Script: plutusV1Scripts,
//                 PlutusV2Script: plutusV2Scripts,
//                 PlutusData:     PlutusData.PlutusIndefArray(plutusdata),
//                 Redeemer:       tb.Redeemers(),
//         }
// }

// func (tb *TransactionBuilder) _EnsureNoInputExclusionConflict() error {
//         for _, input := range tb.Inputs {
//                 for _, excluded := range tb.ExcludedInputs {
//                         if reflect.DeepEqual(input, excluded) {
//                                 return &amp;Errors.InputExclusionError{fmt.Sprintf("Input %v is both included and excluded", input.Input)}
//                         }
//                 }
//         }
//         return nil
// }

// func (tb *TransactionBuilder) _SetCollateralReturn(changeAddress *Address.Address) error {
//         witnesses := tb._BuildFakeWitnessSet()
//         if len(witnesses.PlutusV1Script) == 0 &amp;&amp;
//                 len(witnesses.PlutusV2Script) == 0 &amp;&amp;
//                 len(tb.ReferenceScripts) == 0 {
//                 return nil
//         }

//         if changeAddress == nil {
//                 return nil
//         }
//         collateral_amount := 5_000_000 //tb.Context.MaxTxFee() * tb.Context.GetProtocolParams().CollateralPercent / 100
//         total_input := Value.Value{}
//         for _, utxo := range tb.Collaterals {
//                 total_input = total_input.Add(utxo.Output.GetValue())
//         }
//         if int64(collateral_amount) &gt; total_input.GetCoin() {
//                 return errors.New("Not enough collateral to cover fee")
//         }
//         return_amount := total_input.GetCoin() - int64(collateral_amount)
//         min_lovelace := Utils.MinLovelacePostAlonzo(TransactionOutput.SimpleTransactionOutput(*changeAddress, Value.PureLovelaceValue(return_amount)), tb.Context)
//         if min_lovelace &gt; return_amount {
//                 return errors.New("Not enough collateral to cover fee")
//         } else {
//                 returnOutput := TransactionOutput.SimpleTransactionOutput(*changeAddress, Value.PureLovelaceValue(return_amount))
//                 tb.CollateralReturn = &amp;returnOutput
//                 tb.TotalCollateral = int64(collateral_amount)
//         }
//         return nil
// }

// func (tb *TransactionBuilder) Build(changeAddress *Address.Address, mergeChange bool, collateralChangeAddress *Address.Address) (TransactionBody.TransactionBody, error) {
//         err := tb._EnsureNoInputExclusionConflict()
//         if err != nil {
//                 return TransactionBody.TransactionBody{}, err
//         }
//         selectedUtxos := make([]UTxO.UTxO, 0)
//         selectedAmount := Value.Value{}
//         for _, input := range tb.Inputs {
//                 selectedUtxos = append(selectedUtxos, input)
//                 selectedAmount = selectedAmount.Add(input.Output.GetValue())
//         }

//         // TODO figure out how to handle generic type conversion.... (Mint is int64 but it can only ever be uint in a Value)
//         if tb.Mint != nil {
//                 selectedAmount.AddAssets(tb.Mint)
//         }
//         if tb.Withdrawals != nil {
//                 //TODO: implement WIthdrawals
//         }

//         canMergeChange := false
//         if mergeChange {
//                 for _, output := range tb.Outputs {
//                         addr := output.GetAddress()
//                         if addr.Equal(changeAddress) {
//                                 canMergeChange = true
//                                 break
//                         }
//                 }
//         }

//         selectedAmount.SubLovelace(tb._GetTotalKeyDeposit())
//         requestedAmount := Value.Value{}
//         for _, output := range tb.Outputs {
//                 requestedAmount = requestedAmount.Add(output.GetValue())
//         }
//         requestedAmount.AddLovelace(tb._EstimateFee())

//         trimmedSelectedAmount := Value.SimpleValue(selectedAmount.GetCoin(),
//                 selectedAmount.GetAssets().Filter(func(policy Policy.PolicyId, asset AssetName.AssetName, quantity int64) bool {
//                         for requestedPolicy, requestedAsset := range requestedAmount.GetAssets() {
//                                 for requestedAssetName, _ := range requestedAsset {
//                                         if requestedPolicy == policy &amp;&amp; requestedAssetName == asset {
//                                                 return true
//                                         }
//                                 }
//                         }
//                         return false
//                 }),
//         )
//         unfulfilledAmount := requestedAmount.Sub(trimmedSelectedAmount)
//         if changeAddress != nil &amp;&amp; !canMergeChange {
//                 if unfulfilledAmount.GetCoin() &lt; 0 {
//                         estimated := unfulfilledAmount.GetCoin() +
//                                 Utils.MinLovelacePostAlonzo(
//                                         TransactionOutput.SimpleTransactionOutput(*changeAddress, selectedAmount.Sub(trimmedSelectedAmount)), tb.Context)
//                         if estimated &lt; 0 {
//                                 estimated = 0
//                         }
//                         unfulfilledAmount.SetLovelace(
//                                 estimated)
//                 }
//         } else {
//                 if unfulfilledAmount.GetCoin() &lt; 0 {
//                         unfulfilledAmount.SetLovelace(0)
//                 }
//         }
//         unfulfilledAmount = unfulfilledAmount.RemoveZeroAssets()

//         emptyVal := Value.Value{}
//         if emptyVal.Less(unfulfilledAmount) &amp;&amp; !(unfulfilledAmount.GetCoin() == 0 &amp;&amp; len(unfulfilledAmount.GetAssets()) == 0) {
//                 additionalUtxoPool := make([]UTxO.UTxO, 0)
//                 additionalAmount := Value.Value{}
//                 if tb.LoadedUtxos == nil {
//                         for _, address := range tb.InputAddresses {
//                                 for _, utxo := range tb.Context.Utxos(address) {
//                                         if !Utils.Contains(selectedUtxos, utxo) &amp;&amp;
//                                                 !Utils.Contains(tb.ExcludedInputs, utxo) &amp;&amp;
//                                                 len(utxo.Output.GetDatumHash().Payload) == 0 {
//                                                 additionalUtxoPool = append(additionalUtxoPool, utxo)
//                                                 additionalAmount = additionalAmount.Add(utxo.Output.GetValue())
//                                         }
//                                 }
//                         }
//                 } else {
//                         for _, utxo := range tb.LoadedUtxos {
//                                 if !Utils.Contains(selectedUtxos, utxo) &amp;&amp;
//                                         !Utils.Contains(tb.ExcludedInputs, utxo) &amp;&amp;
//                                         len(utxo.Output.GetDatumHash().Payload) == 0 {
//                                         additionalUtxoPool = append(additionalUtxoPool, utxo)
//                                         additionalAmount = additionalAmount.Add(utxo.Output.GetValue())
//                                 }
//                         }
//                 }
//                 for _, selector := range tb.UtxoSelectors {
//                         selected, _, err := selector.Select(
//                                 additionalUtxoPool,
//                                 []TransactionOutput.TransactionOutput{TransactionOutput.SimpleTransactionOutput(FAKE_ADDRESS, unfulfilledAmount)},
//                                 tb.Context,
//                                 -1,
//                                 false,
//                                 !canMergeChange,
//                         )
//                         if err != nil {
//                                 //TODO MULTI SELECTOR
//                                 return TransactionBody.TransactionBody{}, err
//                         }
//                         for _, s := range selected {
//                                 selectedUtxos = append(selectedUtxos, s)
//                                 selectedAmount = selectedAmount.Add(s.Output.GetValue())
//                         }
//                         break
//                 }
//         }
//         tb.Inputs = selectedUtxos[:]

//         tb._SetRedeemerIndex()
//         if collateralChangeAddress != nil {
//                 tb._SetCollateralReturn(collateralChangeAddress)
//         } else {
//                 tb._SetCollateralReturn(changeAddress)
//         }

//         tb._UpdateExecutionUnits(changeAddress, mergeChange, collateralChangeAddress)

//         err = tb._AddChangeAndFee(changeAddress, mergeChange)
//         if err != nil {
//                 return TransactionBody.TransactionBody{}, err
//         }
//         tx_body := tb._BuildTxBody()
//         return tx_body, nil

// }

// func (tb *TransactionBuilder) Copy() *TransactionBuilder {
//         InputsToRedeemers := make(map[string]Redeemer.Redeemer)
//         for k, v := range tb.InputsToRedeemers {
//                 InputsToRedeemers[k] = v.Clone()
//         }

//         return &amp;TransactionBuilder{
//                 tb.Context,
//                 tb.UtxoSelectors,
//                 tb.ExecutionMemoryBuffer,
//                 tb.ExecutionStepBuffer,
//                 tb.Ttl,
//                 tb.ValidityStart,
//                 Utils.Copy(tb.LoadedUtxos),
//                 tb.AuxiliaryData,
//                 tb.NativeScripts,
//                 tb.Mint,
//                 tb.RequiredSigners,
//                 tb.Collaterals,
//                 tb.Certificates,
//                 tb.Withdrawals,
//                 tb.ReferenceInputs,
//                 Utils.Copy(tb.Inputs),
//                 Utils.Copy(tb.ExcludedInputs),
//                 tb.InputAddresses,
//                 Utils.Copy(tb.Outputs),
//                 tb.Fee,
//                 tb.Datums,
//                 tb.CollateralReturn,
//                 tb.TotalCollateral,
//                 InputsToRedeemers,
//                 tb.MintingScriptToRedeemers,
//                 tb.InputsToScripts,
//                 tb.ReferenceScripts,
//                 false,
//         }
// }

// func (tb *TransactionBuilder) _EstimateExecutionUnits(changeAddress *Address.Address, mergeChange bool, collateralChangeAddress *Address.Address) map[string]Redeemer.ExecutionUnits {
//         tmp_builder := tb.Copy()
//         tmp_builder.ShouldEstimateExecutionUnits = false
//         tx_body, _ := tmp_builder.Build(changeAddress, mergeChange, collateralChangeAddress)
//         witness_set := tb._BuildFakeWitnessSet()
//         tx := Transaction.Transaction{TransactionBody: tx_body, TransactionWitnessSet: witness_set, Valid: false}
//         tx_cbor, _ := cbor.Marshal(tx)
//         return tb.Context.EvaluateTx(tx_cbor)

// }

// func (tb *TransactionBuilder) _UpdateExecutionUnits(changeAddress *Address.Address, mergeChange bool, collateralChangeAddress *Address.Address) {
//         if tb.ShouldEstimateExecutionUnits {
//                 estimated_execution_units := tb._EstimateExecutionUnits(changeAddress, mergeChange, collateralChangeAddress)
//                 for k, redeemer := range tb.InputsToRedeemers {
//                         key := fmt.Sprintf("%s:%d", Redeemer.RedeemerTagNames[redeemer.Tag], redeemer.Index)
//                         if _, ok := estimated_execution_units[key]; ok {
//                                 redeemer.ExUnits = estimated_execution_units[key]
//                                 tb.InputsToRedeemers[k] = redeemer
//                         }
//                 }

//         }
// }

// func SortInputs(inputs []UTxO.UTxO) []UTxO.UTxO {
//         hashes := make([]string, 0)
//         relationMap := map[string]UTxO.UTxO{}
//         for _, utxo := range inputs {
//                 hashes = append(hashes, string(utxo.Input.TransactionId))
//                 relationMap[string(utxo.Input.TransactionId)] = utxo
//         }
//         sort.Strings(hashes)
//         sorted_inputs := make([]UTxO.UTxO, 0)
//         for _, hash := range hashes {
//                 sorted_inputs = append(sorted_inputs, relationMap[hash])
//         }
//         return sorted_inputs
// }

// func (tb *TransactionBuilder) _SetRedeemerIndex() {
//         sorted_inputs := SortInputs(tb.Inputs)
//         done := make([]string, 0)
//         for i, utxo := range sorted_inputs {
//                 utxo_cbor := Utils.ToCbor(utxo)
//                 if slices.Contains(done, utxo_cbor) {
//                         continue
//                 }
//                 val, ok := tb.InputsToRedeemers[utxo_cbor]
//                 if ok &amp;&amp; val.Tag == Redeemer.SPEND {
//                         done = append(done, utxo_cbor)
//                         redeem := tb.InputsToRedeemers[utxo_cbor]
//                         redeem.Index = i
//                         tb.InputsToRedeemers[utxo_cbor] = redeem
//                 } else if ok &amp;&amp; val.Tag == Redeemer.MINT {
//                         //TODO: IMPLEMENT FOR MINTS
//                 }
//         }
//         // for script,redeemer := range tb.MintingScriptToRedeemers {
//         //         //TODO IMPLEMENT THIS
//         // }

// }
</pre>
		
		<pre class="file" id="file49" style="display: none">package Utils

import (
        "encoding/hex"
        "math"

        "github.com/Salvionied/apollo/serialization"
        "github.com/Salvionied/apollo/serialization/TransactionInput"
        "github.com/Salvionied/apollo/serialization/TransactionOutput"
        "github.com/Salvionied/apollo/serialization/UTxO"
        "github.com/Salvionied/apollo/txBuilding/Backend/Base"

        "github.com/fxamacker/cbor/v2"
)

func Contains[T UTxO.Container[any]](container []T, contained T) bool <span class="cov0" title="0">{
        for _, c := range container </span><span class="cov0" title="0">{
                if c.EqualTo(contained) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func MinLovelacePostAlonzo(
        output TransactionOutput.TransactionOutput,
        context Base.ChainContext,
) (int64, error) <span class="cov0" title="0">{
        constantOverhead := 200
        amt := output.GetValue()
        if amt.Coin == 0 </span><span class="cov0" title="0">{
                amt.Coin = 1_000_000
        }</span>
        <span class="cov0" title="0">tmp_out := TransactionOutput.TransactionOutput{
                IsPostAlonzo: true,
                PostAlonzo: TransactionOutput.TransactionOutputAlonzo{
                        Address:   output.GetAddress(),
                        Amount:    output.GetValue().ToAlonzoValue(),
                        Datum:     output.GetDatumOption(),
                        ScriptRef: output.GetScriptRef(),
                },
        }
        encoded, err := cbor.Marshal(tmp_out)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">pps, err := context.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return int64(
                (constantOverhead + len(encoded)) * pps.GetCoinsPerUtxoByte(),
        ), nil</span>
}

func ToCbor(x any) (string, error) <span class="cov0" title="0">{
        bytes, err := cbor.Marshal(x)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

func Fee(
        context Base.ChainContext,
        txSize int,
        steps int64,
        mem int64,
        refInputs []TransactionInput.TransactionInput,
) (int64, error) <span class="cov0" title="0">{
        pps, err := context.GetProtocolParams()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">addedFee := 0
        refInputsSize := 0
        if len(refInputs) &gt; 0 </span><span class="cov0" title="0">{
                // APPLY CONWAY FEE
                for _, refInput := range refInputs </span><span class="cov0" title="0">{
                        utxo, err := context.GetUtxoFromRef(
                                hex.EncodeToString(refInput.TransactionId),
                                refInput.Index,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if utxo == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">scriptRef := utxo.Output.GetScriptRef()
                        if scriptRef != nil </span><span class="cov0" title="0">{
                                refInputsSize += scriptRef.Len()
                        }</span>
                }

        }
        <span class="cov0" title="0">mult := 1.2
        baseFee := 15.0
        Range := 25600.0
        for refInputsSize &gt; 0 </span><span class="cov0" title="0">{
                cur := math.Min(Range, float64(refInputsSize))
                curFee := cur * baseFee
                addedFee += int(curFee)
                refInputsSize -= int(cur)
                baseFee = baseFee * mult
        }</span>

        <span class="cov0" title="0">fee := int64(txSize)*pps.MinFeeCoefficient +
                pps.MinFeeConstant +
                int64(float32(steps)*pps.PriceStep) +
                int64(float32(mem)*pps.PriceMem) + int64(addedFee)
        return fee, nil</span>
}

func Copy[T serialization.Clonable[T]](input []T) []T <span class="cov0" title="0">{
        res := make([]T, 0)
        for _, value := range input </span><span class="cov0" title="0">{
                res = append(res, value.Clone())
        }</span>
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
